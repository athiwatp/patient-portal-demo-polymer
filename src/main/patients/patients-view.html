<html><head><meta charset="UTF-8"><link rel="import" href="../../patient-portal.html"></head><body><div hidden="" by-vulcanize=""><!--
@license
Copyright (c) 2016 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
--><dom-module id="vaadin-grid-active-item-themability-styles" assetpath="/">
  <template>
    <style>
      table tr[active] .vaadin-grid-cell:not([detailscell]) ::content > .cell-content {
        @apply(--vaadin-grid-body-row-active-cell);
      }
    </style>
  </template>
</dom-module>

<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.ActiveItemBehavior
   */
  vaadin.elements.grid.ActiveItemBehavior = {

    properties: {
      /*
       * The item user has last interacted with. Turns to `null` after user deactivates
       * the item by re-interacting with the currently active item.
       */
      activeItem: {
        type: Object,
        notify: true
      }
    },

    listeners: {
      'cell-activate': '_activateItem'
    },

    observers: [
      '_activeItemChanged(activeItem)'
    ],

    _activateItem: function(e) {
      var clickedItem = e.detail.model.item;

      this.activeItem = this.activeItem !== clickedItem ? clickedItem : null;

      e.stopImmediatePropagation();
    },

    _activeItemChanged: function() {
      if (this.$.scroller._physicalItems) {
        this.$.scroller._physicalItems.forEach(function(row) {
          this._updateItem(row, row.item);
        }.bind(this));
      }
    }
  };
</script>
<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>

  /**
   * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll events from a
   * designated scroll target.
   *
   * Elements that consume this behavior can override the `_scrollHandler`
   * method to add logic on the scroll event.
   *
   * @demo demo/scrolling-region.html Scrolling Region
   * @demo demo/document.html Document Element
   * @polymerBehavior
   */
  Polymer.IronScrollTargetBehavior = {

    properties: {

      /**
       * Specifies the element that will handle the scroll event
       * on the behalf of the current element. This is typically a reference to an element,
       * but there are a few more posibilities:
       *
       * ### Elements id
       *
       *```html
       * <div id="scrollable-element" style="overflow: auto;">
       *  <x-element scroll-target="scrollable-element">
       *    <!-- Content-->
       *  </x-element>
       * </div>
       *```
       * In this case, the `scrollTarget` will point to the outer div element.
       *
       * ### Document scrolling
       *
       * For document scrolling, you can use the reserved word `document`:
       *
       *```html
       * <x-element scroll-target="document">
       *   <!-- Content -->
       * </x-element>
       *```
       *
       * ### Elements reference
       *
       *```js
       * appHeader.scrollTarget = document.querySelector('#scrollable-element');
       *```
       *
       * @type {Element}
       */
      scrollTarget: {
        type: Object,
        value: function() {
          return this._defaultScrollTarget;
        }
      }
    },

    observers: [
      '_scrollTargetChanged(scrollTarget, isAttached)'
    ],

    /**
     * True if the event listener should be installed.
     */
    _shouldHaveListener: true,

    _scrollTargetChanged: function(scrollTarget, isAttached) {
      var eventTarget;

      if (this._oldScrollTarget) {
        this._toggleScrollListener(false, this._oldScrollTarget);
        this._oldScrollTarget = null;
      }
      if (!isAttached) {
        return;
      }
      // Support element id references
      if (scrollTarget === 'document') {

        this.scrollTarget = this._doc;

      } else if (typeof scrollTarget === 'string') {

        this.scrollTarget = this.domHost ? this.domHost.$[scrollTarget] :
            Polymer.dom(this.ownerDocument).querySelector('#' + scrollTarget);

      } else if (this._isValidScrollTarget()) {

        this._boundScrollHandler = this._boundScrollHandler || this._scrollHandler.bind(this);
        this._oldScrollTarget = scrollTarget;
        this._toggleScrollListener(this._shouldHaveListener, scrollTarget);

      }
    },

    /**
     * Runs on every scroll event. Consumer of this behavior may override this method.
     *
     * @protected
     */
    _scrollHandler: function scrollHandler() {},

    /**
     * The default scroll target. Consumers of this behavior may want to customize
     * the default scroll target.
     *
     * @type {Element}
     */
    get _defaultScrollTarget() {
      return this._doc;
    },

    /**
     * Shortcut for the document element
     *
     * @type {Element}
     */
    get _doc() {
      return this.ownerDocument.documentElement;
    },

    /**
     * Gets the number of pixels that the content of an element is scrolled upward.
     *
     * @type {number}
     */
    get _scrollTop() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
      }
      return 0;
    },

    /**
     * Gets the number of pixels that the content of an element is scrolled to the left.
     *
     * @type {number}
     */
    get _scrollLeft() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
      }
      return 0;
    },

    /**
     * Sets the number of pixels that the content of an element is scrolled upward.
     *
     * @type {number}
     */
    set _scrollTop(top) {
      if (this.scrollTarget === this._doc) {
        window.scrollTo(window.pageXOffset, top);
      } else if (this._isValidScrollTarget()) {
        this.scrollTarget.scrollTop = top;
      }
    },

    /**
     * Sets the number of pixels that the content of an element is scrolled to the left.
     *
     * @type {number}
     */
    set _scrollLeft(left) {
      if (this.scrollTarget === this._doc) {
        window.scrollTo(left, window.pageYOffset);
      } else if (this._isValidScrollTarget()) {
        this.scrollTarget.scrollLeft = left;
      }
    },

    /**
     * Scrolls the content to a particular place.
     *
     * @method scroll
     * @param {number} left The left position
     * @param {number} top The top position
     */
    scroll: function(left, top) {
       if (this.scrollTarget === this._doc) {
        window.scrollTo(left, top);
      } else if (this._isValidScrollTarget()) {
        this.scrollTarget.scrollLeft = left;
        this.scrollTarget.scrollTop = top;
      }
    },

    /**
     * Gets the width of the scroll target.
     *
     * @type {number}
     */
    get _scrollTargetWidth() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
      }
      return 0;
    },

    /**
     * Gets the height of the scroll target.
     *
     * @type {number}
     */
    get _scrollTargetHeight() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
      }
      return 0;
    },

    /**
     * Returns true if the scroll target is a valid HTMLElement.
     *
     * @return {boolean}
     */
    _isValidScrollTarget: function() {
      return this.scrollTarget instanceof HTMLElement;
    },

    _toggleScrollListener: function(yes, scrollTarget) {
      if (!this._boundScrollHandler) {
        return;
      }
      var eventTarget = scrollTarget === this._doc ? window : scrollTarget;

      if (yes) {
        eventTarget.addEventListener('scroll', this._boundScrollHandler);
      } else {
        eventTarget.removeEventListener('scroll', this._boundScrollHandler);
      }
    },

    /**
     * Enables or disables the scroll event listener.
     *
     * @param {boolean} yes True to add the event, False to remove it.
     */
    toggleScrollListener: function(yes) {
      this._shouldHaveListener = yes;
      this._toggleScrollListener(yes, this.scrollTarget);
    }

  };

</script><dom-module id="vaadin-grid-table-scroll-styles" assetpath="/">
  <template>
    <style>
      :host {
        transform: translateZ(0);
      }

      thead {
        position: absolute;
        top: 0;
        width: 100%;
      }

      tfoot {
        position: absolute;
        bottom: 0;
        width: 100%;
      }

      tbody {
        z-index: -1;
      }

      table {
        position: relative;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        z-index: -2;

        /* translate Z needed to be applied to keep scroll bars from disappearing
        when scrolling on desktop Safari.
        Also, this rule can't be applied on mobile
        Safari to keep scroll bars visible in there :-) */
        transform: translateZ(0);
      }

      :host([ios]) table {
        transform: none;
      }

      :host([fixed-sections]) {
        /* Any value other than ‘none’ for the transform results in the creation of both a stacking context and
        a containing block. The object acts as a containing block for fixed positioned descendants. */
        transform: translateZ(0);
        overflow: hidden;
      }

      :host([fixed-sections]) thead,
      :host([fixed-sections]) tfoot {
        position: fixed;
      }

      :host([fixed-sections]) tbody#items {
        position: fixed;
        width: 100%;
        will-change: transform;
      }

      :host([fixed-sections]) table {
        transform: none;
      }

    </style>
  </template>
</dom-module>

<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.TableScrollBehaviorImpl
   */
  vaadin.elements.grid.TableScrollBehaviorImpl = {

    properties: {

      _vidxOffset: {
        value: 0
      },

      ios: {
        value: navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/),
        reflectToAttribute: true
      },

      fixedSections: {
        type: Boolean,
        reflectToAttribute: true,
        computed: '_hasFixedSections(scrollbarWidth)'
      },

      // Cached array of frozen cells
      _frozenCells: {
        type: Array,
        value: function() {
          return [];
        }
      },

      scrolling: {
        type: Boolean,
        reflectToAttribute: true
      }
    },

    listeners: {
      'table.wheel': '_onWheel'
    },

    ready: function() {
      this.scrollTarget = this.$.table;
    },

    /**
     * Scroll to a specific index (also scaled indexes) in the virtual list.
     */
    scrollToScaledIndex: function(idx) {
      this._pendingScrollToScaledIndex = null;
      if (!this.$.items.style.borderTopWidth) {
        // Schedule another scroll to be invoked once init is complete
        this._pendingScrollToScaledIndex = idx;
      }

      idx = Math.min(Math.max(idx, 0), this.size - 1);
      this.$.table.scrollTop = idx / this.size * this.$.table.scrollHeight;
      this._scrollHandler();
      this.scrollToIndex(idx - this._vidxOffset);

      // TODO: This is a hack to get around offset issues when scrolling to bottom.
      // Revisit iron-list-behavior for cleaner fix.
      if (this._vidxOffset + this.lastVisibleIndex === this.size - 1) {
        this.$.table.scrollTop = this.$.table.scrollHeight - this.$.table.offsetHeight;
      }
    },

    _hasFixedSections: function(scrollbarWidth) {
      return navigator.userAgent.match(/Edge/) && scrollbarWidth === 0;
    },

    _onWheel: function(e) {
      if (e.ctrlKey) {
        return;
      }

      var table = this.$.table;
      var momentum = Math.abs(e.deltaX) + Math.abs(e.deltaY);

      if (
        (e.deltaY > 0 && table.scrollTop < table.scrollHeight - table.offsetHeight) ||
        (e.deltaY < 0 && table.scrollTop > 0) ||
        (e.deltaX > 0 && table.scrollLeft < table.scrollWidth - table.offsetWidth) ||
        (e.deltaX < 0 && table.scrollLeft > 0)
      ) {
        e.preventDefault();
        table.scrollTop += e.deltaY;
        table.scrollLeft += e.deltaX;
        this._scrollHandler();

        this._ignoreNewWheel = this.debounce('ignore-new-wheel', function() {
          this._ignoreNewWheel = null;
        }, 500);
      } else if (momentum <= this._previousMomentum || this._ignoreNewWheel) {
        e.preventDefault();
      }
      this._previousMomentum = momentum;
    },

    /**
     * Update the models, the position of the
     * items in the viewport and recycle tiles as needed.
     */
    _scrollHandler: function(e) {
      // clamp the `scrollTop` value
      var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
      var delta = scrollTop - this._scrollPosition;
      var tileHeight, kth, recycledTileSet, scrollBottom, physicalBottom;
      var ratio = this._ratio;
      var recycledTiles = 0;
      var hiddenContentSize = this._hiddenContentSize;
      var currentRatio = ratio;
      var movingUp = [];

      // track the last `scrollTop`
      this._scrollPosition = scrollTop;

      // clear cached visible indexes
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;

      scrollBottom = this._scrollBottom;
      physicalBottom = this._physicalBottom;

      // random access
      if (Math.abs(delta) > this._physicalSize) {
        this._physicalTop += delta;
        recycledTiles = Math.round(delta / this._physicalAverage);
      // scroll up
      } else if (delta < 0) {
        var topSpace = scrollTop - this._physicalTop;
        var virtualStart = this._virtualStart;

        recycledTileSet = [];

        kth = this._physicalEnd;
        currentRatio = topSpace / hiddenContentSize;

        // move tiles from bottom to top
        while (
            // approximate `currentRatio` to `ratio`
            currentRatio < ratio &&
            // recycle less physical items than the total
            recycledTiles < this._physicalCount &&
            // ensure that these recycled tiles are needed
            virtualStart - recycledTiles > 0 &&
            // ensure that the tile is not visible
            physicalBottom - this._getPhysicalSizeIncrement(kth) > scrollBottom
        ) {

          tileHeight = this._getPhysicalSizeIncrement(kth);
          currentRatio += tileHeight / hiddenContentSize;
          physicalBottom -= tileHeight;
          recycledTileSet.push(kth);
          recycledTiles++;
          kth = (kth === 0) ? this._physicalCount - 1 : kth - 1;
        }

        movingUp = recycledTileSet;
        recycledTiles = -recycledTiles;
      // scroll down
      } else if (delta > 0) {
        var bottomSpace = physicalBottom - scrollBottom;
        var virtualEnd = this._virtualEnd;
        var lastVirtualItemIndex = this._virtualCount - 1;

        recycledTileSet = [];

        kth = this._physicalStart;
        currentRatio = bottomSpace / hiddenContentSize;

        // move tiles from top to bottom
        while (
            // approximate `currentRatio` to `ratio`
            currentRatio < ratio &&
            // recycle less physical items than the total
            recycledTiles < this._physicalCount &&
            // ensure that these recycled tiles are needed
            virtualEnd + recycledTiles < lastVirtualItemIndex &&
            // ensure that the tile is not visible
            this._physicalTop + this._getPhysicalSizeIncrement(kth) < scrollTop
          ) {

          tileHeight = this._getPhysicalSizeIncrement(kth);
          currentRatio += tileHeight / hiddenContentSize;

          this._physicalTop += tileHeight;
          recycledTileSet.push(kth);
          recycledTiles++;
          kth = (kth + 1) % this._physicalCount;
        }
      }

      if (this._virtualCount < this.size) {
        this._adjustVirtualIndexOffset(delta);
      }

      if (recycledTiles === 0) {
        // Try to increase the pool if the list's client height isn't filled up with physical items
        if (physicalBottom < scrollBottom || this._physicalTop > scrollTop) {
          this._increasePoolIfNeeded();
        }
      } else {
        this._virtualStart = this._virtualStart + recycledTiles;
        this._physicalStart = this._physicalStart + recycledTiles;
        this._update(recycledTileSet, movingUp);
      }

      this._translateStationaryElements();

      this.scrolling = true;
      this.debounce('vaadin-grid-scrolling', function() {
        this.scrolling = false;
        this._reorderRows();
      }, 100);
    },

    _adjustVirtualIndexOffset: function(delta) {
      if (Math.abs(delta) > 10000) {
        if (this._noScale) {
          this._noScale = false;
          return;
        }

        var scale = Math.round(this._scrollPosition / this._scrollHeight * 1000) / 1000;
        var offset = scale * this.size;

        this._vidxOffset = Math.round(offset - scale * this._virtualCount);

        if (this._scrollTop === 0) {
          // fixes issues when scrolling to start but correct items are not bound. :-()
          this.scrollToIndex(0);
        }
      } else {
        // Make sure user can always swipe/wheel scroll to the start and end
        // TODO: causes a small jump in the scroll handle

        var oldOffset = this._vidxOffset || 0;
        var threshold = 1000;
        var maxShift = 100;

        // At start
        if (this._scrollTop === 0) {
          this._vidxOffset = 0;
          if (oldOffset !== this._vidxOffset) {
            this.scrollToIndex(0);
          }
        } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {
          this._vidxOffset -= Math.min(this._vidxOffset, maxShift);
          this.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset) + 1);
          this._noScale = true;
        }

        // At end
        var maxOffset = this.size - this._virtualCount;
        if (this._scrollTop >= this._maxScrollTop) {
          this._vidxOffset = maxOffset;
          if (oldOffset !== this._vidxOffset) {
            this.scrollToIndex(this._virtualCount);
          }
        } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {
          this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);
          this.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));
          this._noScale = true;
        }

      }
    },

    _reorderRows: function() {
      var tbody = Polymer.dom(this.$.items);
      var items = tbody.querySelectorAll('tr');
      var _adjustedVirtualStart = this._virtualStart + this._vidxOffset;

      // DOM index of the element with the lowest index
      var physicalIndexOfFirst = items.length - (items[0].index - _adjustedVirtualStart);

      // Reorder the DOM elements
      if (physicalIndexOfFirst < items.length / 2) {
        // Append all the preceding elements after the last element
        for (var i = 0; i < physicalIndexOfFirst; i++) {
          tbody.appendChild(items[i]);
        }
      } else {
        // Prepend all the trailing elements before the first element
        for (var j = physicalIndexOfFirst; j < items.length; j++) {
          tbody.insertBefore(items[j], items[0]);
        }
      }
    },

    _frozenCellsChanged: function() {
      this.debounce('cache-elements', function() {
        Polymer.dom(this.root).querySelectorAll('td, th').forEach(function(cell) {
          cell.style.transform = '';
        });
        this._frozenCells = Polymer.dom(this.root).querySelectorAll('[frozen]');
        this._translateStationaryElements();
      });
      this._updateLastFrozen();
    },

    _updateLastFrozen: function() {
      var columnsRow = this.columnTree[this.columnTree.length - 1].slice(0);
      columnsRow.sort(function(a, b) {
        return a._order - b._order;
      });
      var lastFrozen = columnsRow.reduce(function(prev, col, index) {
        col._lastFrozen = false;
        return col.frozen && !col.hidden ? index : prev;
      }, undefined);
      if (lastFrozen !== undefined) {
        columnsRow[lastFrozen]._lastFrozen = true;
      }
    },

    _translateStationaryElements: function() {
      if (this.fixedSections) {
        this.$.items.style.transform =
        this._getTranslate3d(-this._scrollLeft || 0, -this._scrollTop || 0);

        this.$.footer.style.transform = this.$.header.style.transform =
        this._getTranslate3d(-this._scrollLeft || 0, 0);
      } else {
        this.$.footer.style.transform = this.$.header.style.transform = this._getTranslate3d(0, this._scrollTop);
      }

      var frozenCellTransform = this._getTranslate3d(this._scrollLeft, 0);
      for (var i = 0; i < this._frozenCells.length; i++) {
        this._frozenCells[i].style.transform = frozenCellTransform;
      }
    },

    _getTranslate3d: function(x, y) {
      return 'translate3d(' + x + 'px,' + y + 'px, 0)';
    }

  };

  /**
   * @polymerBehavior vaadin.elements.grid.TableScrollBehavior
   */
  vaadin.elements.grid.TableScrollBehavior = [
    Polymer.IronScrollTargetBehavior,
    vaadin.elements.grid.TableScrollBehaviorImpl
  ];

</script>
<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.CellClickBehavior
   */
  vaadin.elements.grid.CellClickBehavior = {

    listeners: {
      'click': '_onClick'
    },

    attached: function() {
      this._cellContentFocusHandler = function(e) {
        // IE11 fires `focus` events for the cell content element even when nothing
        // focusable was clicked.
        if (e.target !== this._cellContent) {
          this.fire('cell-content-focus', {cell: this});
        }
      }.bind(this);

      // we need to capture focus events originating from elements inside this cell,
      // capture mode seems to be required in order it to work.
      this.addEventListener('focus', this._cellContentFocusHandler, true);
    },

    detached: function() {
      this.removeEventListener('focus', this._cellContentFocusHandler, true);
    },

    // we need to listen to click instead of tap because on mobile safari, the
    // document.activeElement has not been updated (focus has not been shifted)
    // yet at the point when tap event is being executed.
    _onClick: function(e) {
      // this event is only supposed to be fired from cells.
      if (this.localName !== 'vaadin-grid-sorter') {
        this.fire('cell-focus', {cell: this});
      }

      // Prevent item action if cell itself is not focused.
      if (this._cellClick) {
        var target = Polymer.dom(e).localTarget;
        // Polymer.dom(e).localTarget usually returns <content> element in shady
        // DOM. We'll get and use the cell-content wrapper in that case.
        if (target.getDistributedNodes) {
          target = Polymer.dom(target).getDistributedNodes()[0];
        }

        var path = Polymer.dom(e).path;
        var elementsClicked = Array.prototype.slice.call(path, 0, path.indexOf(target) + 1);
        if (!target.contains(this.target && this.target.root.activeElement || document.activeElement) &&
            !elementsClicked.some(this._isFocusable)) {
          this._cellClick(e);
        }
      }
    },

    _isFocusable: function(target) {
      return target.matches &&
             target.matches(':not([disabled])') &&
             (target.matches('[tabindex]') ||
             target.matches('button, input, select, textarea, object, iframe, label') ||
             target.matches('a[href], area[href]'));
    }
  };
</script>
<dom-module id="vaadin-grid-table-cell" assetpath="/"></dom-module>
<dom-module id="vaadin-grid-table-header-cell" assetpath="/"></dom-module>
<dom-module id="vaadin-grid-table-footer-cell" assetpath="/"></dom-module>
<dom-module id="vaadin-grid-sizer-cell" assetpath="/"></dom-module>

<script>
  (function() {

    /**
     * @polymerBehavior vaadinGridTableCellBehavior
     */
    var vaadinGridTableCellBehavior = {
      properties: {
        column: Object,
        expanded: Boolean,
        flexGrow: Number,
        focused: {
          type: Boolean,
          reflectToAttribute: true
        },
        frozen: {
          type: Boolean,
          reflectToAttribute: true
        },
        lastFrozen: {
          type: Boolean,
          reflectToAttribute: true
        },
        hidden: {
          type: Boolean,
          reflectToAttribute: true
        },
        instance: Object,
        index: Number,
        item: Object,
        selected: Boolean,
        template: Object,
        target: Object,
        width: String,
        order: Number,
        reorderStatus: {
          type: String,
          reflectToAttribute: true
        },

        _childColumns: Array,

        _cellContent: Object,
        _insertionPoint: Object,
        _templatizer: Object
      },

      observers: ['_columnChanged(column)',
        '_cellAttached(column, isAttached)',
        '_expandedChanged(expanded, instance)',
        '_flexGrowChanged(flexGrow)',
        '_indexChanged(index, instance)',
        '_itemChanged(item, instance)',
        '_instanceChanged(instance, target)',
        '_selectedChanged(selected, instance)',
        '_toggleContent(isAttached, _cellContent, _insertionPoint)',
        '_toggleInstance(isAttached, _templatizer, instance)',
        '_widthChanged(width)',
        '_orderChanged(order)',
        '_visibleChildColumnsChanged(_visibleChildColumns)',
        '_childColumnsChanged(_childColumns)'
      ],

      created: function() {
        this.classList.add('vaadin-grid-cell');
      },

      _columnChanged: function(column) {
        this.flexGrow = column.flexGrow;
        this.frozen = column.frozen;
        this.lastFrozen = column._lastFrozen;
        this.headerTemplate = column.headerTemplate;
        this.footerTemplate = column.footerTemplate;
        this.template = column.template;
        this.width = column.width;
        this.hidden = column.hidden;
        this.resizable = column.resizable;
        this._childColumns = column._childColumns;
        this.order = column._order;

        // Assigning undefined to element.colSpan will set colSpan attribute to 0
        if (column.colSpan) {
          this.colSpan = column.colSpan;
        }

        this.listen(column, 'property-changed', '_columnPropChanged');
      },

      _cellAttached: function(column, isAttached) {
        // Cells get detached when the column tree changes and new cells are created.
        // Also, cells get detached and attached during row reordering after scrolling.
        if (isAttached) {
          this.listen(column, 'property-changed', '_columnPropChanged');
        } else {
          this.unlisten(column, 'property-changed', '_columnPropChanged');
        }
      },

      _columnPropChanged: function(e) {
        if (e.target == this.column) {
          this[e.detail.path] = e.detail.value;
        }
      },

      _expandedChanged: function(expanded, instance) {
        instance.__expanded__ = expanded;
        instance.expanded = expanded;
      },

      _flexGrowChanged: function(flexGrow) {
        this.style.flexGrow = flexGrow;
      },

      _indexChanged: function(index, instance) {
        instance.index = index;
      },

      _itemChanged: function(item, instance) {
        instance.item = item;
      },

      _selectedChanged: function(selected, instance) {
        instance.__selected__ = selected;
        instance.selected = selected;
      },

      _childColumnsChanged: function(childColumns) {
        this.colSpan = childColumns.length;
      },

      _toggleContent: function(isAttached, cellContent, insertionPoint) {
        if (isAttached) {
          if (Polymer.dom(cellContent).parentNode !== this.target) {
            Polymer.dom(this.target).appendChild(cellContent);
          }
          Polymer.dom(this).appendChild(insertionPoint);
        } else {
          this.debounce('remove-content', function() {
            if (!this.isAttached && Polymer.dom(cellContent).parentNode === this.target) {
              Polymer.dom(this.target).removeChild(cellContent);
            }
          }, 1);
        }
      },

      _toggleInstance: function(isAttached, templatizer, instance) {
        if (isAttached) {
          templatizer.addInstance(instance);
        } else {
          templatizer.removeInstance(instance);
        }
      },

      _widthChanged: function(width) {
        this.style.width = width;
      },

      _orderChanged: function(order) {
        this.style.order = order;
      },

      _templateChanged: function(template) {
        this.instance = template.templatizer.createInstance();
        this._templatizer = template.templatizer;
      },

      _instanceChanged: function(instance, target) {
        this.style.height = '';

        this._cellContent = document.createElement('div');
        this._cellContent.setAttribute('class', 'cell-content');
        var contentId = target._contentIndex = target._contentIndex + 1 || 0;
        this._cellContent.setAttribute('data-cell-content-id', contentId);
        Polymer.dom(this._cellContent).appendChild(this.instance.root);

        this._insertionPoint = document.createElement('content');
        this._insertionPoint.setAttribute('select', '[data-cell-content-id="' + contentId + '"]');
      },
    };

    Polymer({
      is: 'vaadin-grid-table-cell',

      extends: 'td',

      behaviors: [
        vaadinGridTableCellBehavior,
        vaadin.elements.grid.CellClickBehavior
      ],

      observers: ['_templateChanged(template)'],

      _cellClick: function() {
        this.fire('cell-activate', {
          model: this.instance
        });
      }
    });

    Polymer({
      is: 'vaadin-grid-table-header-cell',

      extends: 'th',

      properties: {
        headerTemplate: Object,

        resizable: Boolean,

        columnResizing: {
          type: Boolean,
          reflectToAttribute: true
        }
      },

      behaviors: [
        vaadinGridTableCellBehavior,
        vaadin.elements.grid.CellClickBehavior
      ],

      observers: [
        '_headerTemplateChanged(headerTemplate, isAttached)',
        '_resizableChanged(resizable)'
      ],

      listeners: {
        'track': '_onTrack',
        'mousedown': '_cancelMouseDownOnResize',
        'mousemove': '_enableDrag',
        'mouseout': '_disableDrag'
      },

      _enableDrag: function() {
        // Text inside draggable grid cells can't be selected. Thus we need to
        // check the global selection state here to avoid a cell becoming
        // draggable while text is being selected.
        this._cellContent.draggable = this.target.columnReorderingAllowed && !window.getSelection().toString();
      },

      _disableDrag: function() {
        this._cellContent.draggable = false;
      },

      _cancelMouseDownOnResize: function(e) {
        if (e.target === this._resizeHandle) {
          e.preventDefault();
        }
      },

      _resizableChanged: function(resizable) {
        if (resizable) {
          this._resizeHandle = document.createElement('div');
          this._resizeHandle.classList.add('vaadin-grid-column-resize-handle');
          Polymer.dom(this).appendChild(this._resizeHandle);
        } else if (this._resizeHandle) {
          Polymer.dom(this).removeChild(this._resizeHandle);
        }
      },

      _onTrack: function(e) {
        if (e.target === this._resizeHandle) {
          this.columnResizing = true;

          var column = this.column;
          // Mind reorder
          if (column.localName === 'vaadin-grid-column-group') {
            column = column._childColumns.slice(0)
            .sort(function(a, b) {
              return a._order - b._order;
            })
            .pop();
          }

          var targetCell = this._getHeaderCellByColumn(column);
          if (targetCell.offsetWidth) {
            var style = window.getComputedStyle(targetCell._cellContent);
            var minWidth = 10 + parseInt(style.paddingLeft) + parseInt(style.paddingRight);
            column.width = Math.max(minWidth, targetCell.offsetWidth + e.detail.x - targetCell.getBoundingClientRect().right) + 'px';
            column.flexGrow = 0;
          }
        }

        if (this.columnResizing && e.detail.state === 'end') {
          this.columnResizing = false;
        }
      },

      _getHeaderCellByColumn: function(column) {
        var thead = this.parentElement.parentElement;
        return Polymer.dom(thead).querySelectorAll('tr:last-child th').filter(function(cell) {
          return cell.column === column;
        })[0];
      },

      _headerTemplateChanged: function(headerTemplate, isAttached) {
        if (headerTemplate !== null && (this._isColumnRow || this.column.localName === 'vaadin-grid-column-group')) {
          this._isEmpty = false;
          this.instance = this.instance || headerTemplate.templatizer.createInstance();
          this._templatizer = headerTemplate.templatizer;
        } else {
          this._isEmpty = true;
          this.instance = this.instance || {root: document.createElement('div')};
        }

        // Safari 9 doesn't bubble events while not attached to the DOM. #552
        if (isAttached) {
          this.fire('cell-empty-changed');
        }
      }
    });

    Polymer({
      is: 'vaadin-grid-table-footer-cell',

      extends: 'td',

      properties: {
        footerTemplate: Object
      },

      behaviors: [
        vaadinGridTableCellBehavior,
        vaadin.elements.grid.CellClickBehavior
      ],

      observers: ['_footerTemplateChanged(footerTemplate, isAttached)'],

      _footerTemplateChanged: function(footerTemplate, isAttached) {
        if (footerTemplate !== null && (this._isColumnRow || this.column.localName === 'vaadin-grid-column-group')) {
          this._isEmpty = false;
          this.instance = this.instance || footerTemplate.templatizer.createInstance();
          this._templatizer = footerTemplate.templatizer;
        } else {
          this._isEmpty = true;
          this.instance = this.instance || {root: document.createElement('div')};
        }

        // Safari 9 doesn't bubble events while not attached to the DOM. #552
        if (isAttached) {
          this.fire('cell-empty-changed');
        }
      }
    });

    Polymer({
      is: 'vaadin-grid-sizer-cell',

      behaviors: [vaadinGridTableCellBehavior]
    });
  })();
</script>
<dom-module id="vaadin-grid-sizer" assetpath="/">
  <template>
    <style>
      :host {
        display: flex;
        position: relative;
        width: 100%;
        visibility: hidden;
        line-height: 0;
      }

      .cell {
        display: block;
        flex-shrink: 0;
        transform: translateY(-1em);
      }
    </style>

    <template is="dom-repeat" items="[[_columns]]" as="column">
      <vaadin-grid-sizer-cell class="cell" column="[[column]]">&nbsp;</vaadin-grid-sizer-cell>
    </template>

  </template>
  <script>
    Polymer({
      is: 'vaadin-grid-sizer',

      extends: 'div',

      properties: {
        columnTree: Array,

        top: Number,

        _columns: Array
      },

      observers: [
        '_columnTreeChanged(columnTree)',
        '_topChanged(top)'
      ],

      _columnTreeChanged: function(columnTree) {
        this._columns = columnTree[columnTree.length - 1];
      },

      _topChanged: function(top) {
        this.style.top = top + 'px';
      }
    });
  </script>
</dom-module>
<dom-module id="vaadin-grid-table-outer-scroller" assetpath="/">
  <template>
    <style>
      :host {
        display: block;
        height: 100%;
        width: 100%;
        position: absolute;
        top: 0;
        box-sizing: border-box;
        overflow: auto;
      }

      :host([passthrough]) {
        pointer-events: none;
      }

      :host([ios]) {
        pointer-events: all;
        z-index: -3;
      }

      :host([ios][scrolling]) {
        z-index: 0;
      }
    </style>

    <content></content>

  </template>
  <script>
    Polymer({
      is: 'vaadin-grid-table-outer-scroller',

      properties: {
        scrollTarget: {
          observer: '_scrollTargetChanged'
        },

        passthrough: {
          reflectToAttribute: true,
          value: true
        }
      },

      listeners: {
        'scroll': '_syncScrollTarget'
      },

      attached: function() {
        this.listen(this.domHost, 'mousemove', '_onMouseMove');

        // for some reason scroll bars are hidden in iOS if this style is
        // added in stylesheets or before attaching.
        this.style.webkitOverflowScrolling = 'touch';
      },

      detached: function() {
        this.unlisten(this.domHost, 'mousemove', '_onMouseMove');
      },

      _scrollTargetChanged: function(scrollTarget, oldScrollTarget) {
        if (oldScrollTarget) {
          this.unlisten(oldScrollTarget, 'scroll', '_syncOuterScroller');
        }
        this.listen(scrollTarget, 'scroll', '_syncOuterScroller');
      },

      _onMouseMove: function(e) {
        this.passthrough = e.offsetY <= this.clientHeight && e.offsetX <= this.clientWidth;
      },

      _syncOuterScroller: function() {
        if (!this._syncingScrollTarget) {
          this._syncingOuterScroller = true;
          this.scrollTop = this.domHost._scrollTop;
          this.scrollLeft = this.domHost._scrollLeft;
        }
        this._syncingScrollTarget = false;
      },

      _syncScrollTarget: function() {
        if (!this._syncingOuterScroller) {
          this._syncingScrollTarget = true;
          this.scrollTarget.scrollTop = this.scrollTop;
          this.scrollTarget.scrollLeft = this.scrollLeft;
          this.domHost._scrollHandler();
        }
        this._syncingOuterScroller = false;
      }

    });
  </script>
</dom-module>
<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.FocusableCellContainerBehavior
   */
  vaadin.elements.grid.FocusableCellContainerBehavior = {
    properties: {
      focused: {
        type: Boolean,
        reflectToAttribute: true
      },
      _focusedRow: Object,
      _focusedRowIndex: Number,
      _focusedCell: Object,
      _focusedCellIndex: Number
    },

    observers: ['_focusedCellChanged(_focusedRowIndex, _focusedCellIndex)'],

    _focusedCellChanged: function(rowIndex, cellIndex) {
      Polymer.dom(this).children.forEach(function(row, i) {
        row.focused = i === rowIndex;

        if (row.focused) {
          this._focusedRow = row;
          this._focusedCellIndex = Math.min(cellIndex, row.children.length - 1);
          this._focusedCell = row.children[this._focusedCellIndex];
        }

        row.cells.forEach(function(cell, j) {
          cell.focused = j === this._focusedCellIndex;
        }.bind(this));
      }.bind(this));
    },

    focusLeft: function() {
      var visibleCells = this._visibleCellIndexes();
      if (visibleCells.length > 0) {
        var current = visibleCells.indexOf(this._focusedCellIndex);
        this._focusedCellIndex = visibleCells[Math.max(0, current - 1)];
      }
    },

    focusDown: function() {
      this._focusedRowIndex = Math.min(this._focusedRowIndex + 1, this.children.length - 1);
    },

    _visibleCellIndexes: function() {
      var indexes = [];
      if (this._focusedRow && this._focusedRow.children) {
        var children = this._focusedRow.children;
        for(var i = 0; i < children.length; i++) {
          if (!children[i].hidden) {
            indexes.push(i);
          }
        }

        indexes.sort(function(i1, i2) {
          return children[i1].column._order < children[i2].column._order ? -1 : 1;
        });
      }

      return indexes;
    },

    focusPageDown: function() {
      this._focusedRowIndex = Math.min(this._focusedRowIndex + 10, this.children.length - 1);
    },

    focusPageUp: function() {
      this._focusedRowIndex = Math.max(0, this._focusedRowIndex - 10);
    },

    focusRight: function() {
      var visibleCells = this._visibleCellIndexes();
      if (visibleCells.length > 0) {
        var current = visibleCells.indexOf(this._focusedCellIndex);
        this._focusedCellIndex = visibleCells[Math.min(current + 1, visibleCells.length - 1)];
      }
    },

    focusUp: function() {
      this._focusedRowIndex = Math.max(0, this._focusedRowIndex - 1);
    },

    focusHome: function() {
      var visibleCells = this._visibleCellIndexes();
      if (visibleCells.length > 0) {
        this._focusedCellIndex = visibleCells[0];
      }
    },

    focusEnd: function() {
      var visibleCells = this._visibleCellIndexes();
      if (visibleCells.length > 0) {
        this._focusedCellIndex = visibleCells[visibleCells.length - 1];
      }
    },

    focusFirst: function(e) {
      this._focusedRowIndex = 0;
      this.focusHome();
    },

    focusLast: function(e) {
      this._focusedRowIndex = this.children.length - 1;
      this.focusEnd();
    }
  };
</script>
<script>
  (function() {

    /**
     * @polymerBehavior vaadinGridTableRowContainerBehavior
     */
    var vaadinGridTableRowContainerBehavior = {
      properties: {
        columnTree: Array,
        target: Object,
        _rows: Array
      },

      observers: ['_columnTreeChanged(columnTree, target)', '_rowsChanged(_rows)'],

      _columnTreeChanged: function(columnTree, target) {
        if (this._rows) {
          this._rows.forEach(function(row) {
            Polymer.dom(row).innerHTML = '';
          });
        }

        var rows = [];
        for(var i = 0; i < columnTree.length; i++) {
          var row = this._createRow();
          row.target = target;
          row._isColumnRow = i == columnTree.length - 1;
          row.columns = columnTree[i];
          rows.push(row);
        }

        this._rows = this.localName === 'thead' ? rows : rows.reverse();
      },

      _rowsChanged: function(rows) {
        Polymer.dom(this).innerHTML = '';

        rows.forEach(function(row) {
          Polymer.dom(this).appendChild(row);
        }.bind(this));
      }
    };

    Polymer({
      is: 'vaadin-grid-table-header',
      extends: 'thead',
      behaviors: [vaadinGridTableRowContainerBehavior,
        vaadin.elements.grid.FocusableCellContainerBehavior],

      _createRow: function() {
        return document.createElement('tr', 'vaadin-grid-table-header-row');
      }
    });

    Polymer({
      is: 'vaadin-grid-table-body',
      extends: 'tbody',
      behaviors: [vaadin.elements.grid.FocusableCellContainerBehavior],

      focusDown: function() {
        this._focusedRowIndex = Math.min(this._focusedRowIndex + 1, this.domHost.size - 1);
      },

      focusUp: function() {
        this._focusedRowIndex = Math.max(0, this._focusedRowIndex - 1);
      },

      focusLast: function() {
        this._focusedRowIndex = this.domHost.size - 1;
        this.focusEnd();
      },

      _focusedCellChanged: function(rowIndex, cellIndex) {
        Polymer.dom(this).children.forEach(function(row) {
          row.focused = row.index === rowIndex;

          if (row.index === rowIndex) {
            this._focusedRow = row;
            this._focusedCell = row.children[cellIndex];
          }

          row.cells.forEach(function(cell, idx) {
            cell.focused = idx === cellIndex;
          });
        }.bind(this));
      }
    });

    Polymer({
      is: 'vaadin-grid-table-footer',
      extends: 'tfoot',
      behaviors: [vaadinGridTableRowContainerBehavior,
        vaadin.elements.grid.FocusableCellContainerBehavior],

      _createRow: function() {
        return document.createElement('tr', 'vaadin-grid-table-footer-row');
      }
    });
  })();
</script><dom-module id="vaadin-grid-table-row" assetpath="/"></dom-module>
<dom-module id="vaadin-grid-table-header-row" assetpath="/"></dom-module>

<script>
  (function() {

    /**
     * @polymerBehavior vaadinGridTableRowBehavior
     */
    var vaadinGridTableRowBehavior = {

      extends: 'tr',

      properties: {
        active: {
          type: Boolean,
          reflectToAttribute: true,
          value: false
        },
        columns: Array,
        index: Number,
        cells: {
          value: []
        },
        target: Object,

        expanded: {
          value: false
        },

        focused: {
          type: Boolean,
          reflectToAttribute: true
        },

        item: Object,

        selected: {
          reflectToAttribute: true
        },

        _rowDetailsCell: Object,

        rowDetailsTemplate: Object
      },

      observers: [
        '_columnsChanged(columns, target)',
        '_indexChanged(index, cells)',
        '_itemChanged(item, cells)',
        '_itemChangedForDetails(item, _rowDetailsCell)',
        '_rowDetailsChanged(expanded, rowDetailsTemplate, target)',
        '_rowDetailsCellIndexChanged(_rowDetailsCell, index)',
        '_rowDetailsCellChanged(_rowDetailsCell, target)',
        '_selectedChanged(selected, cells)',
        '_selectedChangedForDetails(selected, _rowDetailsCell)',
      ],

      iterateCells: function(callback) {
        this.cells.forEach(callback);
        if (this._rowDetailsCell) {
          callback(this._rowDetailsCell);
        }
      },

      _rowDetailsChanged: function(expanded, rowDetailsTemplate, target) {
        if (expanded) {
          // TODO: template instance for each detail cell is pushed to the template.instances
          // but never cleaned up. Maybe consider just hiding details instead of removing.
          var rowDetailsCell = document.createElement('td', 'vaadin-grid-table-cell');
          rowDetailsCell.setAttribute('detailscell', true);
          // Using a frozen cell as the details cell works as a handy way of
          // making it float in place
          rowDetailsCell.frozen = true;
          rowDetailsCell.target = target;
          rowDetailsCell.template = rowDetailsTemplate;
          rowDetailsCell.toggleAttribute('lastcolumn', true);
          Polymer.dom(this.root).appendChild(rowDetailsCell);
          Polymer.dom.flush();
          this._rowDetailsCell = rowDetailsCell;

        } else {
          if (this._rowDetailsCell) {
            Polymer.dom(this.root).removeChild(this._rowDetailsCell);
            this.style.paddingBottom = '';
            this._rowDetailsCell = null;
          }
        }

        this.iterateCells(function(cell) {
          cell.expanded = expanded;
        });

        // Row details uses a frozen cell to need to invoke this to update cache
        this.target.$.scroller._frozenCellsChanged();
      },

      _updateRowVisibility: function() {
        this.hidden = this.cells.every(function(cell) {
          return cell._isEmpty;
        });
      },

      _rowDetailsCellChanged: function(_rowDetailsCell, target) {
        // paddingBottom must be set before update() is called!
        // make sure observers are in the correct order!
        target.$.scroller._update();
      },

      _rowDetailsCellIndexChanged: function(_rowDetailsCell, index, target) {
        if (_rowDetailsCell) {
          _rowDetailsCell.index = index;
          this.style.paddingBottom = _rowDetailsCell.style.height = _rowDetailsCell.clientHeight + 'px';
        }
      },

      _columnsChanged: function(columns, target) {
        Polymer.dom(this).innerHTML = '';

        var cells = [];

        columns.forEach(function(column, columnIndex) {
          // Get a cached cell instance if one is available
          var cacheName = '_' + this.is.replace(/-/g, '_') + '_cells';
          var cache = column[cacheName] = column[cacheName] || [];
          var cell = cache.filter(function(cell) {
            return !Polymer.dom(cell).parentNode;
          })[0];
          if (!cell) {
            cell = this._createCell();
            cache.push(cell);
          }

          cell.index = this.index;
          cell.target = this.target;
          cell._isColumnRow = this._isColumnRow;
          cell.column = column;

          Polymer.dom(this).appendChild(cell);
          cells.push(cell);

        }.bind(this));

        this.cells = cells;
      },

      _indexChanged: function(index, cells, _rowDetailsCell) {
        cells.forEach(function(cell) {
          cell.index = index;
        });
      },

      _itemChanged: function(item, cells) {
        cells.forEach(function(cell) {
          // use assignment here instead of notifyPath to avoid triggering
          // forwardInstancePath for path "item" on cells unnecessarily.
          cell.item = item;
        });
      },

      _itemChangedForDetails: function(item, rowDetails) {
        if (rowDetails) {
          rowDetails.item = item;
        }
      },

      _selectedChanged: function(selected, cells) {
        cells.forEach(function(cell) {
          cell.selected = selected;
        });
      },

      _selectedChangedForDetails: function(selected, rowDetails) {
        if (rowDetails) {
          rowDetails.selected = selected;
        }
      },

      updateLastColumn: function() {
        this.cells.slice(0).sort(function(a, b) {
          return a.column._order - b.column._order;
        }).forEach(function(cell, cellIndex, children) {
          cell.toggleAttribute('lastcolumn', cellIndex === children.length - 1);
        });
      }

    };

    Polymer({
      is: 'vaadin-grid-table-row',

      behaviors: [
        vaadinGridTableRowBehavior
      ],

      _createCell: function() {
        return document.createElement('td', 'vaadin-grid-table-cell');
      }
    });

    Polymer({
      is: 'vaadin-grid-table-header-row',

      behaviors: [
        vaadinGridTableRowBehavior
      ],

      observers: [
        '_updateRowVisibility(columns)'
      ],

      listeners: {
        'cell-empty-changed': '_updateRowVisibility'
      },

      _createCell: function() {
        return document.createElement('th', 'vaadin-grid-table-header-cell');
      }

    });

    Polymer({
      is: 'vaadin-grid-table-footer-row',

      behaviors: [
        vaadinGridTableRowBehavior
      ],

      observers: [
        '_updateRowVisibility(columns)'
      ],

      listeners: {
        'cell-empty-changed': '_updateRowVisibility'
      },

      _createCell: function() {
        return document.createElement('td', 'vaadin-grid-table-footer-cell');
      }

    });

  })();
</script>
<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  vaadin.elements.grid.Templatizer = Polymer({
    is: 'vaadin-grid-templatizer',

    factoryImpl: function(dataHost) {
      this.dataHost = dataHost;
    },

    behaviors: [Polymer.Templatizer],

    properties: {
      template: Object,

      _forwardedParentProps: Object,
      _templateInstances: Array
    },

    observers: ['_templateChanged(template)', '_forwardedParentPropsChanged(_forwardedParentProps.*, _templateInstances)'],

    created: function() {
      this._instanceProps = {
        expanded: true,
        index: true,
        item: true,
        selected: true
      };
    },

    createInstance: function() {
      var instance = this.stamp(null);
      this.addInstance(instance);

      return instance;
    },

    addInstance: function(instance) {
      if (this._templateInstances.indexOf(instance) === -1) {
        this._templateInstances.push(instance);
      }
    },

    removeInstance: function(instance) {
      var index = this._templateInstances.indexOf(instance);

      this._templateInstances.splice(index, 1);
    },

    _templateChanged: function(template) {
      this._forwardedParentProps = {};
      this._templateInstances = [];
      template.templatizer = this;
      this.templatize(template);

      // TODO: hack to avoid: https://github.com/Polymer/polymer/issues/3307
      this._parentProps = this._parentProps || {};
    },

    _forwardInstanceProp: function(inst, prop, value) {
      // fire notification event only when a prop is changed through a user-action.
      // e.g. 'expanded' is different from the originally bound '__expanded__' value.
      if (inst['__' + prop + '__'] !== undefined &&
        inst['__' + prop + '__'] !== value) {
        this.fire('template-instance-changed', {
          prop: prop,
          value: value,
          inst: inst
        });
      }
    },

    _forwardInstancePath: function(inst, path, value) {
      // TODO: assuming we're currently just listening to [[item.xxxx]] properties
      // which affect only cells on the current row.
      if (path.indexOf('item.') === 0 && !this._suppressItemChangeEvent) {
        this.fire('item-changed', {
          item: inst.item,
          // stripping 'item.' from path.
          path: path.substring(5),
          value: value
        });
      }
    },

    _forwardParentProp: function(prop, value) {
      // _forwardParentProp might be called during this.stamp() before
      // this.instance is set. We need to delay it until instance is set.
      this.set('_forwardedParentProps.' + prop, value);
    },

    _forwardParentPath: function(path, value) {
      this.set('_forwardedParentProps.' + path, value);
    },

    _forwardedParentPropsChanged: function(e, templateInstances) {
      if (e.path !== '_forwardedParentProps') {
        var prop = e.path.substring(e.path.indexOf('.') + 1);
        var value = e.value;

        templateInstances.forEach(function(inst) {
          inst.notifyPath(prop, value);
        });
      }
    }
  });
</script><dom-module id="vaadin-grid-row-details-styles" assetpath="/">
  <template>
    <style>
      [detailscell] {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
      }
    </style>
  </template>
</dom-module>
<dom-module id="vaadin-grid-row-details-themability-styles" assetpath="/">
  <template>
    <style>
      td[detailscell] ::content > .cell-content {
        background: #fff;
        @apply(--vaadin-grid-body-row-details-cell);
      }
    </style>
  </template>
</dom-module>


<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.RowDetailsBehavior
   */
  vaadin.elements.grid.RowDetailsBehavior = {

    properties: {

      /**
       * An array containing references to expanded items.
       */
      expandedItems: {
        value: function() {
          return [];
        }
      }
    },

    listeners: {
      'template-instance-changed': '_templateInstanceChangedExpanded'
    },

    observers: [
      '_expandedItemsChanged(expandedItems.*, dataSource)',
      '_rowDetailsTemplateChanged(_rowDetailsTemplate)'
    ],

    _expandedItemsChanged: function(expandedItems, dataSource) {
      this._flushItemsDebouncer();
      if (this.$.scroller._physicalItems) {
        this.$.scroller._physicalItems.forEach(function(row) {
          row.expanded = this._isExpanded(row.item);
        }.bind(this));
      }
    },

    _rowDetailsTemplateChanged: function(rowDetailsTemplate) {
      var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);
      templatizer._instanceProps = {
        expanded: true,
        item: true,
        selected: true
      };

      // row details templatizer needs to be attached so that `item-changed` and
      // `template-instance-changed` events propagate to grid.
      Polymer.dom(this.root).appendChild(templatizer);

      templatizer.template = rowDetailsTemplate;
    },

    _isExpanded: function(item) {
      return this.expandedItems && this.expandedItems.indexOf(item) !== -1;
    },

    /**
     * Expand the details row of a given item.
     */
    expandItem: function(item) {
      if (!this._isExpanded(item)) {
        this.push('expandedItems', item);
      }
    },

    /**
     * Collapse the details row of a given item.
     */
    collapseItem: function(item) {
      if (this._isExpanded(item)) {
        this.splice('expandedItems', this.expandedItems.indexOf(item), 1);
      }
    },

    _templateInstanceChangedExpanded: function(e) {
      if (e.detail.prop === 'expanded') {
        if (e.detail.value) {
          this.expandItem(e.detail.inst.item);
        } else {
          this.collapseItem(e.detail.inst.item);
        }

        // stop this internal event from propagating outside.
        e.stopPropagation();
      }
    }
  };
</script>
<dom-module id="vaadin-grid-data-source-styles" assetpath="/">
  <template>
    <style>
      :host(:not([has-data])) tbody tr::after {
        /* A placeholder for empty rows.
        Content must include (any) text so it derives any possible style
        rules affecting text height. */
        content: "-";
        visibility: hidden;
        width: 0;
        padding: 8px 0;
      }
    </style>
  </template>
</dom-module>
<dom-module id="vaadin-grid-data-source-themability-styles" assetpath="/">
  <template>
    <style>

      /* Anim */
      @keyframes vaadin-grid-spin-360 {
        100% {
          transform: rotate(360deg);
        }
      }
      @-webkit-keyframes vaadin-grid-spin-360 {
        100% {
          -webkit-transform: rotate(360deg);
          transform: rotate(360deg);
        }
      }

      #spinner {
        border: 2px solid var(--primary-color, #03A9F4);
        border-radius: 50%;
        border-right-color: transparent;
        border-top-color: transparent;
        content: "";
        height: 16px;
        left: 50%;
        margin-left: -8px;
        margin-top: -8px;
        position: absolute;
        top: 50%;
        width: 16px;
        pointer-events: none;
        opacity: 0;
        @apply(--vaadin-grid-loading-spinner);
      }

      :host([loading]) #spinner {
        opacity: 1;
        -webkit-animation: vaadin-grid-spin-360 400ms linear infinite;
        animation: vaadin-grid-spin-360 400ms linear infinite;
      }

      :host([loading])::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.5);
        pointer-events: none;
        @apply(--vaadin-grid-loading-backdrop);
      }

    </style>
  </template>
</dom-module>


<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.DataSourceBehavior
   */
  vaadin.elements.grid.DataSourceBehavior = {

    listeners: {
      'item-changed': '_templateItemChanged'
    },

    properties: {

      /**
       * Number of items fetched at a time from the datasource.
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: '_pageSizeChanged'
      },

      /**
       * Function that provides items lazily. Receives parameters `params`, `callback`
       *
       * `params.page` Requested page index
       *
       * `params.pageSize` Current page size
       */
      dataSource: {
        type: Function,
        notify: true,
        observer: '_dataSourceChanged'
      },

      /**
       * `true` while data is being requested from the data source.
       */
      _loading: Boolean,

      _cache: {
        value: function() {
          return {};
        }
      },

      _pendingRequests: {
        value: function() {
          return {};
        }
      },
    },

    _templateItemChanged: function(e) {
      var item = e.detail.item;

      // TODO: We could avoid iterating rows by fixing _physicalIndexForKey mapping
      // in iron-list-behavior so that vidx could be used to fetch the correct row element.
      Polymer.dom(this.$.scroller.$.items).children.forEach(function(row) {
        if (row.item === item) {
          row.iterateCells(function(cell) {
            // prevent _forwardInstancePath from firing duplicate `item-changed`
            // events on all the sibling cells.
            cell._templatizer._suppressItemChangeEvent = true;
            cell.instance.notifyPath('item.' + e.detail.path, e.detail.value);
            cell._templatizer._suppressItemChangeEvent = false;
          });
        }
      });
    },

    _getCachedItem: function(index) {
      var page = this._getPageForIndex(index);

      var p = this._cache && this._cache[page];

      if (p) {
        return p[index - page * this.pageSize];
      } else {
        return null;
      }
    },

    _getItem: function(index, el) {
      this._updateItem(el, this._getCachedItem(index));
      this._eagerlyLoadPages();
      //
      var uncachedPages = this._uncachedPagesForPhysicalItems();
      if (uncachedPages.length > 0) {
        this._loading = true;
        // avoid debounce during scroll to mitigate scrollbar flickering on iOS.
        // debouncing only when data is needed to be fetched. eager loading
        // should somewhat prevent from getting here when scrolling slowly.
        this.debounce('load', function() {
          uncachedPages.forEach(this._loadPage.bind(this));
        }, 100);
      }
    },

    _cachedPagesForPhysicalItems: function() {
      return this._pagesForPhysicalItems().filter(function(page) {
        return this._cache !== undefined && this._cache[page] !== undefined;
      }.bind(this));
    },

    _uncachedPagesForPhysicalItems: function() {
      return this._pagesForPhysicalItems().filter(function(page) {
        return this._cache !== undefined && this._cache[page] === undefined;
      }.bind(this));
    },

    _eagerlyLoadPages: function() {
      var pages = this._cachedPagesForPhysicalItems().slice(0);

      if (pages.length > 0) {
        pages.sort(function(a, b) {
          return a > b;
        });

        var prev = Math.max(0, pages[0] - 1);
        var next = Math.min(pages[pages.length - 1] + 1, Math.floor(this.size / this.pageSize) - 1);

        this._loadPage(prev);
        this._loadPage(next);
      }
    },

    _pagesForPhysicalItems: function() {
      // TODO: potentially heavy operation to run first visible index,
      // reconsider if performance issues occur on data binding / scrolling.
      var firstVisiblePage = this._getPageForIndex(this.$.scroller.firstVisibleIndex + this.$.scroller._vidxOffset);

      return [firstVisiblePage].concat(
          this.$.scroller._physicalItems
          .filter(function(row) {
            return row.index;
          })
          .map(function(row) {
            return this._getPageForIndex(row.index);
          }.bind(this)))
        .reduce(function(prev, curr) {
          if (prev.indexOf(curr) === -1) {
            prev.push(curr);
          }

          return prev;
        }, []);
    },

    _updateItems: function(page, items) {
      for (var i = 0; i < this.pageSize; i++) {
        var index = page * this.pageSize + i;
        var row = this.$.scroller._virtualIndexToItem[index];
        if (row) {
          this._updateItem(row, items[i]);

          // update heights if any of the items change.
          // TODO: in a way these should be obsolete, since _update() is called
          // on scrollHandler every time tiles are recycled. And the function we
          // are currently in is called as a result from calling assignModels when
          // tiles are being recycled. I really should draw a diagram of all this.
          if (!this.$.scroller.hasAttribute('has-data')) {
            // First set of actual data set to rows, have average height re-measured
            this.$.scroller._resetAverage();
            this.$.scroller.toggleAttribute('has-data', true);
          }

          this.debounce('update-heights', function() {
            this.$.scroller._updateMetrics();
            this.$.scroller._positionItems();
            this.$.scroller._updateScrollerSize();
          }, 1);
        }
      }
    },

    _loadPage: function(page) {
      if (!this._cache[page]) {
        // make sure same page isn't requested multiple times.
        if (!this._pendingRequests[page] && this.dataSource) {
          this._pendingRequests[page] = true;
          var opts = {
            page: page,
            pageSize: this.pageSize,
            sortOrder: this._mapSorters(),
            filters: this._mapFilters()
          };
          this.dataSource(opts, function(items) {
            this._cache[page] = items;
            delete this._pendingRequests[page];
            this._updateItems(page, items);

            this._loading = this._pendingRequests.length > 0;
          }.bind(this));
        }
      }
    },

    _getPageForIndex: function(index) {
      return Math.floor(index / this.pageSize);
    },

    /**
     * Clears the cached pages and reloads data from datasource when needed.
     */
    clearCache: function() {
      this._cache = {};
      this._pendingRequests = {};
      this.$.scroller._update();
      this._flushItemsDebouncer();
    },

    _flushItemsDebouncer: function() {
      this.flushDebouncer('load');
    },

    _pageSizeChanged: function(pageSize, oldPageSize) {
      if (oldPageSize !== undefined && pageSize !== oldPageSize) {
        this.clearCache();
      }
    },

    _dataSourceChanged: function(dataSource, oldDataSource) {
      if (oldDataSource !== undefined) {
        this.clearCache();
      }
    }

  };
</script>
<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.SelectionBehavior
   */
  vaadin.elements.grid.SelectionBehavior = {

    properties: {

      /**
       * An array that contains the selected items.
       */
      selectedItems: {
        type: Object,
        notify: true,
        value: function() {
          return [];
        }
      }
    },

    observers: [
      '_selectedItemsChanged(selectedItems.*)'
    ],

    listeners: {
      'template-instance-changed': '_templateInstanceChangedSelection'
    },

    _templateInstanceChangedSelection: function(e) {
      if (e.detail.prop === 'selected') {
        var item = e.detail.inst.item;
        (this._isSelected(item) ? this.deselectItem : this.selectItem).bind(this)(item);

        // stop this internal event from propagating outside.
        e.stopPropagation();
      }
    },

    _isSelected: function(item) {
      return this.selectedItems && this.selectedItems.indexOf(item) > -1;
    },

    /**
     * Selects the given item.
     *
     * @method selectItem
     * @param {number|Object} item The item index or the item object
     */
    selectItem: function(item) {
      item = this._takeItem(item);
      if (!this._isSelected(item)) {
        this.push('selectedItems', item);
      }
    },

    /**
     * Deselects the given item if it is already selected.
     *
     * @method deselect
     * @param {number|Object} item The item index or the item object
     */
    deselectItem: function(item) {
      item = this._takeItem(item);
      var index = this.selectedItems.indexOf(item);
      if (index > -1) {
        this.splice('selectedItems', index, 1);
      }
    },

    /**
     * Toggles the selected state of the given item.
     *
     * @method toggle
     * @param {number|Object} item The item index or the item object
     */
    _toggleItem: function(item) {
      item = this._takeItem(item);
      var index = this.selectedItems.indexOf(item);
      if (index === -1) {
        this.selectItem(item);
      } else {
        this.deselectItem(item);
      }
    },

    /**
     * Returns item object itself or by the item index.
     *
     * @param {number|Object} item The item index or the item object
     */
    _takeItem: function(item) {
      if (typeof item === 'number' && item >= 0 && this.items && this.items.length > item) {
        return this.items[item];
      }
      return item;
    },

    _selectedItemsChanged: function(e) {
      if (this.$.scroller._physicalItems && (e.path === 'selectedItems' || e.path === 'selectedItems.splices')) {
        this.$.scroller._physicalItems.forEach(function(row) {
          row.selected = this._isSelected(row.item);
        }.bind(this));
      }
    }
  };
</script>

<dom-module id="vaadin-grid-selection-themability-styles" assetpath="/">
  <template>
    <style>
      table tr[selected] .vaadin-grid-cell:not([detailscell]) ::content > .cell-content {
        background-color: var(--paper-grey-100, rgb(243, 243, 243));
        @apply(--vaadin-grid-body-row-selected-cell);
      }
    </style>
  </template>
</dom-module>
<dom-module id="vaadin-grid-navigation-themability-styles" assetpath="/">
  <template>
    <style>
      :host(:focus),
      #headerFocusTrap:focus,
      #bodyFocusTrap:focus,
      #footerFocusTrap:focus {
        outline: none;
      }

      :host([navigating]:not([interacting])) [focused] > tr[focused] > [focused] ::content > .cell-content {
        box-shadow: inset 0 0 0 3px rgba(0, 0, 0, 0.3);
        @apply(--vaadin-grid-focused-cell);
      }
    </style>
  </template>
</dom-module>

<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.KeyboardNavigationBehaviorImpl
   */
  vaadin.elements.grid.KeyboardNavigationBehaviorImpl = {
    hostAttributes: {
      // keys can be listened only when vaadin-grid is focusable
      'tabindex': -1
    },

    keyBindings: {
      'ctrl+home': '_onCtrlHome',
      'ctrl+end': '_onCtrlEnd',
      'down': '_onArrowDown',
      'end': '_onEnd',
      'enter': '_onEnter',
      'esc': '_onEscape',
      'f2': '_onF2',
      'home': '_onHome',
      'left': '_onArrowLeft',
      'pagedown': '_onPageDown',
      'pageup': '_onPageUp',
      'right': '_onArrowRight',
      'shift+tab': '_onShiftTab',
      'space': '_onSpace',
      'tab': '_onTab',
      'up': '_onArrowUp'
    },

    attached: function() {
      this.addEventListener('blur', this._onBlur, true);
    },

    detached: function() {
      this.removeEventListener('blur', this._onBlur, true);
    },

    _onBlur: function(e) {
      this.$.scroller.navigating = false;
      this.$.scroller.interacting = false;
    },

    _onEnd: function(e) {
      this.$.scroller._onEnd(e);
    },

    _onEnter: function(e) {
      this.$.scroller._onEnter(e);
    },

    _onEscape: function(e) {
      this.$.scroller._onEscape(e);
    },

    _onF2: function(e) {
      this.$.scroller._onF2(e);
    },

    _onTab: function(e) {
      this.$.scroller._onTab(e);
    },

    _onShiftTab: function(e) {
      this.$.scroller._onShiftTab(e);
    },

    _onArrowDown: function(e) {
      this.$.scroller._onArrowDown(e);
    },

    _onArrowUp: function(e) {
      this.$.scroller._onArrowUp(e);
    },

    _onArrowRight: function(e) {
      this.$.scroller._onArrowRight(e);
    },

    _onArrowLeft: function(e) {
      this.$.scroller._onArrowLeft(e);
    },

    _onHome: function(e) {
      this.$.scroller._onHome(e);
    },

    _onCtrlHome: function(e) {
      this.$.scroller._onCtrlHome(e);
    },

    _onCtrlEnd: function(e) {
      this.$.scroller._onCtrlEnd(e);
    },

    _onPageDown: function(e) {
      this.$.scroller._onPageDown(e);
    },

    _onPageUp: function(e) {
      this.$.scroller._onPageUp(e);
    },

    _onSpace: function(e) {
      this.$.scroller._onSpace(e);
    },
  };

  /**
   * @polymerBehavior vaadin.elements.grid.KeyboardNavigationBehavior
   */
  vaadin.elements.grid.KeyboardNavigationBehavior = [vaadin.elements.grid.KeyboardNavigationBehaviorImpl, Polymer.IronA11yKeysBehavior];


  /**
   * @polymerBehavior vaadin.elements.grid.TableKeyboardBehavior
   */
  vaadin.elements.grid.TableKeyboardBehavior = {

    properties: {
      _virtualFocus: {
        type: Object,
        observer: '_virtualFocusChanged'
      },

      interacting: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },

      navigating: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      }
    },

    listeners: {
      'cell-focus': '_onCellFocus',
      'cell-content-focus': '_onCellContentFocus'
    },

    _isFooterVisible: function() {
      return this.$.footer._rows.filter(function(row) {
        return !row.hidden;
      }).length > 0;
    },

    _onHeaderFocus: function(e) {
      this.navigating = true;
      this.interacting = false;
      this.$.header._focusedCellIndex = this.$.header._focusedCellIndex || 0;
      this.$.header._focusedRowIndex = this.$.header._focusedRowIndex || 0;
      this._virtualFocus = this.$.header;
    },

    _onBodyFocus: function(e) {
      this.navigating = true;
      this.interacting = false;
      this.$.items._focusedCellIndex = this.$.items._focusedCellIndex || 0;
      this.$.items._focusedRowIndex = this.$.items._focusedRowIndex || 0;
      this._virtualFocus = this.$.items;
    },

    _onFooterFocus: function(e) {
      this.navigating = true;
      this.interacting = false;
      var container = this._isFooterVisible() ? this.$.footer : this.$.items;
      container._focusedCellIndex = container._focusedCellIndex || 0;
      container._focusedRowIndex = container._focusedRowIndex || 0;
      this._virtualFocus = container;
    },

    _virtualFocusChanged: function(virtualFocus, oldVirtualFocus) {
      if (oldVirtualFocus) {
        oldVirtualFocus.focused = false;
      }
      if (virtualFocus) {
        virtualFocus.focused = true;

        if (virtualFocus === this.$.items) {
          this._ensureVirtualFocusInViewport();
        }
      }
    },

    _onTab: function(e) {
      if (this.interacting) {
        return;
      }

      if (this.navigating) {
        switch (this._virtualFocus) {
          case this.$.header:
            this.$.bodyFocusTrap.focus();
            e.preventDefault();
            break;

          case this.$.items:
            this.$.footerFocusTrap.focus();
            if (this._isFooterVisible()) {
              this._virtualFocus = this.$.footer;
              e.preventDefault();
            } else {
              this._virtualFocus = null;
            }
            break;

          case this.$.footer:
            this._virtualFocus = null;
            break;
        }
      } else {
        switch (this._virtualFocus) {
          case this.$.header:
            this.$.headerFocusTrap.focus();
            break;

          case this.$.items:
            this.$.bodyFocusTrap.focus();
            break;

          case this.$.footer:
            this.$.footerFocusTrap.focus();
            break;
        }
        e.preventDefault();
      }
    },

    _onShiftTab: function(e) {
      if (this.interacting) {
        return;
      }

      if (this.navigating) {
        switch (this._virtualFocus) {
          case this.$.footer:
            this.$.bodyFocusTrap.focus();
            e.preventDefault();
            break;
          case this.$.items:
            this.$.headerFocusTrap.focus();
            e.preventDefault();
            break;
          case this.$.header:
            this._virtualFocus = null;
            break;
        }
      } else {
        switch (this._virtualFocus) {
          case this.$.footer:
            this.$.footerFocusTrap.focus();
            break;
          case this.$.items:
            this.$.bodyFocusTrap.focus();
            break;
          case this.$.header:
            this.$.headerFocusTrap.focus();
            break;
        }
        e.preventDefault();
      }
    },

    _isAboveViewport: function(index) {
      return this.firstVisibleIndex > index;
    },

    _onArrowDown: function(e) {
      if(this.interacting) {
        return;
      }

      e.preventDefault();

      this._virtualFocus.focusDown();
      this.navigating = true;

      this._ensureVirtualFocusInViewport();
    },

    _scrollPageDown: function() {
      var headerRect = this.$.header.getBoundingClientRect();
      var footerRect = this.$.footer.getBoundingClientRect();

      this.$.table.scrollTop += footerRect.top - headerRect.bottom;
      this._scrollHandler();
    },

    _onPageDown: function(e) {
      if (this.interacting) {
        return;
      }

      e.preventDefault();

      if (this._virtualFocus === this.$.items) {
        var prevLastVisible = this.lastVisibleIndex;
        this._scrollPageDown();
        this._virtualFocus._focusedRowIndex += (this.lastVisibleIndex - prevLastVisible) ||
         (this.lastVisibleIndex - this._virtualFocus._focusedRowIndex);
        this._ensureVirtualFocusInViewport();
      } else {
        this._virtualFocus.focusPageDown();
      }
      this.navigating = true;
    },

    _scrollPageUp: function() {
      var headerRect = this.$.header.getBoundingClientRect();
      var footerRect = this.$.footer.getBoundingClientRect();

      this.$.table.scrollTop -= footerRect.top - headerRect.bottom;
      this._scrollHandler();
    },

    _onPageUp: function(e) {
      if (this.interacting) {
        return;
      }

      e.preventDefault();

      if (this._virtualFocus === this.$.items) {
        var prevLastVisibleIndex = this.lastVisibleIndex;
        this._scrollPageUp();
        this._virtualFocus._focusedRowIndex -= (prevLastVisibleIndex - this.lastVisibleIndex) ||
         this._virtualFocus._focusedRowIndex;
        this._ensureVirtualFocusInViewport();
      } else {
        this._virtualFocus.focusPageUp();
      }
      this.navigating = true;
    },

    _onArrowUp: function(e) {
      if (this.interacting) {
        return;
      }

      e.preventDefault();

      this._virtualFocus.focusUp();
      this.navigating = true;

      this._ensureVirtualFocusInViewport();
    },

    _onArrowRight: function(e) {
      if (this.interacting) {
        return;
      }

      e.preventDefault();

      this._virtualFocus.focusRight();
      this.navigating = true;

      this._ensureVirtualFocusInViewport();
    },

    _onArrowLeft: function(e) {
      if (this.interacting) {
        return;
      }

      e.preventDefault();

      this._virtualFocus.focusLeft();
      this.navigating = true;

      this._ensureVirtualFocusInViewport();
    },

    _onHome: function(e) {
      if (this.interacting) {
        return;
      }

      e.preventDefault();

      this._virtualFocus.focusHome();
      this.navigating = true;

      this._ensureVirtualFocusInViewport();
    },

    _onEnd: function(e) {
      if (this.interacting) {
        return;
      }

      e.preventDefault();

      this._virtualFocus.focusEnd();
      this.navigating = true;

      this._ensureVirtualFocusInViewport();
    },

    _moveFocusToFocusTarget: function() {
      var content = this._virtualFocus._focusedCell._cellContent;

      var focusTarget = content.querySelector('[focus-target]') || content.firstElementChild;
      if (focusTarget) {
        focusTarget.focus();
      }
    },

    _onEnter: function(e) {
      if(!this.interacting) {
        e.preventDefault();
        this._moveFocusToFocusTarget();
      }
    },

    _onEscape: function(e) {
      if (this.interacting) {
        this.interacting = false;
        this._onTab(e); // revert to navigation
      } else if (this.navigating) {
        this.domHost.focus();
      }
    },

    _onF2: function(e) {
      e.preventDefault();
      if (!this.interacting) {
        this._moveFocusToFocusTarget();
      } else {
        this.interacting = false;
        this._onTab(e); // revert to navigation
      }
    },

    _onCtrlHome: function(e) {
      if (this.interacting) {
        return;
      }

      e.preventDefault();

      this._virtualFocus.focusFirst();
      this.navigating = true;

      this._ensureVirtualFocusInViewport();
    },

    _onCtrlEnd: function(e) {
      if (this.interacting) {
        return;
      }

      e.preventDefault();

      this._virtualFocus.focusLast();
      this.navigating = true;

      this._ensureVirtualFocusInViewport();
    },

    _onSpace: function(e) {
      if (this.navigating && !this.interacting && this._virtualFocus === this.$.items) {
        e.preventDefault();

        this.fire('cell-activate', {
          model: this._virtualFocus._focusedCell.instance
        });
      }
    },

    _onCellContentFocus: function(e) {
      this.interacting = true;
      this._onCellFocus(e);
    },

    _onCellFocus: function(e) {
      var cell = e.detail.cell;
      var row = cell.parentElement;
      var container = row.parentElement;

      var rowIndex = Polymer.dom(container).children.indexOf(row);
      if (container === this.$.items) {
        rowIndex = row.index;
      }

      container._focusedRowIndex = rowIndex;
      container._focusedCellIndex = Polymer.dom(row).children.indexOf(cell);
      this._virtualFocus = container;
    },


    _ensureVirtualFocusInViewport: function() {
      var scaledVirtualStart = this._vidxOffset + this._virtualStart;
      var focusedIndex = this._virtualFocus._focusedRowIndex;

      if (this._virtualFocus === this.$.items && ((focusedIndex < scaledVirtualStart) ||
          (focusedIndex > scaledVirtualStart + this._physicalCount))) {
        this.scrollToScaledIndex(focusedIndex);
        // force resetting _focusedCell in case element reordering has happened.
        this._virtualFocus._focusedCellChanged(focusedIndex, this._virtualFocus._focusedCellIndex);
      } else {
        this._ensureElementInViewport(this._virtualFocus._focusedCell);
      }
    },

    _ensureElementInViewport: function(element) {
      var elementRect = element.getBoundingClientRect();

      // Vertical
      if (this._virtualFocus === this.$.items) {
        var maxBottom = this.$.footer.getBoundingClientRect().top;
        var minTop = this.$.header.getBoundingClientRect().bottom;
        if (elementRect.bottom > maxBottom) {
          this.$.table.scrollTop += (elementRect.bottom - maxBottom);
        } else if (elementRect.top < minTop) {
          this.$.table.scrollTop += (elementRect.top - minTop);
        }
      }

      // Horizontal
      var maxRight = this.$.table.getBoundingClientRect().right;
      var minLeft = this.$.table.getBoundingClientRect().left;
      var lastFrozen = this._virtualFocus._focusedRow.querySelector('[last-frozen]');
      if (lastFrozen) {
        minLeft = lastFrozen.getBoundingClientRect().right;
      }

      if (elementRect.right > maxRight) {
        this.$.table.scrollLeft += (elementRect.right - maxRight);
      } else if (elementRect.left < minLeft) {
        this.$.table.scrollLeft += (elementRect.left - minLeft);
      }
    }
  };
</script>
<dom-module id="vaadin-grid-column-reordering-themability-styles" assetpath="/">
  <template>
    <style>
      :host([reordering]) .vaadin-grid-cell {
        background: #000;
      }

      :host([reordering]) .vaadin-grid-cell:not([detailscell]) ::content > .cell-content {
        transition: opacity 300ms;
        transform: translateZ(0);
        opacity: 0.8;
      }

      .vaadin-grid-cell[reorder-status="allowed"] ::content > .cell-content.cell-content {
        opacity: 1;
      }

      .vaadin-grid-cell[reorder-status="dragging"] {
        background: var(--primary-color, #000);
      }

      .vaadin-grid-cell[reorder-status="dragging"] ::content > .cell-content.cell-content {
        opacity: 0.95;
      }
    </style>
  </template>
</dom-module>

<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.ColumnReorderingBehavior
   */
  vaadin.elements.grid.ColumnReorderingBehavior = {

    properties: {

      /**
       * Set to true to allow column reordering.
       */
      columnReorderingAllowed: {
        type: Boolean,
        value: false
      }

    }

  };

  /**
   * @polymerBehavior vaadin.elements.grid.TableColumnReorderingBehavior
   */
  vaadin.elements.grid.TableColumnReorderingBehavior = {

    properties: {

      _orderBaseScope: {
        type: Number,
        value: 10000000
      }

    },

    listeners: {
      'dragstart': '_onDragStart',
      'dragover': '_onDragOver',
      'dragend': '_onDragEnd'
    },

    observers: [
      '_updateOrders(columnTree, columnTree.*)',
    ],

    _updateOrders: function(columnTree, splices) {
      // Set order numbers to top-level columns
      columnTree[0].forEach(function(column, index) {
        column._order = (index + 1) * this._orderBaseScope;
      }, this);
    },

    _onDragStart: function(e) {
      var cell = this._getCellByCellContent(e.target);
      if (cell) {
        this.toggleAttribute('reordering', true);
        this._draggedColumn = cell.column;
        this._setSiblingsReorderStatus(this._draggedColumn, 'allowed');
        this._draggedColumn._reorderStatus = 'dragging';

        // Need to set any data to enable D&D on Firefox
        e.dataTransfer.setData('text', '');
        e.dataTransfer.effectAllowed = 'move';

        this._autoScroller();
      }
    },

    _setSiblingsReorderStatus: function(column, status) {
      Polymer.dom(Polymer.dom(column).parentNode).children.filter(function(child) {
        return /column/.test(child.localName) && this._isSwapAllowed(child, column);
      }, this).forEach(function(sibling) {
        sibling._reorderStatus = status;
      });
    },

    _onDragOver: function(e) {
      e.preventDefault();
      var targetCell = this._getCellByCellContent(e.target);
      var targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);

      if (targetColumn &&
        this._isSwapAllowed(this._draggedColumn, targetColumn) &&
        this._isSwappableByPosition(targetColumn, e.clientX)) {
        this._swapColumnOrders(this._draggedColumn, targetColumn);
      }

      this._lastDragClientX = e.clientX;
    },

    _autoScroller: function() {
      if (this._lastDragClientX) {
        var rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;
        var leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;

        if (rightDiff > 0) {
          this.$.table.scrollLeft += rightDiff / 10;
        } else if (leftDiff > 0) {
          this.$.table.scrollLeft -= leftDiff / 10;
        }
        this._scrollHandler();
      }

      if (this._draggedColumn) {
        this.async(this._autoScroller, 10);
      }
    },

    _onDragEnd: function(e) {
      this.toggleAttribute('reordering', false);
      this._draggedColumn._reorderStatus = '';
      this._setSiblingsReorderStatus(this._draggedColumn, '');
      this._draggedColumn = null;
      this._lastDragClientX = null;
    },

    _isSwapAllowed: function(column1, column2) {
      if (column1 && column2) {
        var differentColumns = column1 !== column2;
        var sameParent = column1.parentElement === column2.parentElement;
        var sameFrozen = column1.frozen === column2.frozen;
        return differentColumns && sameParent && sameFrozen;
      }
    },

    _isSwappableByPosition: function(targetColumn, clientX) {
      var targetCell = Polymer.dom(this.$.header).querySelectorAll('th').filter(function(cell) {
        return cell.column === targetColumn;
      })[0];
      var sourceCellRect = this.$.header.querySelector('[reorder-status=dragging]').getBoundingClientRect();

      if (targetCell.getBoundingClientRect().left > sourceCellRect.left) {
        return clientX > targetCell.getBoundingClientRect().right - sourceCellRect.width;
      } else {
        return clientX < targetCell.getBoundingClientRect().left + sourceCellRect.width;
      }
    },

    _getCellByCellContent: function(cellContent) {
      if (cellContent) {
        var contentId = null;
        while (contentId === null && cellContent !== this.target && cellContent) {
          contentId = cellContent.getAttribute('data-cell-content-id');
          cellContent = cellContent.parentElement;
        }

        if (contentId !== null) {
          var injectionPoint = Polymer.dom(this.$.table).querySelectorAll('content')
          .filter(function(content) {
            return content.getAttribute('select') === '[data-cell-content-id="' + contentId + '"]';
          })[0];
          return Polymer.dom(injectionPoint).parentNode;
        }
      }
    },

    _swapColumnOrders: function(column1, column2) {
      var _order = column1._order;
      column1._order = column2._order;
      column2._order = _order;
      this._updateLastFrozen();
      this._updateLastColumn();
    },

    _getTargetColumn: function(targetCell, draggedColumn) {
      if (targetCell && draggedColumn) {
        var candidate = targetCell.column;
        while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this.target) {
          candidate = candidate.parentElement;
        }
        if (candidate.parentElement === draggedColumn.parentElement) {
          return candidate;
        } else {
          return targetCell.column;
        }
      }
    }

  };
</script>
<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.IronListBehaviorImpl
   */
  vaadin.elements.grid.IronListBehaviorImpl = (function() {

    var IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
    var IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;
    var DEFAULT_PHYSICAL_COUNT = 25;

    return ({

      is: 'iron-list',

      properties: {
        /**
         * The max count of physical items the pool can extend to.
         */
        maxPhysicalCount: {
          type: Number,
          value: 500
        },

        /**
         * The name of the variable to add to the binding scope for the array
         * element associated with a given template instance.
         */
        as: {
          type: String,
          value: 'item'
        },

        /**
         * The name of the variable to add to the binding scope with the index
         * for the row.
         */
        indexAs: {
          type: String,
          value: 'index'
        }
      },

      /**
       * The ratio of hidden tiles that should remain in the scroll direction.
       * Recommended value ~0.5, so it will distribute tiles evely in both directions.
       */
      _ratio: 0.5,

      /**
       * The padding-top value for the list.
       */
      _scrollerPaddingTop: 0,

      /**
       * This value is the same as `scrollTop`.
       */
      _scrollPosition: 0,

      /**
       * The sum of the heights of all the tiles in the DOM.
       */
      _physicalSize: 0,

      /**
       * The average `offsetHeight` of the tiles observed till now.
       */
      _physicalAverage: 0,

      /**
       * The number of tiles which `offsetHeight` > 0 observed until now.
       */
      _physicalAverageCount: 0,

      /**
       * The Y position of the item rendered in the `_physicalStart`
       * tile relative to the scrolling list.
       */
      _physicalTop: 0,

      /**
       * The number of items in the list.
       */
      _virtualCount: 0,

      /**
       * A map between an item key and its physical item index
       */
      _physicalIndexForKey: null,

      /**
       * The estimated scroll height based on `_physicalAverage`
       */
      _estScrollHeight: 0,

      /**
       * The scroll height of the dom node
       */
      _scrollHeight: 0,

      /**
       * The height of the list. This is referred as the viewport in the context of list.
       */
      _viewportHeight: 0,

      /**
       * The width of the list. This is referred as the viewport in the context of list.
       */
      _viewportWidth: 0,

      /**
       * An array of DOM nodes that are currently in the tree
       * @type {?Array<!TemplatizerNode>}
       */
      _physicalItems: null,

      /**
       * An array of heights for each item in `_physicalItems`
       * @type {?Array<number>}
       */
      _physicalSizes: null,

      /**
       * A cached value for the first visible index.
       * See `firstVisibleIndex`
       * @type {?number}
       */
      _firstVisibleIndexVal: null,

      /**
       * A cached value for the last visible index.
       * See `lastVisibleIndex`
       * @type {?number}
       */
      _lastVisibleIndexVal: null,

      /**
       * A Polymer collection for the items.
       * @type {?Polymer.Collection}
       */
      _collection: null,

      /**
       * True if the current item list was rendered for the first time
       * after attached.
       */
      _itemsRendered: false,

      /**
       * The page that is currently rendered.
       */
      _lastPage: null,

      /**
       * The max number of pages to render. One page is equivalent to the height of the list.
       */
      _maxPages: 3,

      /**
       * The maximum items per row
       */
      _itemsPerRow: 1,

      /**
       * The width of each grid item
       */
      _itemWidth: 0,

      /**
       * The height of the row in grid layout.
       */
      _rowHeight: 0,

      /**
       * The bottom of the physical content.
       */
      get _physicalBottom() {
        return this._physicalTop + this._physicalSize;
      },

      /**
       * The bottom of the scroll.
       */
      get _scrollBottom() {
        return this._scrollPosition + this._viewportHeight;
      },

      /**
       * The n-th item rendered in the last physical item.
       */
      get _virtualEnd() {
        return this._virtualStart + this._physicalCount - 1;
      },

      /**
       * The height of the physical content that isn't on the screen.
       */
      get _hiddenContentSize() {
        return this._physicalSize - this._viewportHeight;
      },

      /**
       * The maximum scroll top value.
       */
      get _maxScrollTop() {
        return this._estScrollHeight - this._viewportHeight + this._scrollerPaddingTop;
      },

      /**
       * The lowest n-th value for an item such that it can be rendered in `_physicalStart`.
       */
      _minVirtualStart: 0,

      /**
       * The largest n-th value for an item such that it can be rendered in `_physicalStart`.
       */
      get _maxVirtualStart() {
        return Math.max(0, this._virtualCount - this._physicalCount);
      },

      /**
       * The n-th item rendered in the `_physicalStart` tile.
       */
      _virtualStartVal: 0,

      set _virtualStart(val) {
        this._virtualStartVal = Math.min(this._maxVirtualStart, Math.max(this._minVirtualStart, val));
      },

      get _virtualStart() {
        return this._virtualStartVal || 0;
      },

      /**
       * The k-th tile that is at the top of the scrolling list.
       */
      _physicalStartVal: 0,

      set _physicalStart(val) {
        this._physicalStartVal = val % this._physicalCount;
        if (this._physicalStartVal < 0) {
          this._physicalStartVal = this._physicalCount + this._physicalStartVal;
        }
        this._physicalEnd = (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
      },

      get _physicalStart() {
        return this._physicalStartVal || 0;
      },

      /**
       * The number of tiles in the DOM.
       */
      _physicalCountVal: 0,

      set _physicalCount(val) {
        this._physicalCountVal = val;
        this._physicalEnd = (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
      },

      get _physicalCount() {
        return this._physicalCountVal;
      },

      /**
       * The k-th tile that is at the bottom of the scrolling list.
       */
      _physicalEnd: 0,

      /**
       * An optimal physical size such that we will have enough physical items
       * to fill up the viewport and recycle when the user scrolls.
       *
       * This default value assumes that we will at least have the equivalent
       * to a viewport of physical items above and below the user's viewport.
       */
      get _optPhysicalSize() {
        return this._viewportHeight * this._maxPages;
      },

      get _optPhysicalCount() {
        return this._estRowsInView * this._itemsPerRow * this._maxPages;
      },

     /**
      * True if the current list is visible.
      */
      get _isVisible() {
        return this.scrollTarget && Boolean(this.scrollTarget.offsetWidth || this.scrollTarget.offsetHeight);
      },

      /**
       * Gets the index of the first visible item in the viewport.
       *
       * @type {number}
       */
      get firstVisibleIndex() {
        if (this._firstVisibleIndexVal === null) {
          var physicalOffset = Math.floor(this._physicalTop + this._scrollerPaddingTop);

          this._firstVisibleIndexVal = this._iterateItems(
            function(pidx, vidx) {
              physicalOffset += this._getPhysicalSizeIncrement(pidx);

              if (physicalOffset > this._scrollPosition) {
                return vidx;
              }
            }) || 0;
        }
        return this._firstVisibleIndexVal;
      },

      /**
       * Gets the index of the last visible item in the viewport.
       *
       * @type {number}
       */
      get lastVisibleIndex() {
        if (this._lastVisibleIndexVal === null) {
          var physicalOffset = this._physicalTop;
          this._iterateItems(function(pidx, vidx) {
            if (physicalOffset < this._scrollBottom) {
              this._lastVisibleIndexVal = vidx;
            } else {
              // Break _iterateItems
              return true;
            }
            physicalOffset += this._getPhysicalSizeIncrement(pidx);
          });
        }
        return this._lastVisibleIndexVal;
      },

      get _defaultScrollTarget() {
        return this;
      },
      get _virtualRowCount() {
        return Math.ceil(this._virtualCount / this._itemsPerRow);
      },

      get _estRowsInView() {
        return Math.ceil(this._viewportHeight / this._rowHeight);
      },

      get _physicalRows() {
        return Math.ceil(this._physicalCount / this._itemsPerRow);
      },

      attached: function() {
        this.updateViewportBoundaries();
        this._render();
        // `iron-resize` is fired when the list is attached if the event is added
        // before attached causing unnecessary work.
        this.listen(this, 'iron-resize', '_resizeHandler');
      },

      detached: function() {
        this._itemsRendered = false;
        this.unlisten(this, 'iron-resize', '_resizeHandler');
      },

      /**
       * Invoke this method if you dynamically update the viewport's
       * size or CSS padding.
       *
       * @method updateViewportBoundaries
       */
      updateViewportBoundaries: function() {
        this._scrollerPaddingTop = this.scrollTarget === this ? 0 :
            parseInt(window.getComputedStyle(this)['padding-top'], 10);

        this._viewportHeight = this._scrollTargetHeight;
      },

      /**
       * Update the list of items, starting from the `_virtualStart` item.
       * @param {!Array<number>=} itemSet
       * @param {!Array<number>=} movingUp
       */
      _update: function(itemSet, movingUp) {
        // update models
        this._assignModels(itemSet);
        // measure heights
        this._updateMetrics(itemSet);
        // adjust offset after measuring
        if (movingUp) {
          while (movingUp.length) {
            var idx = movingUp.pop();
            this._physicalTop -= this._getPhysicalSizeIncrement(idx);
          }
        }
        // update the position of the items
        this._positionItems();
        // set the scroller size
        this._updateScrollerSize();
        // increase the pool of physical items

        // dropping this will reduce spinup time by 50%
        this._increasePoolIfNeeded();
      },

      /**
       * Increases the pool of physical items only if needed.
       *
       * @return {boolean} True if the pool was increased.
       */
      _increasePoolIfNeeded: function() {
        // Base case 1: the list has no height.
        if (this._viewportHeight === 0) {
          return false;
        }
        // Base case 2: If the physical size is optimal and the list's client height is full
        // with physical items, don't increase the pool.
        var isClientHeightFull = this._physicalBottom >= this._scrollBottom && this._physicalTop <= this._scrollPosition;
        if (this._physicalSize >= this._optPhysicalSize && isClientHeightFull) {
          return false;
        }
        // this value should range between [0 <= `currentPage` <= `_maxPages`]
        var currentPage = Math.floor(this._physicalSize / this._viewportHeight);
        if (currentPage === 0) {
          // fill the first page
          this._debounceTemplate(this._increasePool.bind(this, Math.round(this._physicalCount * 0.5)));
        } else if (this._lastPage !== currentPage && isClientHeightFull) {
          // paint the page and defer the next increase
          // wait 16ms which is rough enough to get paint cycle.
          Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', this._increasePool.bind(this, this._itemsPerRow), 16));
        } else {
          // fill the rest of the pages
          this._debounceTemplate(this._increasePool.bind(this, this._itemsPerRow));
        }
        this._lastPage = currentPage;
        return true;
      },

      /**
       * Increases the pool size.
       */
      _increasePool: function(missingItems) {
        var nextPhysicalCount = Math.min(
            this._physicalCount + missingItems,
            this._virtualCount - this._virtualStart,
            Math.max(this.maxPhysicalCount, DEFAULT_PHYSICAL_COUNT)
          );
        var prevPhysicalCount = this._physicalCount;
        var delta = nextPhysicalCount - prevPhysicalCount;

        if (delta <= 0) {
          return;
        }

        [].push.apply(this._physicalItems, this._createPool(delta));
        [].push.apply(this._physicalSizes, new Array(delta));

        this._physicalCount = prevPhysicalCount + delta;

        this._update();
      },

      /**
       * Render a new list of items. This method does exactly the same as `update`,
       * but it also ensures that only one `update` cycle is created.
       */
      _render: function() {
        var requiresUpdate = this._virtualCount > 0 || this._physicalCount > 0;

        if (this.isAttached && !this._itemsRendered && this._isVisible && requiresUpdate) {
          this._lastPage = 0;
          this._update();
          this._itemsRendered = true;
        }
      },

      /**
       * Executes a provided function per every physical index in `itemSet`
       * `itemSet` default value is equivalent to the entire set of physical indexes.
       *
       * @param {!function(number, number)} fn
       * @param {!Array<number>=} itemSet
       */
      _iterateItems: function(fn, itemSet) {
        var pidx, vidx, rtn, i;

        if (arguments.length === 2 && itemSet) {
          for (i = 0; i < itemSet.length; i++) {
            pidx = itemSet[i];
            vidx = this._computeVidx(pidx);
            if ((rtn = fn.call(this, pidx, vidx)) != null) {
              return rtn;
            }
          }
        } else {
          pidx = this._physicalStart;
          vidx = this._virtualStart;

          for (; pidx < this._physicalCount; pidx++, vidx++) {
            if ((rtn = fn.call(this, pidx, vidx)) != null) {
              return rtn;
            }
          }
          for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {
            if ((rtn = fn.call(this, pidx, vidx)) != null) {
              return rtn;
            }
          }
        }
      },

      /**
       * Returns the virtual index for a given physical index
       *
       * @param {number} pidx Physical index
       * @return {number}
       */
      _computeVidx: function(pidx) {
        if (pidx >= this._physicalStart) {
          return this._virtualStart + (pidx - this._physicalStart);
        }
        return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;
      },

      /**
       * Updates the height for a given set of items.
       *
       * @param {!Array<number>=} itemSet
       */
      _updateMetrics: function(itemSet) {
        // Make sure we distributed all the physical items
        // so we can measure them
        Polymer.dom.flush();

        var newPhysicalSize = 0;
        var oldPhysicalSize = 0;
        var prevAvgCount = this._physicalAverageCount;
        var prevPhysicalAvg = this._physicalAverage;

        this._iterateItems(function(pidx, vidx) {

          oldPhysicalSize += this._physicalSizes[pidx] || 0;
          this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;
          newPhysicalSize += this._physicalSizes[pidx];
          this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;

        }, itemSet);

        this._viewportHeight = this._scrollTargetHeight;
        this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;

        // update the average if we measured something
        if (this._physicalAverageCount !== prevAvgCount) {
          this._physicalAverage = Math.round(
              ((prevPhysicalAvg * prevAvgCount) + newPhysicalSize) /
              this._physicalAverageCount);
        }
      },

      /**
       * Updates the position of the physical items.
       */
      _positionItems: function() {
        this._adjustScrollPosition();

        var y = this._physicalTop;

        this._iterateItems(function(pidx, vidx) {

          this.translate3d(0, y + 'px', 0, this._physicalItems[pidx]);
          y += this._physicalSizes[pidx];

        });

      },

      _getPhysicalSizeIncrement: function(pidx) {
        return this._physicalSizes[pidx];
      },

      /**
       * Returns, based on the current index,
       * whether or not the next index will need
       * to be rendered on a new row.
       *
       * @param {number} vidx Virtual index
       * @return {boolean}
       */
      _shouldRenderNextRow: function(vidx) {
        return vidx % this._itemsPerRow === this._itemsPerRow - 1;
      },

      /**
       * Adjusts the scroll position when it was overestimated.
       */
      _adjustScrollPosition: function() {
        var deltaHeight = this._virtualStart === 0 ? this._physicalTop :
            Math.min(this._scrollPosition + this._physicalTop, 0);

        if (deltaHeight) {
          this._physicalTop = this._physicalTop - deltaHeight;
          // juking scroll position during interial scrolling on iOS is no bueno
          if (!IOS_TOUCH_SCROLLING && this._physicalTop !== 0) {
            this._resetScrollPosition(this._scrollTop - deltaHeight);
          }
        }
      },

      /**
       * Sets the position of the scroll.
       */
      _resetScrollPosition: function(pos) {
        if (this.scrollTarget) {
          this._scrollTop = pos;
          this._scrollPosition = this._scrollTop;
        }
      },

      /**
       * Sets the scroll height, that's the height of the content,
       *
       * @param {boolean=} forceUpdate If true, updates the height no matter what.
       */
      _updateScrollerSize: function(forceUpdate) {
        this._estScrollHeight = (this._physicalBottom +
            Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage);

        forceUpdate = forceUpdate || this._scrollHeight === 0;
        forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;

        // amortize height adjustment, so it won't trigger repaints very often
        if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._optPhysicalSize) {
          this.$.items.style.height = this._estScrollHeight + 'px';
          this._scrollHeight = this._estScrollHeight;
        }
      },

      /**
       * Scroll to a specific index in the virtual list regardless
       * of the physical items in the DOM tree.
       *
       * @method scrollToIndex
       * @param {number} idx The index of the item
       */
      scrollToIndex: function(idx) {
        Polymer.dom.flush();

        idx = Math.min(Math.max(idx, 0), this._virtualCount - 1);
        // update the virtual start only when needed
        if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {
          this._virtualStart = idx - 1;
        }
        // assign new models
        this._assignModels();
        // measure the new sizes
        this._updateMetrics();

        // estimate new physical offset
        var estPhysicalTop = Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage;
        this._physicalTop = estPhysicalTop;

        var currentTopItem = this._physicalStart;
        var currentVirtualItem = this._virtualStart;
        var targetOffsetTop = 0;
        var hiddenContentSize = this._hiddenContentSize;

        // scroll to the item as much as we can
        while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {
          targetOffsetTop = targetOffsetTop + this._getPhysicalSizeIncrement(currentTopItem);
          currentTopItem = (currentTopItem + 1) % this._physicalCount;
          currentVirtualItem++;
        }
        // update the scroller size
        this._updateScrollerSize(true);
        // update the position of the items
        this._positionItems();
        // set the new scroll position
        this._resetScrollPosition(this._physicalTop + this._scrollerPaddingTop + targetOffsetTop);
        // increase the pool of physical items if needed
        this._increasePoolIfNeeded();
        // clear cached visible index
        this._firstVisibleIndexVal = null;
        this._lastVisibleIndexVal = null;
      },

      /**
       * Reset the physical average and the average count.
       */
      _resetAverage: function() {
        this._physicalAverage = 0;
        this._physicalAverageCount = 0;
      },

      /**
       * A handler for the `iron-resize` event triggered by `IronResizableBehavior`
       * when the element is resized.
       */
      _resizeHandler: function() {
        // iOS fires the resize event when the address bar slides up
        if (IOS && Math.abs(this._viewportHeight - this._scrollTargetHeight) < 100) {
          return;
        }
        // In Desktop Safari 9.0.3, if the scroll bars are always shown,
        // changing the scroll position from a resize handler would result in
        // the scroll position being reset. Waiting 1ms fixes the issue.
        Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', function() {
          this.updateViewportBoundaries();
          this._render();

          if (this._itemsRendered && this._physicalItems && this._isVisible) {
            this._resetAverage();
            this.scrollToIndex(this.firstVisibleIndex);
          }
        }.bind(this), 1));
      },

      /**
       * Updates the size of an item.
       *
       * @method updateSizeForItem
       * @param {|number} index
       */
       // TODO: rename to updateSizeForIndex ?
      updateSizeForItem: function(index) {
        var pidx = this._physicalIndexForKey[index];

        if (pidx != null) {
          this._updateMetrics([pidx]);
          this._positionItems();
        }
      },

      _isIndexRendered: function(idx) {
        return idx >= this._virtualStart && idx <= this._virtualEnd;
      },

      _isIndexVisible: function(idx) {
        return idx >= this.firstVisibleIndex && idx <= this.lastVisibleIndex;
      }
    });
  })();

  /**
   * @polymerBehavior vaadin.elements.grid.IronListBehavior
   */
  vaadin.elements.grid.IronListBehavior = [
    Polymer.Templatizer,
    Polymer.IronResizableBehavior,
    Polymer.IronScrollTargetBehavior,
    vaadin.elements.grid.IronListBehaviorImpl
  ];
</script><dom-module id="vaadin-grid-table-styles" assetpath="../../../bower_components/vaadin-grid/">
  <template>
    <style>

      @keyframes appear {
        to {
          opacity: 1;
        }
      }

      :host {
        display: block;
        position: relative;
        animation: 0 appear;
      }

      @media only screen and (-webkit-max-device-pixel-ratio: 1) {
        :host {
          will-change: transform;
        }
      }

      #items {
        position: relative;
      }

      #items,
      #fixedsizer,
      #outersizer {
        border-top: 0 solid transparent;
        border-bottom: 0 solid transparent;
      }

      :host(:not([grid])) #items > ::content > * {
        width: 100%;
      }

      #items > tr {
        box-sizing: border-box;
        margin: 0;
        position: absolute;
        /* iron-list expects top to be 0. Might cause issues */
        /* top: 0; */
        will-change: transform;
      }

      table {
        height: 100%;
        width: 100%;
        display: block;
        overflow: auto;
        box-sizing: border-box;
      }

      [overflow-hidden] {
        overflow: hidden;
      }

      tbody {
        display: block;
      }

      thead th,
      tfoot td {
        top: 0;
      }

      .vaadin-grid-cell {
        padding: 0;
        flex-shrink: 0;
        flex-grow: 1;
        box-sizing: border-box;
        display: flex;
      }

      .vaadin-grid-cell:not([detailscell]) {
        position: relative;
      }

      .vaadin-grid-cell ::content > .cell-content {
         width: 100%;
         display: inline-flex;
         justify-content: center;
         flex-direction: column;
         white-space: nowrap;
         overflow: hidden;
      }

      .vaadin-grid-column-resize-handle {
        position: absolute;
        right: 0;
        height: 100%;
        cursor: col-resize;
        z-index: 1;
      }

      .vaadin-grid-column-resize-handle::before {
        position: absolute;
        content: "";
        height: 100%;
        width: 35px;
        transform: translateX(-50%);
      }

      [lastcolumn] .vaadin-grid-column-resize-handle::before,
      [last-frozen] .vaadin-grid-column-resize-handle::before {
        width: 18px;
        transform: translateX(-100%);
      }

      :host([column-resizing]) {
        -ms-user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        user-select: none;
        cursor: col-resize;
      }

      :host([ios][column-resizing]) #outerscroller {
        overflow: hidden;
      }

      tr:not([hidden]) {
        display: flex;
        width: 100%;
      }

      [frozen] {
        z-index: 2;
      }

      [hidden] {
        display: none;
      }

      caption {
        position: absolute;
        display: block;
        padding: 0;
        width: 100%;
        z-index: -100;
      }

      ::content > vaadin-grid-column,
      ::content > vaadin-grid-selection-column,
      ::content > vaadin-grid-column-group {
        display: none;
      }

      /* Style overrides required to make copying the selection to clipboard work properly (on Safari) */
      :host([copying]) tr {
        opacity: 0 !important;
        position: static !important;
        display: table-row !important;
      }

      :host([copying]) .vaadin-grid-cell {
        display: table-cell !important;
      }
    </style>
  </template>
</dom-module>

<dom-module id="vaadin-grid-table-themability-styles" assetpath="../../../bower_components/vaadin-grid/">
  <template>
    <style>

      /* Default borders */

      thead tr:last-child th ::content > .cell-content {
        border-bottom: 1px solid var(--divider-color, rgba(0, 0, 0, 0.08));
      }

      tfoot tr:first-child td ::content > .cell-content {
        border-top: 1px solid var(--divider-color, rgba(0, 0, 0, 0.08));
      }

      tbody tr:not([lastrow]) td ::content > .cell-content {
        border-bottom: 1px solid var(--divider-color, rgba(0, 0, 0, 0.08));
      }

      [last-frozen] ::content > .cell-content {
        border-right: 1px solid var(--divider-color, rgba(0, 0, 0, 0.08));
      }

      /* Column resize handle */

      .vaadin-grid-column-resize-handle {
        border-right: 1px solid var(--divider-color, rgba(0, 0, 0, 0.08));
        @apply(--vaadin-grid-column-resize-handle);
      }

      /* Cells */

      table tr .vaadin-grid-cell:not([detailscell]) ::content > .cell-content {
        background: #fff;
        text-align: left;
        padding: 8px;
        box-sizing: border-box;
        @apply(--vaadin-grid-cell);
      }

      table thead .vaadin-grid-cell:not([detailscell]) ::content > .cell-content {
        font-weight: 500;
        @apply(--vaadin-grid-header-cell);
      }

      table tfoot .vaadin-grid-cell:not([detailscell]) ::content > .cell-content {
        font-weight: 500;
        @apply(--vaadin-grid-footer-cell);
      }

      table tbody .vaadin-grid-cell:not([detailscell]) ::content > .cell-content {
        @apply(--vaadin-grid-body-cell);
      }

      tbody [odd] .vaadin-grid-cell:not([detailscell]) ::content > .cell-content {
        @apply(--vaadin-grid-body-row-odd-cell);
      }

      table tr .vaadin-grid-cell:not([detailscell])[last-frozen] ::content > .cell-content {
        @apply(--vaadin-grid-cell-last-frozen);
      }

      :host(:not([scrolling])) tbody tr:hover .vaadin-grid-cell ::content > .cell-content {
        @apply(--vaadin-grid-body-row-hover-cell);
      }

      table tr .vaadin-grid-cell.vaadin-grid-cell[lastcolumn] ::content > .cell-content {
        border-right: none;
      }

    </style>
  </template>
</dom-module>

<dom-module id="vaadin-grid-table" assetpath="../../../bower_components/vaadin-grid/">
  <template>
    <style include="vaadin-grid-table-scroll-styles"></style>
    <style include="vaadin-grid-row-details-styles"></style>
    <style include="vaadin-grid-data-source-styles"></style>
    <style include="vaadin-grid-table-styles"></style>

    <style include="vaadin-grid-table-themability-styles"></style>
    <style include="vaadin-grid-selection-themability-styles"></style>
    <style include="vaadin-grid-navigation-themability-styles"></style>
    <style include="vaadin-grid-active-item-themability-styles"></style>
    <style include="vaadin-grid-data-source-themability-styles"></style>
    <style include="vaadin-grid-row-details-themability-styles"></style>
    <style include="vaadin-grid-column-reordering-themability-styles"></style>


    <!-- trap needs to have content in order for Safari to scroll the page when focused -->
    <div id="headerFocusTrap" tabindex="0" on-focus="_onHeaderFocus" style="position: absolute;z-index: -1">&nbsp;</div>
    <div id="bodyFocusTrap" tabindex="-1" on-focus="_onBodyFocus" style="position: absolute;z-index: -1">&nbsp;</div>

    <content select="vaadin-grid-column, vaadin-grid-selection-column, vaadin-grid-column-group"></content>

    <div id="spinner"></div>
    <table id="table" overflow-hidden$="[[_hideTableOverflow(scrollbarWidth, safari)]]">
      <caption>
        <div id="fixedsizer" is="vaadin-grid-sizer" top="[[_estScrollHeight]]" column-tree="[[columnTree]]">
        </div>
      </caption>
      <thead id="header" target="[[target]]" is="vaadin-grid-table-header" column-tree="[[columnTree]]"></thead>
      <tbody id="items" is="vaadin-grid-table-body"></tbody>
      <tfoot id="footer" target="[[target]]" is="vaadin-grid-table-footer" column-tree="[[columnTree]]"></tfoot>
    </table>

    <vaadin-grid-table-outer-scroller id="outerscroller" scroll-target="[[scrollTarget]]" overflow-hidden$="[[_hideOuterScroller(scrollbarWidth, safari)]]" ios$="[[ios]]" scrolling$="[[scrolling]]">
      <div id="outersizer" is="vaadin-grid-sizer" top="[[_estScrollHeight]]" column-tree="[[columnTree]]"></div>
    </vaadin-grid-table-outer-scroller>

    <!--
      in native Shadow, we move the footer focus trap to light DOM.
      It needs to be injected/slotted back inside the shadow root in order to be focusable.
     -->
    <content select="#footerFocusTrap"></content>
    <div id="footerFocusTrap" tabindex="0" on-focus="_onFooterFocus" style="position: absolute;z-index: -1">&nbsp;</div>
  </template>
</dom-module>

<script>

  Polymer({

    is: 'vaadin-grid-table',

    behaviors: [
      vaadin.elements.grid.IronListBehavior,
      vaadin.elements.grid.TableScrollBehavior,
      vaadin.elements.grid.TableKeyboardBehavior,
      vaadin.elements.grid.TableColumnReorderingBehavior,
      Polymer.Templatizer,
      Polymer.IronResizableBehavior
    ],

    properties: {
      size: Number,

      columnTree: Array,

      bindData: Function,

      rowDetailsTemplate: Object,

      safari: {
        value: /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
      },

      scrollbarWidth: {
        value: function() {
          // Create the measurement node
          var scrollDiv = document.createElement('div');
          scrollDiv.style.width = '100px';
          scrollDiv.style.height = '100px';
          scrollDiv.style.overflow = 'scroll';
          scrollDiv.style.position = 'absolute';
          scrollDiv.style.top = '-9999px';
          document.body.appendChild(scrollDiv);
          // Get the scrollbar width
          var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;

          // Delete the DIV
          document.body.removeChild(scrollDiv);
          return scrollbarWidth;
        }
      },

      target: Object
    },

    observers: [
      '_columnTreeChanged(columnTree, _physicalItems, _physicalCountVal)',
      '_sizeChanged(size, bindData)',
      '_rowDetailsTemplateChanged(rowDetailsTemplate, _physicalItems, _physicalCountVal)'
    ],

    listeners: {
      'property-changed': '_columnPropChanged',
      'copy': '_onCopy',
      'animationend': '_onAnimationEnd',
      'track': '_onTrack'
    },

    _onTrack: function() {
      this.toggleAttribute('column-resizing', this.$.header.querySelector('[column-resizing]'));
    },

    _onAnimationEnd: function(e) {
      if (/appear/.test(e.animationName)) {
        this._render();
        this._updateHeaderFooterMetrics();
        e.stopPropagation();
      }
    },

    _columnPropChanged: function(e) {
      if (e.detail.path === 'headerTemplate') {
        this.toggleAttribute('has-templates', true, this.$.header);
      }

      if (e.detail.path === 'footerTemplate') {
        this.toggleAttribute('has-templates', true, this.$.footer);
      }

      if (/frozen|hidden/.test(e.detail.path)) {
        this._frozenCellsChanged();
      }

      if (e.detail.path === 'hidden') {
        this.notifyResize();
      }
    },

    _onCopy: function() {
      if (this.safari) {
        this.toggleAttribute('copying', true);
        this.async(function() {
          this.toggleAttribute('copying', false);
        }, 1);
      }
    },

    // The following values aim at avoiding having 2 overlapping semi-invisible
    // scrollbars visible at the same time when scrollbar width is 0
    // (OSX's "show scrollbars: when scrolling").
    // 1. hide the outerscroller altogether when scrollbar width is 0
    _hideOuterScroller: function(scrollbarWidth, safari) {
      return scrollbarWidth === 0 && !safari;
    },
    // 2. Safari (on desktop and IOS) requires outer scroller to work properly
    // so in that case we hide the table's scrollbar instead.
    _hideTableOverflow: function(scrollbarWidth, safari) {
      return scrollbarWidth === 0 && safari;
    },

    _rowDetailsTemplateChanged: function(rowDetailsTemplate, physicalItems) {
      physicalItems.forEach(function(row) {
        row.rowDetailsTemplate = rowDetailsTemplate;
      });
    },

    _columnTreeChanged: function(columnTree, physicalItems, count) {
      this._frozenCellsChanged();
      this._hasTemplatesChanged(columnTree);

      physicalItems.forEach(function(row) {
        row.columns = columnTree[columnTree.length - 1];
      });

      this._updateHeaderFooterMetrics();
      this._updateLastColumn();
    },

    _updateLastColumn: function() {
      Polymer.dom(this.$.table).querySelectorAll('tr').forEach(function(row) {
        row.updateLastColumn();
      });
    },

    _updateHeaderFooterMetrics: function() {
      Polymer.RenderStatus.afterNextRender(this.$.header, function() {
        var headerHeight = this.$.header.clientHeight + 'px';
        var footerHeight = this.$.footer.clientHeight + 'px';

        [this.$.outersizer, this.$.fixedsizer, this.$.items].forEach(function(element) {
          element.style.borderTopWidth = headerHeight;
          element.style.borderBottomWidth = footerHeight;
        });
        if (this._pendingScrollToScaledIndex) {
          this.scrollToScaledIndex(this._pendingScrollToScaledIndex);
        }
      }.bind(this));
    },

    _hasTemplatesChanged: function(columnTree) {
      var hasHeaders = false;
      var hasFooters = false;
      columnTree.forEach(function(row) {
        return row.forEach(function(col) {
          hasHeaders = hasHeaders || col.headerTemplate;
          hasFooters = hasFooters || col.footerTemplate;
        });
      });

      this.toggleAttribute('has-templates', hasHeaders, this.$.header);
      this.toggleAttribute('has-templates', hasFooters, this.$.footer);
    },

    /**
     * Creates a pool of DOM elements and attaches them to the local dom.
     */
    _createPool: function(size) {
      var physicalItems = new Array(size);

      for (var i = 0; i < size; i++) {
        var row = document.createElement('tr', 'vaadin-grid-table-row');
        row.target = this.domHost;
        physicalItems[i] = row;
        row.setAttribute('hidden', ''); // hidden by default, removed when data is bound.
        Polymer.dom(this.$.items).appendChild(row);
      }

      return physicalItems;
    },

    _sizeChanged: function(size) {
      this._virtualStart = 0;
      this._physicalTop = 0;

      /* TODO: virtual count of 500k will make the sizer.top too large for Firefox */
      this._virtualCount = Math.min(size, 100000);
      this._physicalIndexForKey = {};
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;

      this._vidxOffset = 0;
      this._resetScrollPosition(0);

      if (!this._physicalItems) {
        var DEFAULT_PHYSICAL_COUNT = 25;

        this._physicalCount = Math.max(1, Math.min(DEFAULT_PHYSICAL_COUNT, this._virtualCount));
        this._physicalItems = this._createPool(this._physicalCount);
        this._physicalSizes = new Array(this._physicalCount);
      }

      this._physicalStart = 0;

      this._itemsRendered = false;
      this._debounceTemplate(this._render);
    },

    /**
     * Assigns the data models to a given set of items.
     * @param {!Array<number>=} itemSet
     */
    _assignModels: function(itemSet) {
      this._virtualIndexToItem = this._virtualIndexToItem || {};
      this._iterateItems(function(pidx, vidx) {
        var el = this._physicalItems[pidx];
        if (el.index) {
          delete this._virtualIndexToItem[el.index];
        }
        el.index = vidx + this._vidxOffset;
        this._virtualIndexToItem[el.index] = el;
        el.toggleAttribute('odd', el.index % 2);
        el.toggleAttribute('lastrow', el.index === this.size - 1);
        el.toggleAttribute('hidden', el.index >= this.size);
        this.bindData(el.index, el);
      }, itemSet);
    }

  });

</script>
<!--
@license
Copyright (c) 2016 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
--><!--

A `vaadin-grid-column` is used to configure how a column in `vaadin-grid` should look like by using HTML templates.
A column can have a template for each of the three table sections: header, body and footer.

The `class` attribute is used to differentiate header and footer templates from the body template.

#### Example:

    <vaadin-grid-column>
      <template class="header">I'm in the header</template>
      <template>I'm in the body</template>
      <template class="footer">I'm in the footer</template>
    </vaadin-grid-column>

-->
<dom-module id="vaadin-grid-column" assetpath="../../../bower_components/vaadin-grid/">
</dom-module>

<!--

A `vaadin-grid-column-group` is used to wrap many columns under a common header. It supports nested groups.

The `class` attribute is used to differentiate header and footer templates.

#### Example:

    <vaadin-grid>
      <vaadin-grid-column-group>
        <template class="header">I'm in the group header</template>
        <template class="footer">I'm in the group footer</template>
        <vaadin-grid-column>
          <template class="header">I'm in the first header</template>
          <template>I'm in the first body cell</template>
          <template class="footer">I'm in the first footer</template>
        </vaadin-grid-column>
        <vaadin-grid-column>
          <template class="header">I'm in the second header</template>
          <template>I'm in the second body cell</template>
          <template class="footer">I'm in the second footer</template>
        </vaadin-grid-column>
      </vaadin-grid-column-group>
    </vaadin-grid>

-->
<dom-module id="vaadin-grid-column-group" assetpath="../../../bower_components/vaadin-grid/">
</dom-module>

<script>

  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.ColumnBaseBehavior
   */
  vaadin.elements.grid.ColumnBaseBehavior = {
    properties: {

      /**
       * When set to true, the column is user-resizable.
       */
      resizable: {
        type: Boolean,
        value: function() {
          var parent = Polymer.dom(this).parentNode;
          if (parent && parent.localName === 'vaadin-grid-column-group') {
            return parent.resizable;
          }
        }
      },

      /**
       * @private
       */
      headerTemplate: {
        type: Object,
        value: function() {
          return this._findTemplate('template.header') || null;
        }
      },

      /**
       * @private
       */
      footerTemplate: {
        type: Object,
        value: function() {
          return this._findTemplate('template.footer') || null;
        }
      },

      /**
       * When true, the column is frozen. When a column inside of a column group is frozen,
       * all of the sibling columns inside the group will get frozen also.
       */
      frozen: {
        type: Boolean,
        notify: true,
        value: false
      },

      _lastFrozen: {
        type: Boolean,
        notify: true,
        value: false
      },

      _order: Number,

      _reorderStatus: Boolean
    },

    observers: [
      '_footerTemplateChanged(footerTemplate)',
      '_headerTemplateChanged(headerTemplate)',
      '_lastFrozenChanged(_lastFrozen)'
    ],

    _selectFirstTemplate: function(selector) {
      return Polymer.dom(this).querySelectorAll(selector).filter(function(el) {
        return el.parentElement === this;
      }.bind(this))[0];
    },

    _findTemplate: function(selector) {
      var template = this._selectFirstTemplate(selector);
      if (template) {
        if (this.dataHost) {
          // set dataHost to the context where template has been defined
          template._rootDataHost = this.dataHost._rootDataHost || this.dataHost;
        }
      }
      return template;
    },

    _headerTemplateChanged: function(headerTemplate) {
      if (headerTemplate) {
        var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);
        templatizer._instanceProps = {};
        templatizer.template = headerTemplate;
      }

      this.fire('property-changed', {path: 'headerTemplate', value: headerTemplate});
    },

    _footerTemplateChanged: function(footerTemplate) {
      if (footerTemplate) {
        var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);
        templatizer._instanceProps = {};
        templatizer.template = footerTemplate;
      }

      this.fire('property-changed', {path: 'footerTemplate', value: footerTemplate});
    },

    _flexGrowChanged: function(flexGrow) {
      this.fire('property-changed', {path: 'flexGrow', value: flexGrow});
    },

    _widthChanged: function(width) {
      this.fire('property-changed', {path: 'width', value: width});
    },

    _lastFrozenChanged: function(lastFrozen) {
      this.fire('property-changed', {path: 'lastFrozen', value: lastFrozen});
    }
  };

  /**
   * @polymerBehavior vaadin.elements.grid.ColumnBehaviorImpl
   */
  vaadin.elements.grid.ColumnBehaviorImpl = {
    properties: {
      /**
       * Width of the cells for this column.
       */
      width: {
        type: String,
        value: '100px'
      },

      /**
       * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
       */
      flexGrow: {
        type: Number,
        value: 1
      },

      /**
       * @private
       */
      template: {
        type: Object,
        value: function() {
          return this._findTemplate('template:not(.header):not(.footer)');
        }
      },

      /**
       * When set to true, the cells for this column are hidden.
       */
      hidden: {
        type: Boolean
      }

    },

    observers: [
      '_flexGrowChanged(flexGrow)',
      '_widthChanged(width)',
      '_templateChanged(template)',
      '_frozenChanged(frozen, isAttached)',
      '_hiddenChanged(hidden)',
      '_orderChanged(_order)',
      '_reorderStatusChanged(_reorderStatus)',
      '_resizableChanged(resizable)'
    ],

    _frozenChanged: function(frozen, isAttached) {
      // since `frozen` is defined in ColumnBaseBehavior, this observer is triggered
      // normally before the column is actually attached to the DOM.
      // For events to bubble in Safari 9, element needs to be attached.
      if (isAttached) {
        this.fire('property-changed', {path: 'frozen', value: frozen});
      }
    },

    _templateChanged: function(template) {
      var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);

      // body cell templatizer needs to be attached so that `item-changed` and
      // `template-instance-changed` events propagate to grid.
      Polymer.dom(this.root).appendChild(templatizer);

      templatizer.template = template;

      // We bubble false for optimisation
      this.fire('property-changed', {path: 'template', value: template}, {bubbles: false});
    },

    _hiddenChanged: function(hidden) {
      this.fire('property-changed', {path: 'hidden', value: hidden});
    },

    _orderChanged: function(order) {
      this.fire('property-changed', {path: 'order', value: order});
    },

    _reorderStatusChanged: function(reorderStatus) {
      this.fire('property-changed', {path: 'reorderStatus', value: reorderStatus});
    },

    _resizableChanged: function(resizable) {
      this.fire('property-changed', {path: 'resizable', value: resizable});
    },
  };

  /**
   * @polymerBehavior vaadin.elements.grid.ColumnBehavior
   */
  vaadin.elements.grid.ColumnBehavior = [
    vaadin.elements.grid.ColumnBaseBehavior,
    vaadin.elements.grid.ColumnBehaviorImpl
  ];

  Polymer({
    is: 'vaadin-grid-column',

    behaviors: [vaadin.elements.grid.ColumnBehavior]
  });


  Polymer({
    is: 'vaadin-grid-column-group',

    behaviors: [vaadin.elements.grid.ColumnBaseBehavior],

    properties: {
      _childColumns: {
        value: function() {
          return Polymer.dom(this).querySelectorAll('vaadin-grid-column, vaadin-grid-selection-column');
        }
      },

      /**
       * Flex grow ratio for the column group as the sum of the ratios of its child columns.
       */
      flexGrow: {
        type: Number,
        readOnly: true
      },

      /**
       * Width of the column group as the sum of the widths of its child columns.
       */
      width: {
        type: String,
        readOnly: true
      },

      _visibleChildColumns: Array,

      /**
       * `true` when all of its child columns are hidden.
       */
      hidden: {
        type: Boolean,
        notify: true,
        readOnly: true
      },

      /**
       * Represents the number of child columns of this group.
       */
      colSpan: {
        type: Number,
        notify: true,
        readOnly: true
      },

      _rootColumns: Array
    },

    observers: [
      '_updateVisibleChildColumns(_childColumns)',
      '_childColumnsChanged(_childColumns)',
      '_flexGrowChanged(flexGrow)',
      '_widthChanged(width)',
      '_frozenChanged(_childColumns, frozen)',
      '_hiddenChanged(hidden)',
      '_visibleChildColumnsChanged(_visibleChildColumns)',
      '_colSpanChanged(colSpan)',
      '_orderChanged(_order, _rootColumns)',
      '_reorderStatusChanged(_reorderStatus, _rootColumns)',
      '_resizableChanged(resizable, _rootColumns)'
    ],

    listeners: {
      'property-changed': '_columnPropChanged'
    },

    attached: function() {
      this._updateFlexAndWidth(this._visibleChildColumns);
      this._addNodeObserver();
    },

    detached: function() {
      Polymer.dom(this).unobserveNodes(this._observer);
    },

    _columnPropChanged: function(e) {
      if (e.detail.path === 'hidden') {
        this._updateVisibleChildColumns(this._childColumns);
      }

      if (/flexGrow|width|hidden|_childColumns/.test(e.detail.path)) {
        this._updateFlexAndWidth(this._visibleChildColumns);
      }

      if (e.detail.path === 'frozen') {
        this.frozen = e.detail.value;
      }

      if (e.detail.path === 'lastFrozen') {
        this._lastFrozen = e.detail.value;
      }
    },

    _orderChanged: function(order, rootColumns) {
      if (order) {
        // The parent column order number cascades downwards to it's children
        // so that the resulting order numbering constructs as follows:
        // [             1000              ]
        // [     1100    ] | [     1200    ]
        // [1110] | [1120] | [1210] | [1220]

        // Trailing zeros are counted so we know the level on which we're working on.
        var trailingZeros = /(0+)$/.exec(order).pop().length;

        // In an unlikely situation where a group has more than 9 child columns,
        // the child scope must have 1 digit less...
        var childCountDigits = ~~Math.log10(rootColumns.length) + 1;

        // Final scope for the child columns needs to mind both factors.
        var scope = Math.pow(10, trailingZeros - childCountDigits);

        var _rootColumns = rootColumns.slice(0);
        if (_rootColumns[0] && _rootColumns[0]._order) {
          _rootColumns.sort(function(a, b) {
            return a._order - b._order;
          });
        }
        
        _rootColumns.forEach(function(column, index) {
          column._order = order + ((index + 1) * scope);
        });

        this.fire('property-changed', {path: 'order', value: order});
      }
    },

    _reorderStatusChanged: function(reorderStatus, rootColumns) {
      rootColumns.forEach(function(column) {
        column._reorderStatus = reorderStatus;
      });

      this.fire('property-changed', {path: 'reorderStatus', value: reorderStatus});
    },

    _resizableChanged: function(resizable, rootColumns) {
      rootColumns.forEach(function(column) {
        column.resizable = resizable;
      });

      this.fire('property-changed', {path: 'resizable', value: resizable});
    },

    _updateVisibleChildColumns: function(childColumns) {
      this._visibleChildColumns = childColumns.filter(function(col) {
        return !col.hidden;
      });
    },

    _childColumnsChanged: function(childColumns) {
      this.fire('property-changed', {path: '_childColumns', value: childColumns});
    },

    _updateFlexAndWidth: function(visibleChildColumns) {
      this._setWidth('calc(' + visibleChildColumns.reduce(function(prev, curr) {
        return prev += ' + ' + (curr.width || '0').replace('calc', '');
      }, '').substring(3) + ')');

      this._setFlexGrow(visibleChildColumns.reduce(function(prev, curr) {
        return prev + curr.flexGrow;
      }, 0));
    },

    _frozenChanged: function(childColumns, frozen) {
      childColumns.forEach(function(col) {
        col.frozen = frozen;
      });
      this.fire('property-changed', {path: 'frozen', value: frozen});
    },

    _hiddenChanged: function(hidden) {
      this.fire('property-changed', {path: 'hidden', value: hidden});
    },

    _visibleChildColumnsChanged: function(visibleChildColumns) {
      this._setColSpan(visibleChildColumns.length);
      this._setHidden(this.colSpan === 0);
    },

    _colSpanChanged: function(colSpan) {
      this.fire('property-changed', {path: 'colSpan', value: colSpan});
    },

    _addNodeObserver: function() {
      this._observer = Polymer.dom(this).observeNodes(function(info) {
        this._rootColumns = Polymer.dom(this).children.filter(function(child) {
          return /column/.test(child.localName);
        });
        var columns = function(node) {
          return (node.nodeType === Node.ELEMENT_NODE && node.localName.indexOf('vaadin-grid-column') === 0);
        };
        if (info.addedNodes.filter(columns).length > 0 ||
        info.removedNodes.filter(columns).length > 0) {
          this._childColumns = Polymer.dom(this).querySelectorAll('vaadin-grid-column');
        }
      }.bind(this));
    }
  });

</script>
<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.ArrayDataSourceBehavior
   */
  vaadin.elements.grid.ArrayDataSourceBehavior = {

    properties: {

      /**
       * An array containing the items which will be stamped to the column template
       * instances.
       */
      items: Array

    },

    observers: [
      '_itemsChanged(items, items.*)'
    ],

    _itemsChanged: function(items, splices) {
      this.size = (items || []).length;
      this.dataSource = this.dataSource || this._arrayDataSource;
      this.clearCache();
    },

    _arrayDataSource: function(opts, cb) {
      var items = (this.items || []).slice(0);

      items = this._filter(items);
      this.size = items.length;

      if (opts.sortOrder.length) {
        items = items.sort(this._multiSort.bind(this));
      }

      var start = opts.page * opts.pageSize;
      var end = start + opts.pageSize;
      var slice = items.slice(start, end);
      cb(slice, items.length);
    },

    _multiSort: function(a, b) {
      return this._sorters.map(function(sort) {
        if (sort.direction === 'asc') {
          return this._compare(Polymer.Base.get(sort.path, a), Polymer.Base.get(sort.path, b));
        } else if (sort.direction === 'desc') {
          return this._compare(Polymer.Base.get(sort.path, b), Polymer.Base.get(sort.path, a));
        }
        return 0;
      }, this).reduce(function firstNonZeroValue(p, n) {
        return p ? p : n;
      }, 0);
    },

    _compare: function(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    },

    _filter: function(items) {
      return items.filter(function(item, index) {
        return this._filters.filter(function(filter) {
          var value = Polymer.Base.get(filter.path, item) || '';
          return value.toString().toLowerCase().indexOf(filter.value.toString().toLowerCase()) === -1;
        }).length === 0;
      }, this);
    }

  };
</script>
<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.DynamicColumnsBehavior
   */
  vaadin.elements.grid.DynamicColumnsBehavior = {
    ready: function() {
      this._addNodeObserver();
    },

    _hasColumnGroups: function(columns) {
      for (var i = 0; i < columns.length; i++) {
        if (columns[i].localName === 'vaadin-grid-column-group') {
          return true;
        }
      }

      return false;
    },

    _childrenColumns: function(columns) {
      return columns.map(function(col) {
        if (col.localName === 'vaadin-grid-column-group') {
          var children = Polymer.dom(col).children.filter(function(el) {
            return /^vaadin-grid-(column|selection)/.test(el.localName);
          });
          return children;
        } else {
          return [col];
        }
      }).reduce(function(prev, curr) {
        return prev.concat(curr);
      }, []);
    },

    _getColumnTree: function() {
      var rootColumns = this.queryAllEffectiveChildren(
        'vaadin-grid-column, vaadin-grid-column-group, vaadin-grid-selection-column');

      var _columnTree = [];

      for (var c = rootColumns; ; ) {
        _columnTree.push(c);
        if (!this._hasColumnGroups(c)) {
          break;
        }
        c = this._childrenColumns(c);
      }

      return _columnTree;
    },

    _updateColumnTree: function() {
      var columnTree = this._getColumnTree();
      if (!this._arrayEquals(columnTree, this._columnTree)) {
        this._columnTree = columnTree;
      }
    },

    _addNodeObserver: function() {
      this._observer = Polymer.dom(this).observeNodes(function(info) {
        var rootColumns = function(node) {
          return (node.nodeType === Node.ELEMENT_NODE && /^vaadin-grid-(column|selection)/i.test(node.localName));
        };
        if (info.addedNodes.filter(rootColumns).length > 0 ||
          info.removedNodes.filter(rootColumns).length > 0) {
          this._updateColumnTree();
        }

        // in native Shadow, tab order goes first through shadow root, then moves over
        // to light children. We need to make sure footer focus trap is always
        // the very last element that can be tabbed into.
        if (Polymer.Settings.useNativeShadow) {
          Polymer.dom(this).appendChild(this.$.scroller.$.footerFocusTrap);
        }
      }.bind(this));
    },

    _arrayEquals: function(arr1, arr2) {
      if (!arr1 || !arr2 || arr1.length != arr2.length) {
        return false;
      }

      for (var i = 0, l = arr1.length; i < l; i++) {
        // Check if we have nested arrays
        if (arr1[i] instanceof Array && arr2[i] instanceof Array) {
          // recurse into the nested arrays
          if (!this._arrayEquals(arr1[i], arr2[i])) {
            return false;
          }
        } else if (arr1[i] != arr2[i]) {
          return false;
        }
      }
      return true;
    }
  };
</script>
<!--
@license
Copyright (c) 2016 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
--><dom-module id="vaadin-grid-sorter" assetpath="../../../bower_components/vaadin-grid/">
  <template>
    <style>
      :host {
        display: inline-flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
      }

      #indicators {
        position: relative;
      }

      :host(:not([direction])) #order,
      :host(:not([direction])) #indicators::before {
        opacity: 0.2;
      }

      #order {
        position: absolute;
        right: 0;
        top: 0;
        transform: translateY(-4px) scale(0.7);
        @apply(--vaadin-grid-sorter-order);
      }

      #indicators::before {
        content: "▲";
        display: block;
        padding: 0 8px;
        @apply(--vaadin-grid-sorter-arrow);
      }

      :host([direction=desc]) #indicators::before {
        transform: rotateZ(180deg);
      }
    </style>

    <content></content>
    <div id="indicators">
      <div id="order">[[_getDisplayOrder(_order)]]</div>
    </div>

  </template>
  <script>
    Polymer({
      is: 'vaadin-grid-sorter',

      properties: {

        /**
         * JS Path of the property in the item used for sorting the data.
         */
        path: String,

        /**
         * How to sort the data.
         * Possible values are `asc` to use an ascending algorithm, `desc` to sort the data in
         * descending direction, or `null` for not sorting the data.
         */
        direction: {
          type: String,
          reflectToAttribute: true,
          notify: true,
          value: null
        },

        _order: Number

      },

      observers: [
        '_propertiesChanged(path, direction, isAttached)'
      ],

      behaviors: [
        vaadin.elements.grid.CellClickBehavior
      ],

      _propertiesChanged: function(path, direction, isAttached) {
        if (isAttached) {
          this.fire('sorter-changed');
        }
      },

      _getDisplayOrder: function(order) {
        return order === null ? '' : order + 1;
      },

      _cellClick: function(e) {
        if (this.direction === 'asc') {
          this.direction = 'desc';
        } else if (this.direction === 'desc') {
          this.direction = null;
        } else {
          this.direction = 'asc';
        }
      }

    });
  </script>
</dom-module>

<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.SortBehavior
   */
  vaadin.elements.grid.SortBehavior = {

    properties: {

      _sorters: {
        type: Array,
        value: function() {
          return [];
        }
      },

      _previousSorters: {
        type: Array,
        value: function() {
          return [];
        }
      }

    },

    listeners: {
      'sorter-changed': '_onSorterChanged'
    },

    _onSorterChanged: function(e) {
      var sorter = e.target;

      this._removeArrayItem(this._sorters, sorter);
      if (sorter.direction) {
        this._sorters.unshift(sorter);
      }

      sorter._order = null;
      this._sorters.forEach(function(sorter, index) {
        sorter._order = this._sorters.length > 1 ? index : null;
      }, this);

      e.stopPropagation();

      if (this.dataSource &&
        // No need to clear cache if sorters didn't change
        JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters())) {
        this.clearCache();
      }

      this._previousSorters = this._mapSorters();
    },

    _mapSorters: function() {
      return this._sorters.map(function(sorter) {
        return {
          path: sorter.path,
          direction: sorter.direction
        };
      });
    },

    _removeArrayItem: function(array, item) {
      var index = array.indexOf(item);
      if (index > -1) {
        array.splice(index, 1);
      }
    },

  };
</script>
<!--
@license
Copyright (c) 2016 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
--><dom-module id="vaadin-grid-filter" assetpath="../../../bower_components/vaadin-grid/">
  <template>
    <style>
      :host {
        display: inline-flex;
      }

      #filter {
        width: 100%;
        box-sizing: border-box;
      }
    </style>

    <content select="*">
      <input id="filter" value="{{value::input}}">
    </content>

  </template>
  <script>
    Polymer({
      is: 'vaadin-grid-filter',

      properties: {

        /**
         * JS Path of the property in the item used for filtering the data.
         */
        path: String,

        /**
         * Current filter value.
         */
        value: {
          type: String,
          notify: true
        }
      },

      observers: ['_filterChanged(path, value, isAttached)'],

      _filterChanged: function(path, value, isAttached) {
        if (isAttached) {
          this.debounce('filter-changed', function() {
            this.fire('filter-changed');
          }, 200);
        }
      }
    });
  </script>
</dom-module>

<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.FilterBehavior
   */
  vaadin.elements.grid.FilterBehavior = {
    properties: {

      _filters: {
        value: function() {
          return [];
        }
      }

    },

    listeners: {
      'filter-changed': '_filterChanged'
    },

    _filterChanged: function(e) {
      if (this._filters.indexOf(e.target) === -1) {
        this._filters.push(e.target);
      }

      e.stopPropagation();

      if (this.dataSource) {
        this.clearCache();
      }
    },

    _mapFilters: function() {
      return this._filters.map(function(filter) {
        return {
          path: filter.path,
          value: filter.value
        };
      });
    },
  };
</script>
<dom-module id="vaadin-grid" assetpath="../../../bower_components/vaadin-grid/">
  <style>
    :host {
      display: block;
      height: 400px;
      background: var(--primary-background-color, #fff);
      box-sizing: border-box;
      border: 1px solid var(--divider-color, rgba(0, 0, 0, 0.08));

      -webkit-tap-highlight-color: transparent;
    }

    :host(:focus),
    ::content #footerFocusTrap:focus {
      outline: none;
    }

    #scroller {
      height: 100%;
      width: 100%;
    }

  </style>
  <template>
    <vaadin-grid-table id="scroller" loading$="[[_loading]]" bind-data="[[_bindData]]" size="[[size]]" column-tree="[[_columnTree]]" content-target="[[_getContentTarget()]]" row-details-template="[[_rowDetailsTemplate]]">
      <content></content>
    </vaadin-grid-table>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'vaadin-grid',

    properties: {

      _columnTree: {
        type: Array,
        notify: true
      },


      /**
       * Estimated size of the grid data (number of items).
       * When using function data sources, it always needs to be set manually.
       */
      size: Number,

      _rowDetailsTemplate: Object,

      _bindData: {
        value: function() {
          return this._getItem.bind(this);
        }
      }
    },

    behaviors: [
      Polymer.IronA11yKeysBehavior,
      vaadin.elements.grid.ActiveItemBehavior,
      vaadin.elements.grid.RowDetailsBehavior,
      vaadin.elements.grid.DataSourceBehavior,
      vaadin.elements.grid.DynamicColumnsBehavior,
      vaadin.elements.grid.ArrayDataSourceBehavior,
      vaadin.elements.grid.SelectionBehavior,
      vaadin.elements.grid.SortBehavior,
      vaadin.elements.grid.FilterBehavior,
      vaadin.elements.grid.KeyboardNavigationBehavior,
      vaadin.elements.grid.ColumnReorderingBehavior
    ],

    listeners: {
      'property-changed': '_columnPropChanged'
    },

    _updateItem: function(row, item) {
      row.style.minHeight = item ? '' : this.$.scroller._physicalAverage + 'px';
      row.item = item;
      row.selected = this._isSelected(item);
      row.expanded = this._isExpanded(item);
      row.active = item !== null && item == this.activeItem;
      row.focused = row.index === this.$.scroller.$.items._focusedRowIndex;
    },

    _getContentTarget: function() {
      return this;
    },

    ready: function() {
      this._updateColumnTree();
      this._rowDetailsTemplate = Polymer.dom(this).querySelector('template.row-details') || undefined;
      this.$.scroller.target = this;
    },

    _columnPropChanged: function(e) {
      if (e.detail.path === '_childColumns') {
        this._updateColumnTree();
      }

      e.stopPropagation();
    }
  });
</script>
<!--
`iron-media-query` can be used to data bind to a CSS media query.
The `query` property is a bare CSS media query.
The `query-matches` property is a boolean representing whether the page matches that media query.

Example:

    <iron-media-query query="(min-width: 600px)" query-matches="{{queryMatches}}"></iron-media-query>

@group Iron Elements
@demo demo/index.html
@hero hero.svg
@element iron-media-query
-->

<script>

  Polymer({

    is: 'iron-media-query',

    properties: {

      /**
       * The Boolean return value of the media query.
       */
      queryMatches: {
        type: Boolean,
        value: false,
        readOnly: true,
        notify: true
      },

      /**
       * The CSS media query to evaluate.
       */
      query: {
        type: String,
        observer: 'queryChanged'
      },

      /**
       * If true, the query attribute is assumed to be a complete media query
       * string rather than a single media feature.
       */
      full: {
        type: Boolean,
        value: false
      },

      /**
       * @type {function(MediaQueryList)}
       */
      _boundMQHandler: {
        value: function() {
          return this.queryHandler.bind(this);
        }
      },

      /**
       * @type {MediaQueryList}
       */
      _mq: {
        value: null
      }
    },

    attached: function() {
      this.style.display = 'none';
      this.queryChanged();
    },

    detached: function() {
      this._remove();
    },

    _add: function() {
      if (this._mq) {
        this._mq.addListener(this._boundMQHandler);
      }
    },

    _remove: function() {
      if (this._mq) {
        this._mq.removeListener(this._boundMQHandler);
      }
      this._mq = null;
    },

    queryChanged: function() {
      this._remove();
      var query = this.query;
      if (!query) {
        return;
      }
      if (!this.full && query[0] !== '(') {
        query = '(' + query + ')';
      }
      this._mq = window.matchMedia(query);
      this._add();
      this.queryHandler(this._mq);
    },

    queryHandler: function(mq) {
      this._setQueryMatches(mq.matches);
    }

  });

</script><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
Material design: [Icon toggles](https://www.google.com/design/spec/components/buttons.html#buttons-toggle-buttons)

`paper-icon-button` is a button with an image placed at the center. When the user touches
the button, a ripple effect emanates from the center of the button.

`paper-icon-button` includes a default icon set.  Use `icon` to specify which icon
from the icon set to use.

    <paper-icon-button icon="menu"></paper-icon-button>

See [`iron-iconset`](iron-iconset) for more information about
how to use a custom icon set.

Example:

    <link href="path/to/iron-icons/iron-icons.html" rel="import">

    <paper-icon-button icon="favorite"></paper-icon-button>
    <paper-icon-button src="star.png"></paper-icon-button>

To use `paper-icon-button` as a link, wrap it in an anchor tag. Since `paper-icon-button`
will already receive focus, you may want to prevent the anchor tag from receiving focus
as well by setting its tabindex to -1.

    <a href="https://www.polymer-project.org" tabindex="-1">
      <paper-icon-button icon="polymer"></paper-icon-button>
    </a>

### Styling

Style the button with CSS as you would a normal DOM element. If you are using the icons
provided by `iron-icons`, they will inherit the foreground color of the button.

    /* make a red "favorite" button */
    <paper-icon-button icon="favorite" style="color: red;"></paper-icon-button>

By default, the ripple is the same color as the foreground at 25% opacity. You may
customize the color using the `--paper-icon-button-ink-color` custom property.

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-icon-button-disabled-text` | The color of the disabled button | `--disabled-text-color`
`--paper-icon-button-ink-color` | Selected/focus ripple color | `--primary-text-color`
`--paper-icon-button` | Mixin for a button | `{}`
`--paper-icon-button-disabled` | Mixin for a disabled button | `{}`
`--paper-icon-button-hover` | Mixin for button on hover | `{}`

@group Paper Elements
@element paper-icon-button
@demo demo/index.html
-->

<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>

  /**
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronControlState = {

    properties: {

      /**
       * If true, the element currently has focus.
       */
      focused: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },

      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        value: false,
        notify: true,
        observer: '_disabledChanged',
        reflectToAttribute: true
      },

      _oldTabIndex: {
        type: Number
      },

      _boundFocusBlurHandler: {
        type: Function,
        value: function() {
          return this._focusBlurHandler.bind(this);
        }
      }

    },

    observers: [
      '_changedControlState(focused, disabled)'
    ],

    ready: function() {
      this.addEventListener('focus', this._boundFocusBlurHandler, true);
      this.addEventListener('blur', this._boundFocusBlurHandler, true);
    },

    _focusBlurHandler: function(event) {
      // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
      // eventually become `this` due to retargeting; if we are not in
      // ShadowDOM land, `event.target` will eventually become `this` due
      // to the second conditional which fires a synthetic event (that is also
      // handled). In either case, we can disregard `event.path`.

      if (event.target === this) {
        this._setFocused(event.type === 'focus');
      } else if (!this.shadowRoot) {
        var target = /** @type {Node} */(Polymer.dom(event).localTarget);
        if (!this.isLightDescendant(target)) {
          this.fire(event.type, {sourceEvent: event}, {
            node: this,
            bubbles: event.bubbles,
            cancelable: event.cancelable
          });
        }
      }
    },

    _disabledChanged: function(disabled, old) {
      this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
      this.style.pointerEvents = disabled ? 'none' : '';
      if (disabled) {
        this._oldTabIndex = this.tabIndex;
        this._setFocused(false);
        this.tabIndex = -1;
        this.blur();
      } else if (this._oldTabIndex !== undefined) {
        this.tabIndex = this._oldTabIndex;
      }
    },

    _changedControlState: function() {
      // _controlStateChanged is abstract, follow-on behaviors may implement it
      if (this._controlStateChanged) {
        this._controlStateChanged();
      }
    }

  };

</script><script>

  /**
   * @demo demo/index.html
   * @polymerBehavior Polymer.IronButtonState
   */
  Polymer.IronButtonStateImpl = {

    properties: {

      /**
       * If true, the user is currently holding down the button.
       */
      pressed: {
        type: Boolean,
        readOnly: true,
        value: false,
        reflectToAttribute: true,
        observer: '_pressedChanged'
      },

      /**
       * If true, the button toggles the active state with each tap or press
       * of the spacebar.
       */
      toggles: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * If true, the button is a toggle and is currently in the active state.
       */
      active: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true
      },

      /**
       * True if the element is currently being pressed by a "pointer," which
       * is loosely defined as mouse or touch input (but specifically excluding
       * keyboard input).
       */
      pointerDown: {
        type: Boolean,
        readOnly: true,
        value: false
      },

      /**
       * True if the input device that caused the element to receive focus
       * was a keyboard.
       */
      receivedFocusFromKeyboard: {
        type: Boolean,
        readOnly: true
      },

      /**
       * The aria attribute to be set if the button is a toggle and in the
       * active state.
       */
      ariaActiveAttribute: {
        type: String,
        value: 'aria-pressed',
        observer: '_ariaActiveAttributeChanged'
      }
    },

    listeners: {
      down: '_downHandler',
      up: '_upHandler',
      tap: '_tapHandler'
    },

    observers: [
      '_detectKeyboardFocus(focused)',
      '_activeChanged(active, ariaActiveAttribute)'
    ],

    keyBindings: {
      'enter:keydown': '_asyncClick',
      'space:keydown': '_spaceKeyDownHandler',
      'space:keyup': '_spaceKeyUpHandler',
    },

    _mouseEventRe: /^mouse/,

    _tapHandler: function() {
      if (this.toggles) {
       // a tap is needed to toggle the active state
        this._userActivate(!this.active);
      } else {
        this.active = false;
      }
    },

    _detectKeyboardFocus: function(focused) {
      this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
    },

    // to emulate native checkbox, (de-)activations from a user interaction fire
    // 'change' events
    _userActivate: function(active) {
      if (this.active !== active) {
        this.active = active;
        this.fire('change');
      }
    },

    _downHandler: function(event) {
      this._setPointerDown(true);
      this._setPressed(true);
      this._setReceivedFocusFromKeyboard(false);
    },

    _upHandler: function() {
      this._setPointerDown(false);
      this._setPressed(false);
    },

    /**
     * @param {!KeyboardEvent} event .
     */
    _spaceKeyDownHandler: function(event) {
      var keyboardEvent = event.detail.keyboardEvent;
      var target = Polymer.dom(keyboardEvent).localTarget;

      // Ignore the event if this is coming from a focused light child, since that
      // element will deal with it.
      if (this.isLightDescendant(/** @type {Node} */(target)))
        return;

      keyboardEvent.preventDefault();
      keyboardEvent.stopImmediatePropagation();
      this._setPressed(true);
    },

    /**
     * @param {!KeyboardEvent} event .
     */
    _spaceKeyUpHandler: function(event) {
      var keyboardEvent = event.detail.keyboardEvent;
      var target = Polymer.dom(keyboardEvent).localTarget;

      // Ignore the event if this is coming from a focused light child, since that
      // element will deal with it.
      if (this.isLightDescendant(/** @type {Node} */(target)))
        return;

      if (this.pressed) {
        this._asyncClick();
      }
      this._setPressed(false);
    },

    // trigger click asynchronously, the asynchrony is useful to allow one
    // event handler to unwind before triggering another event
    _asyncClick: function() {
      this.async(function() {
        this.click();
      }, 1);
    },

    // any of these changes are considered a change to button state

    _pressedChanged: function(pressed) {
      this._changedButtonState();
    },

    _ariaActiveAttributeChanged: function(value, oldValue) {
      if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
        this.removeAttribute(oldValue);
      }
    },

    _activeChanged: function(active, ariaActiveAttribute) {
      if (this.toggles) {
        this.setAttribute(this.ariaActiveAttribute,
                          active ? 'true' : 'false');
      } else {
        this.removeAttribute(this.ariaActiveAttribute);
      }
      this._changedButtonState();
    },

    _controlStateChanged: function() {
      if (this.disabled) {
        this._setPressed(false);
      } else {
        this._changedButtonState();
      }
    },

    // provide hook for follow-on behaviors to react to button-state

    _changedButtonState: function() {
      if (this._buttonStateChanged) {
        this._buttonStateChanged(); // abstract
      }
    }

  };

  /** @polymerBehavior */
  Polymer.IronButtonState = [
    Polymer.IronA11yKeysBehavior,
    Polymer.IronButtonStateImpl
  ];

</script><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
Material design: [Surface reaction](https://www.google.com/design/spec/animation/responsive-interaction.html#responsive-interaction-surface-reaction)

`paper-ripple` provides a visual effect that other paper elements can
use to simulate a rippling effect emanating from the point of contact.  The
effect can be visualized as a concentric circle with motion.

Example:

    <div style="position:relative">
      <paper-ripple></paper-ripple>
    </div>

Note, it's important that the parent container of the ripple be relative position, otherwise
the ripple will emanate outside of the desired container.

`paper-ripple` listens to "mousedown" and "mouseup" events so it would display ripple
effect when touches on it.  You can also defeat the default behavior and
manually route the down and up actions to the ripple element.  Note that it is
important if you call `downAction()` you will have to make sure to call
`upAction()` so that `paper-ripple` would end the animation loop.

Example:

    <paper-ripple id="ripple" style="pointer-events: none;"></paper-ripple>
    ...
    downAction: function(e) {
      this.$.ripple.downAction({detail: {x: e.x, y: e.y}});
    },
    upAction: function(e) {
      this.$.ripple.upAction();
    }

Styling ripple effect:

  Use CSS color property to style the ripple:

    paper-ripple {
      color: #4285f4;
    }

  Note that CSS color property is inherited so it is not required to set it on
  the `paper-ripple` element directly.

By default, the ripple is centered on the point of contact.  Apply the `recenters`
attribute to have the ripple grow toward the center of its container.

    <paper-ripple recenters></paper-ripple>

You can also  center the ripple inside its container from the start.

    <paper-ripple center></paper-ripple>

Apply `circle` class to make the rippling effect within a circle.

    <paper-ripple class="circle"></paper-ripple>

@group Paper Elements
@element paper-ripple
@hero hero.svg
@demo demo/index.html
-->

<dom-module id="paper-ripple" assetpath="../../../bower_components/paper-ripple/">

  <template>
    <style>
      :host {
        display: block;
        position: absolute;
        border-radius: inherit;
        overflow: hidden;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;

        /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,
         * creating a node (with a position:absolute) in the middle of an event
         * handler "interrupts" that event handler (which happens when the
         * ripple is created on demand) */
        pointer-events: none;
      }

      :host([animating]) {
        /* This resolves a rendering issue in Chrome (as of 40) where the
           ripple is not properly clipped by its parent (which may have
           rounded corners). See: http://jsbin.com/temexa/4

           Note: We only apply this style conditionally. Otherwise, the browser
           will create a new compositing layer for every ripple element on the
           page, and that would be bad. */
        -webkit-transform: translate(0, 0);
        transform: translate3d(0, 0, 0);
      }

      #background,
      #waves,
      .wave-container,
      .wave {
        pointer-events: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      #background,
      .wave {
        opacity: 0;
      }

      #waves,
      .wave {
        overflow: hidden;
      }

      .wave-container,
      .wave {
        border-radius: 50%;
      }

      :host(.circle) #background,
      :host(.circle) #waves {
        border-radius: 50%;
      }

      :host(.circle) .wave-container {
        overflow: hidden;
      }
    </style>

    <div id="background"></div>
    <div id="waves"></div>
  </template>
</dom-module>
<script>
  (function() {
    var Utility = {
      distance: function(x1, y1, x2, y2) {
        var xDelta = (x1 - x2);
        var yDelta = (y1 - y2);

        return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
      },

      now: window.performance && window.performance.now ?
          window.performance.now.bind(window.performance) : Date.now
    };

    /**
     * @param {HTMLElement} element
     * @constructor
     */
    function ElementMetrics(element) {
      this.element = element;
      this.width = this.boundingRect.width;
      this.height = this.boundingRect.height;

      this.size = Math.max(this.width, this.height);
    }

    ElementMetrics.prototype = {
      get boundingRect () {
        return this.element.getBoundingClientRect();
      },

      furthestCornerDistanceFrom: function(x, y) {
        var topLeft = Utility.distance(x, y, 0, 0);
        var topRight = Utility.distance(x, y, this.width, 0);
        var bottomLeft = Utility.distance(x, y, 0, this.height);
        var bottomRight = Utility.distance(x, y, this.width, this.height);

        return Math.max(topLeft, topRight, bottomLeft, bottomRight);
      }
    };

    /**
     * @param {HTMLElement} element
     * @constructor
     */
    function Ripple(element) {
      this.element = element;
      this.color = window.getComputedStyle(element).color;

      this.wave = document.createElement('div');
      this.waveContainer = document.createElement('div');
      this.wave.style.backgroundColor = this.color;
      this.wave.classList.add('wave');
      this.waveContainer.classList.add('wave-container');
      Polymer.dom(this.waveContainer).appendChild(this.wave);

      this.resetInteractionState();
    }

    Ripple.MAX_RADIUS = 300;

    Ripple.prototype = {
      get recenters() {
        return this.element.recenters;
      },

      get center() {
        return this.element.center;
      },

      get mouseDownElapsed() {
        var elapsed;

        if (!this.mouseDownStart) {
          return 0;
        }

        elapsed = Utility.now() - this.mouseDownStart;

        if (this.mouseUpStart) {
          elapsed -= this.mouseUpElapsed;
        }

        return elapsed;
      },

      get mouseUpElapsed() {
        return this.mouseUpStart ?
          Utility.now () - this.mouseUpStart : 0;
      },

      get mouseDownElapsedSeconds() {
        return this.mouseDownElapsed / 1000;
      },

      get mouseUpElapsedSeconds() {
        return this.mouseUpElapsed / 1000;
      },

      get mouseInteractionSeconds() {
        return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
      },

      get initialOpacity() {
        return this.element.initialOpacity;
      },

      get opacityDecayVelocity() {
        return this.element.opacityDecayVelocity;
      },

      get radius() {
        var width2 = this.containerMetrics.width * this.containerMetrics.width;
        var height2 = this.containerMetrics.height * this.containerMetrics.height;
        var waveRadius = Math.min(
          Math.sqrt(width2 + height2),
          Ripple.MAX_RADIUS
        ) * 1.1 + 5;

        var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
        var timeNow = this.mouseInteractionSeconds / duration;
        var size = waveRadius * (1 - Math.pow(80, -timeNow));

        return Math.abs(size);
      },

      get opacity() {
        if (!this.mouseUpStart) {
          return this.initialOpacity;
        }

        return Math.max(
          0,
          this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity
        );
      },

      get outerOpacity() {
        // Linear increase in background opacity, capped at the opacity
        // of the wavefront (waveOpacity).
        var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
        var waveOpacity = this.opacity;

        return Math.max(
          0,
          Math.min(outerOpacity, waveOpacity)
        );
      },

      get isOpacityFullyDecayed() {
        return this.opacity < 0.01 &&
          this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
      },

      get isRestingAtMaxRadius() {
        return this.opacity >= this.initialOpacity &&
          this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
      },

      get isAnimationComplete() {
        return this.mouseUpStart ?
          this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
      },

      get translationFraction() {
        return Math.min(
          1,
          this.radius / this.containerMetrics.size * 2 / Math.sqrt(2)
        );
      },

      get xNow() {
        if (this.xEnd) {
          return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
        }

        return this.xStart;
      },

      get yNow() {
        if (this.yEnd) {
          return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
        }

        return this.yStart;
      },

      get isMouseDown() {
        return this.mouseDownStart && !this.mouseUpStart;
      },

      resetInteractionState: function() {
        this.maxRadius = 0;
        this.mouseDownStart = 0;
        this.mouseUpStart = 0;

        this.xStart = 0;
        this.yStart = 0;
        this.xEnd = 0;
        this.yEnd = 0;
        this.slideDistance = 0;

        this.containerMetrics = new ElementMetrics(this.element);
      },

      draw: function() {
        var scale;
        var translateString;
        var dx;
        var dy;

        this.wave.style.opacity = this.opacity;

        scale = this.radius / (this.containerMetrics.size / 2);
        dx = this.xNow - (this.containerMetrics.width / 2);
        dy = this.yNow - (this.containerMetrics.height / 2);


        // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
        // https://bugs.webkit.org/show_bug.cgi?id=98538
        this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
        this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
        this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
        this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
      },

      /** @param {Event=} event */
      downAction: function(event) {
        var xCenter = this.containerMetrics.width / 2;
        var yCenter = this.containerMetrics.height / 2;

        this.resetInteractionState();
        this.mouseDownStart = Utility.now();

        if (this.center) {
          this.xStart = xCenter;
          this.yStart = yCenter;
          this.slideDistance = Utility.distance(
            this.xStart, this.yStart, this.xEnd, this.yEnd
          );
        } else {
          this.xStart = event ?
              event.detail.x - this.containerMetrics.boundingRect.left :
              this.containerMetrics.width / 2;
          this.yStart = event ?
              event.detail.y - this.containerMetrics.boundingRect.top :
              this.containerMetrics.height / 2;
        }

        if (this.recenters) {
          this.xEnd = xCenter;
          this.yEnd = yCenter;
          this.slideDistance = Utility.distance(
            this.xStart, this.yStart, this.xEnd, this.yEnd
          );
        }

        this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(
          this.xStart,
          this.yStart
        );

        this.waveContainer.style.top =
          (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
        this.waveContainer.style.left =
          (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

        this.waveContainer.style.width = this.containerMetrics.size + 'px';
        this.waveContainer.style.height = this.containerMetrics.size + 'px';
      },

      /** @param {Event=} event */
      upAction: function(event) {
        if (!this.isMouseDown) {
          return;
        }

        this.mouseUpStart = Utility.now();
      },

      remove: function() {
        Polymer.dom(this.waveContainer.parentNode).removeChild(
          this.waveContainer
        );
      }
    };

    Polymer({
      is: 'paper-ripple',

      behaviors: [
        Polymer.IronA11yKeysBehavior
      ],

      properties: {
        /**
         * The initial opacity set on the wave.
         *
         * @attribute initialOpacity
         * @type number
         * @default 0.25
         */
        initialOpacity: {
          type: Number,
          value: 0.25
        },

        /**
         * How fast (opacity per second) the wave fades out.
         *
         * @attribute opacityDecayVelocity
         * @type number
         * @default 0.8
         */
        opacityDecayVelocity: {
          type: Number,
          value: 0.8
        },

        /**
         * If true, ripples will exhibit a gravitational pull towards
         * the center of their container as they fade away.
         *
         * @attribute recenters
         * @type boolean
         * @default false
         */
        recenters: {
          type: Boolean,
          value: false
        },

        /**
         * If true, ripples will center inside its container
         *
         * @attribute recenters
         * @type boolean
         * @default false
         */
        center: {
          type: Boolean,
          value: false
        },

        /**
         * A list of the visual ripples.
         *
         * @attribute ripples
         * @type Array
         * @default []
         */
        ripples: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /**
         * True when there are visible ripples animating within the
         * element.
         */
        animating: {
          type: Boolean,
          readOnly: true,
          reflectToAttribute: true,
          value: false
        },

        /**
         * If true, the ripple will remain in the "down" state until `holdDown`
         * is set to false again.
         */
        holdDown: {
          type: Boolean,
          value: false,
          observer: '_holdDownChanged'
        },

        /**
         * If true, the ripple will not generate a ripple effect
         * via pointer interaction.
         * Calling ripple's imperative api like `simulatedRipple` will
         * still generate the ripple effect.
         */
        noink: {
          type: Boolean,
          value: false
        },

        _animating: {
          type: Boolean
        },

        _boundAnimate: {
          type: Function,
          value: function() {
            return this.animate.bind(this);
          }
        }
      },

      get target () {
        return this.keyEventTarget;
      },

      keyBindings: {
        'enter:keydown': '_onEnterKeydown',
        'space:keydown': '_onSpaceKeydown',
        'space:keyup': '_onSpaceKeyup'
      },

      attached: function() {
        // Set up a11yKeysBehavior to listen to key events on the target,
        // so that space and enter activate the ripple even if the target doesn't
        // handle key events. The key handlers deal with `noink` themselves.
        if (this.parentNode.nodeType == 11) { // DOCUMENT_FRAGMENT_NODE
          this.keyEventTarget = Polymer.dom(this).getOwnerRoot().host;
        } else {
          this.keyEventTarget = this.parentNode;
        }
        var keyEventTarget = /** @type {!EventTarget} */ (this.keyEventTarget);
        this.listen(keyEventTarget, 'up', 'uiUpAction');
        this.listen(keyEventTarget, 'down', 'uiDownAction');
      },

      detached: function() {
        this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
        this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
        this.keyEventTarget = null;
      },

      get shouldKeepAnimating () {
        for (var index = 0; index < this.ripples.length; ++index) {
          if (!this.ripples[index].isAnimationComplete) {
            return true;
          }
        }

        return false;
      },

      simulatedRipple: function() {
        this.downAction(null);

        // Please see polymer/polymer#1305
        this.async(function() {
          this.upAction();
        }, 1);
      },

      /**
       * Provokes a ripple down effect via a UI event,
       * respecting the `noink` property.
       * @param {Event=} event
       */
      uiDownAction: function(event) {
        if (!this.noink) {
          this.downAction(event);
        }
      },

      /**
       * Provokes a ripple down effect via a UI event,
       * *not* respecting the `noink` property.
       * @param {Event=} event
       */
      downAction: function(event) {
        if (this.holdDown && this.ripples.length > 0) {
          return;
        }

        var ripple = this.addRipple();

        ripple.downAction(event);

        if (!this._animating) {
          this._animating = true;
          this.animate();
        }
      },

      /**
       * Provokes a ripple up effect via a UI event,
       * respecting the `noink` property.
       * @param {Event=} event
       */
      uiUpAction: function(event) {
        if (!this.noink) {
          this.upAction(event);
        }
      },

      /**
       * Provokes a ripple up effect via a UI event,
       * *not* respecting the `noink` property.
       * @param {Event=} event
       */
      upAction: function(event) {
        if (this.holdDown) {
          return;
        }

        this.ripples.forEach(function(ripple) {
          ripple.upAction(event);
        });

        this._animating = true;
        this.animate();
      },

      onAnimationComplete: function() {
        this._animating = false;
        this.$.background.style.backgroundColor = null;
        this.fire('transitionend');
      },

      addRipple: function() {
        var ripple = new Ripple(this);

        Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
        this.$.background.style.backgroundColor = ripple.color;
        this.ripples.push(ripple);

        this._setAnimating(true);

        return ripple;
      },

      removeRipple: function(ripple) {
        var rippleIndex = this.ripples.indexOf(ripple);

        if (rippleIndex < 0) {
          return;
        }

        this.ripples.splice(rippleIndex, 1);

        ripple.remove();

        if (!this.ripples.length) {
          this._setAnimating(false);
        }
      },

      /**
       * This conflicts with Element#antimate().
       * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
       * @suppress {checkTypes}
       */
      animate: function() {
        if (!this._animating) {
          return;
        }
        var index;
        var ripple;

        for (index = 0; index < this.ripples.length; ++index) {
          ripple = this.ripples[index];

          ripple.draw();

          this.$.background.style.opacity = ripple.outerOpacity;

          if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
            this.removeRipple(ripple);
          }
        }

        if (!this.shouldKeepAnimating && this.ripples.length === 0) {
          this.onAnimationComplete();
        } else {
          window.requestAnimationFrame(this._boundAnimate);
        }
      },

      _onEnterKeydown: function() {
        this.uiDownAction();
        this.async(this.uiUpAction, 1);
      },

      _onSpaceKeydown: function() {
        this.uiDownAction();
      },

      _onSpaceKeyup: function() {
        this.uiUpAction();
      },

      // note: holdDown does not respect noink since it can be a focus based
      // effect.
      _holdDownChanged: function(newVal, oldVal) {
        if (oldVal === undefined) {
          return;
        }
        if (newVal) {
          this.downAction();
        } else {
          this.upAction();
        }
      }

      /**
      Fired when the animation finishes.
      This is useful if you want to wait until
      the ripple animation finishes to perform some action.

      @event transitionend
      @param {{node: Object}} detail Contains the animated node.
      */
    });
  })();
</script>
<script>
  /**
   * `Polymer.PaperRippleBehavior` dynamically implements a ripple
   * when the element has focus via pointer or keyboard.
   *
   * NOTE: This behavior is intended to be used in conjunction with and after
   * `Polymer.IronButtonState` and `Polymer.IronControlState`.
   *
   * @polymerBehavior Polymer.PaperRippleBehavior
   */
  Polymer.PaperRippleBehavior = {
    properties: {
      /**
       * If true, the element will not produce a ripple effect when interacted
       * with via the pointer.
       */
      noink: {
        type: Boolean,
        observer: '_noinkChanged'
      },

      /**
       * @type {Element|undefined}
       */
      _rippleContainer: {
        type: Object,
      }
    },

    /**
     * Ensures a `<paper-ripple>` element is available when the element is
     * focused.
     */
    _buttonStateChanged: function() {
      if (this.focused) {
        this.ensureRipple();
      }
    },

    /**
     * In addition to the functionality provided in `IronButtonState`, ensures
     * a ripple effect is created when the element is in a `pressed` state.
     */
    _downHandler: function(event) {
      Polymer.IronButtonStateImpl._downHandler.call(this, event);
      if (this.pressed) {
        this.ensureRipple(event);
      }
    },

    /**
     * Ensures this element contains a ripple effect. For startup efficiency
     * the ripple effect is dynamically on demand when needed.
     * @param {!Event=} optTriggeringEvent (optional) event that triggered the
     * ripple.
     */
    ensureRipple: function(optTriggeringEvent) {
      if (!this.hasRipple()) {
        this._ripple = this._createRipple();
        this._ripple.noink = this.noink;
        var rippleContainer = this._rippleContainer || this.root;
        if (rippleContainer) {
          Polymer.dom(rippleContainer).appendChild(this._ripple);
        }
        if (optTriggeringEvent) {
          // Check if the event happened inside of the ripple container
          // Fall back to host instead of the root because distributed text
          // nodes are not valid event targets
          var domContainer = Polymer.dom(this._rippleContainer || this);
          var target = Polymer.dom(optTriggeringEvent).rootTarget;
          if (domContainer.deepContains( /** @type {Node} */(target))) {
            this._ripple.uiDownAction(optTriggeringEvent);
          }
        }
      }
    },

    /**
     * Returns the `<paper-ripple>` element used by this element to create
     * ripple effects. The element's ripple is created on demand, when
     * necessary, and calling this method will force the
     * ripple to be created.
     */
    getRipple: function() {
      this.ensureRipple();
      return this._ripple;
    },

    /**
     * Returns true if this element currently contains a ripple effect.
     * @return {boolean}
     */
    hasRipple: function() {
      return Boolean(this._ripple);
    },

    /**
     * Create the element's ripple effect via creating a `<paper-ripple>`.
     * Override this method to customize the ripple element.
     * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
     */
    _createRipple: function() {
      return /** @type {!PaperRippleElement} */ (
          document.createElement('paper-ripple'));
    },

    _noinkChanged: function(noink) {
      if (this.hasRipple()) {
        this._ripple.noink = noink;
      }
    }
  };
</script><script>
  /**
   * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
   *
   * @polymerBehavior Polymer.PaperInkyFocusBehavior
   */
  Polymer.PaperInkyFocusBehaviorImpl = {
    observers: [
      '_focusedChanged(receivedFocusFromKeyboard)'
    ],

    _focusedChanged: function(receivedFocusFromKeyboard) {
      if (receivedFocusFromKeyboard) {
        this.ensureRipple();
      }
      if (this.hasRipple()) {
        this._ripple.holdDown = receivedFocusFromKeyboard;
      }
    },

    _createRipple: function() {
      var ripple = Polymer.PaperRippleBehavior._createRipple();
      ripple.id = 'ink';
      ripple.setAttribute('center', '');
      ripple.classList.add('circle');
      return ripple;
    }
  };

  /** @polymerBehavior Polymer.PaperInkyFocusBehavior */
  Polymer.PaperInkyFocusBehavior = [
    Polymer.IronButtonState,
    Polymer.IronControlState,
    Polymer.PaperRippleBehavior,
    Polymer.PaperInkyFocusBehaviorImpl
  ];
</script><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!-- Taken from https://www.google.com/design/spec/style/color.html#color-ui-color-application -->

<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><style is="custom-style">

  :root {

    /* Material Design color palette for Google products */

    --google-red-100: #f4c7c3;
    --google-red-300: #e67c73;
    --google-red-500: #db4437;
    --google-red-700: #c53929;

    --google-blue-100: #c6dafc;
    --google-blue-300: #7baaf7;
    --google-blue-500: #4285f4;
    --google-blue-700: #3367d6;

    --google-green-100: #b7e1cd;
    --google-green-300: #57bb8a;
    --google-green-500: #0f9d58;
    --google-green-700: #0b8043;

    --google-yellow-100: #fce8b2;
    --google-yellow-300: #f7cb4d;
    --google-yellow-500: #f4b400;
    --google-yellow-700: #f09300;

    --google-grey-100: #f5f5f5;
    --google-grey-300: #e0e0e0;
    --google-grey-500: #9e9e9e;
    --google-grey-700: #616161;
    
    /* Material Design color palette from online spec document */

    --paper-red-50: #ffebee;
    --paper-red-100: #ffcdd2;
    --paper-red-200: #ef9a9a;
    --paper-red-300: #e57373;
    --paper-red-400: #ef5350;
    --paper-red-500: #f44336;
    --paper-red-600: #e53935;
    --paper-red-700: #d32f2f;
    --paper-red-800: #c62828;
    --paper-red-900: #b71c1c;
    --paper-red-a100: #ff8a80;
    --paper-red-a200: #ff5252;
    --paper-red-a400: #ff1744;
    --paper-red-a700: #d50000;
 
    --paper-pink-50: #fce4ec;
    --paper-pink-100: #f8bbd0;
    --paper-pink-200: #f48fb1;
    --paper-pink-300: #f06292;
    --paper-pink-400: #ec407a;
    --paper-pink-500: #e91e63;
    --paper-pink-600: #d81b60;
    --paper-pink-700: #c2185b;
    --paper-pink-800: #ad1457;
    --paper-pink-900: #880e4f;
    --paper-pink-a100: #ff80ab;
    --paper-pink-a200: #ff4081;
    --paper-pink-a400: #f50057;
    --paper-pink-a700: #c51162;
 
    --paper-purple-50: #f3e5f5;
    --paper-purple-100: #e1bee7;
    --paper-purple-200: #ce93d8;
    --paper-purple-300: #ba68c8;
    --paper-purple-400: #ab47bc;
    --paper-purple-500: #9c27b0;
    --paper-purple-600: #8e24aa;
    --paper-purple-700: #7b1fa2;
    --paper-purple-800: #6a1b9a;
    --paper-purple-900: #4a148c;
    --paper-purple-a100: #ea80fc;
    --paper-purple-a200: #e040fb;
    --paper-purple-a400: #d500f9;
    --paper-purple-a700: #aa00ff;
 
    --paper-deep-purple-50: #ede7f6;
    --paper-deep-purple-100: #d1c4e9;
    --paper-deep-purple-200: #b39ddb;
    --paper-deep-purple-300: #9575cd;
    --paper-deep-purple-400: #7e57c2;
    --paper-deep-purple-500: #673ab7;
    --paper-deep-purple-600: #5e35b1;
    --paper-deep-purple-700: #512da8;
    --paper-deep-purple-800: #4527a0;
    --paper-deep-purple-900: #311b92;
    --paper-deep-purple-a100: #b388ff;
    --paper-deep-purple-a200: #7c4dff;
    --paper-deep-purple-a400: #651fff;
    --paper-deep-purple-a700: #6200ea;
 
    --paper-indigo-50: #e8eaf6;
    --paper-indigo-100: #c5cae9;
    --paper-indigo-200: #9fa8da;
    --paper-indigo-300: #7986cb;
    --paper-indigo-400: #5c6bc0;
    --paper-indigo-500: #3f51b5;
    --paper-indigo-600: #3949ab;
    --paper-indigo-700: #303f9f;
    --paper-indigo-800: #283593;
    --paper-indigo-900: #1a237e;
    --paper-indigo-a100: #8c9eff;
    --paper-indigo-a200: #536dfe;
    --paper-indigo-a400: #3d5afe;
    --paper-indigo-a700: #304ffe;
 
    --paper-blue-50: #e3f2fd;
    --paper-blue-100: #bbdefb;
    --paper-blue-200: #90caf9;
    --paper-blue-300: #64b5f6;
    --paper-blue-400: #42a5f5;
    --paper-blue-500: #2196f3;
    --paper-blue-600: #1e88e5;
    --paper-blue-700: #1976d2;
    --paper-blue-800: #1565c0;
    --paper-blue-900: #0d47a1;
    --paper-blue-a100: #82b1ff;
    --paper-blue-a200: #448aff;
    --paper-blue-a400: #2979ff;
    --paper-blue-a700: #2962ff;
 
    --paper-light-blue-50: #e1f5fe;
    --paper-light-blue-100: #b3e5fc;
    --paper-light-blue-200: #81d4fa;
    --paper-light-blue-300: #4fc3f7;
    --paper-light-blue-400: #29b6f6;
    --paper-light-blue-500: #03a9f4;
    --paper-light-blue-600: #039be5;
    --paper-light-blue-700: #0288d1;
    --paper-light-blue-800: #0277bd;
    --paper-light-blue-900: #01579b;
    --paper-light-blue-a100: #80d8ff;
    --paper-light-blue-a200: #40c4ff;
    --paper-light-blue-a400: #00b0ff;
    --paper-light-blue-a700: #0091ea;
 
    --paper-cyan-50: #e0f7fa;
    --paper-cyan-100: #b2ebf2;
    --paper-cyan-200: #80deea;
    --paper-cyan-300: #4dd0e1;
    --paper-cyan-400: #26c6da;
    --paper-cyan-500: #00bcd4;
    --paper-cyan-600: #00acc1;
    --paper-cyan-700: #0097a7;
    --paper-cyan-800: #00838f;
    --paper-cyan-900: #006064;
    --paper-cyan-a100: #84ffff;
    --paper-cyan-a200: #18ffff;
    --paper-cyan-a400: #00e5ff;
    --paper-cyan-a700: #00b8d4;
 
    --paper-teal-50: #e0f2f1;
    --paper-teal-100: #b2dfdb;
    --paper-teal-200: #80cbc4;
    --paper-teal-300: #4db6ac;
    --paper-teal-400: #26a69a;
    --paper-teal-500: #009688;
    --paper-teal-600: #00897b;
    --paper-teal-700: #00796b;
    --paper-teal-800: #00695c;
    --paper-teal-900: #004d40;
    --paper-teal-a100: #a7ffeb;
    --paper-teal-a200: #64ffda;
    --paper-teal-a400: #1de9b6;
    --paper-teal-a700: #00bfa5;
 
    --paper-green-50: #e8f5e9;
    --paper-green-100: #c8e6c9;
    --paper-green-200: #a5d6a7;
    --paper-green-300: #81c784;
    --paper-green-400: #66bb6a;
    --paper-green-500: #4caf50;
    --paper-green-600: #43a047;
    --paper-green-700: #388e3c;
    --paper-green-800: #2e7d32;
    --paper-green-900: #1b5e20;
    --paper-green-a100: #b9f6ca;
    --paper-green-a200: #69f0ae;
    --paper-green-a400: #00e676;
    --paper-green-a700: #00c853;
 
    --paper-light-green-50: #f1f8e9;
    --paper-light-green-100: #dcedc8;
    --paper-light-green-200: #c5e1a5;
    --paper-light-green-300: #aed581;
    --paper-light-green-400: #9ccc65;
    --paper-light-green-500: #8bc34a;
    --paper-light-green-600: #7cb342;
    --paper-light-green-700: #689f38;
    --paper-light-green-800: #558b2f;
    --paper-light-green-900: #33691e;
    --paper-light-green-a100: #ccff90;
    --paper-light-green-a200: #b2ff59;
    --paper-light-green-a400: #76ff03;
    --paper-light-green-a700: #64dd17;
 
    --paper-lime-50: #f9fbe7;
    --paper-lime-100: #f0f4c3;
    --paper-lime-200: #e6ee9c;
    --paper-lime-300: #dce775;
    --paper-lime-400: #d4e157;
    --paper-lime-500: #cddc39;
    --paper-lime-600: #c0ca33;
    --paper-lime-700: #afb42b;
    --paper-lime-800: #9e9d24;
    --paper-lime-900: #827717;
    --paper-lime-a100: #f4ff81;
    --paper-lime-a200: #eeff41;
    --paper-lime-a400: #c6ff00;
    --paper-lime-a700: #aeea00;
 
    --paper-yellow-50: #fffde7;
    --paper-yellow-100: #fff9c4;
    --paper-yellow-200: #fff59d;
    --paper-yellow-300: #fff176;
    --paper-yellow-400: #ffee58;
    --paper-yellow-500: #ffeb3b;
    --paper-yellow-600: #fdd835;
    --paper-yellow-700: #fbc02d;
    --paper-yellow-800: #f9a825;
    --paper-yellow-900: #f57f17;
    --paper-yellow-a100: #ffff8d;
    --paper-yellow-a200: #ffff00;
    --paper-yellow-a400: #ffea00;
    --paper-yellow-a700: #ffd600;
 
    --paper-amber-50: #fff8e1;
    --paper-amber-100: #ffecb3;
    --paper-amber-200: #ffe082;
    --paper-amber-300: #ffd54f;
    --paper-amber-400: #ffca28;
    --paper-amber-500: #ffc107;
    --paper-amber-600: #ffb300;
    --paper-amber-700: #ffa000;
    --paper-amber-800: #ff8f00;
    --paper-amber-900: #ff6f00;
    --paper-amber-a100: #ffe57f;
    --paper-amber-a200: #ffd740;
    --paper-amber-a400: #ffc400;
    --paper-amber-a700: #ffab00;
 
    --paper-orange-50: #fff3e0;
    --paper-orange-100: #ffe0b2;
    --paper-orange-200: #ffcc80;
    --paper-orange-300: #ffb74d;
    --paper-orange-400: #ffa726;
    --paper-orange-500: #ff9800;
    --paper-orange-600: #fb8c00;
    --paper-orange-700: #f57c00;
    --paper-orange-800: #ef6c00;
    --paper-orange-900: #e65100;
    --paper-orange-a100: #ffd180;
    --paper-orange-a200: #ffab40;
    --paper-orange-a400: #ff9100;
    --paper-orange-a700: #ff6500;
 
    --paper-deep-orange-50: #fbe9e7;
    --paper-deep-orange-100: #ffccbc;
    --paper-deep-orange-200: #ffab91;
    --paper-deep-orange-300: #ff8a65;
    --paper-deep-orange-400: #ff7043;
    --paper-deep-orange-500: #ff5722;
    --paper-deep-orange-600: #f4511e;
    --paper-deep-orange-700: #e64a19;
    --paper-deep-orange-800: #d84315;
    --paper-deep-orange-900: #bf360c;
    --paper-deep-orange-a100: #ff9e80;
    --paper-deep-orange-a200: #ff6e40;
    --paper-deep-orange-a400: #ff3d00;
    --paper-deep-orange-a700: #dd2c00;
 
    --paper-brown-50: #efebe9;
    --paper-brown-100: #d7ccc8;
    --paper-brown-200: #bcaaa4;
    --paper-brown-300: #a1887f;
    --paper-brown-400: #8d6e63;
    --paper-brown-500: #795548;
    --paper-brown-600: #6d4c41;
    --paper-brown-700: #5d4037;
    --paper-brown-800: #4e342e;
    --paper-brown-900: #3e2723;
 
    --paper-grey-50: #fafafa;
    --paper-grey-100: #f5f5f5;
    --paper-grey-200: #eeeeee;
    --paper-grey-300: #e0e0e0;
    --paper-grey-400: #bdbdbd;
    --paper-grey-500: #9e9e9e;
    --paper-grey-600: #757575;
    --paper-grey-700: #616161;
    --paper-grey-800: #424242;
    --paper-grey-900: #212121;
 
    --paper-blue-grey-50: #eceff1;
    --paper-blue-grey-100: #cfd8dc;
    --paper-blue-grey-200: #b0bec5;
    --paper-blue-grey-300: #90a4ae;
    --paper-blue-grey-400: #78909c;
    --paper-blue-grey-500: #607d8b;
    --paper-blue-grey-600: #546e7a;
    --paper-blue-grey-700: #455a64;
    --paper-blue-grey-800: #37474f;
    --paper-blue-grey-900: #263238;

    /* opacity for dark text on a light background */
    --dark-divider-opacity: 0.12;
    --dark-disabled-opacity: 0.38; /* or hint text or icon */
    --dark-secondary-opacity: 0.54;
    --dark-primary-opacity: 0.87;

    /* opacity for light text on a dark background */
    --light-divider-opacity: 0.12;
    --light-disabled-opacity: 0.3; /* or hint text or icon */
    --light-secondary-opacity: 0.7;
    --light-primary-opacity: 1.0;

  }

</style><style is="custom-style">

  :root {
    /*
     * You can use these generic variables in your elements for easy theming.
     * For example, if all your elements use `--primary-text-color` as its main
     * color, then switching from a light to a dark theme is just a matter of
     * changing the value of `--primary-text-color` in your application.
     */
    --primary-text-color: var(--light-theme-text-color);
    --primary-background-color: var(--light-theme-background-color);
    --secondary-text-color: var(--light-theme-secondary-color);
    --disabled-text-color: var(--light-theme-disabled-color);
    --divider-color: var(--light-theme-divider-color);
    --error-color: var(--paper-deep-orange-a700);

    /*
     * Primary and accent colors. Also see color.html for more colors.
     */
    --primary-color: var(--paper-indigo-500);
    --light-primary-color: var(--paper-indigo-100);
    --dark-primary-color: var(--paper-indigo-700);

    --accent-color: var(--paper-pink-a200);
    --light-accent-color: var(--paper-pink-a100);
    --dark-accent-color: var(--paper-pink-a400);


    /*
     * Material Design Light background theme
     */
    --light-theme-background-color: #ffffff;
    --light-theme-base-color: #000000;
    --light-theme-text-color: var(--paper-grey-900);
    --light-theme-secondary-color: #737373;  /* for secondary text and icons */
    --light-theme-disabled-color: #9b9b9b;  /* disabled/hint text */
    --light-theme-divider-color: #dbdbdb;

    /*
     * Material Design Dark background theme
     */
    --dark-theme-background-color: var(--paper-grey-900);
    --dark-theme-base-color: #ffffff;
    --dark-theme-text-color: #ffffff;
    --dark-theme-secondary-color: #bcbcbc;  /* for secondary text and icons */
    --dark-theme-disabled-color: #646464;  /* disabled/hint text */
    --dark-theme-divider-color: #3c3c3c;

    /*
     * Deprecated values because of their confusing names.
     */
    --text-primary-color: var(--dark-theme-text-color);
    --default-primary-color: var(--primary-color);

  }

</style><dom-module id="paper-icon-button" assetpath="../../../bower_components/paper-icon-button/">
  <template strip-whitespace="">
    <style>
      :host {
        display: inline-block;
        position: relative;
        padding: 8px;
        outline: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        cursor: pointer;
        z-index: 0;
        line-height: 1;

        width: 40px;
        height: 40px;

        /* NOTE: Both values are needed, since some phones require the value to be `transparent`. */
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        -webkit-tap-highlight-color: transparent;

        /* Because of polymer/2558, this style has lower specificity than * */
        box-sizing: border-box !important;

        @apply(--paper-icon-button);
      }

      :host #ink {
        color: var(--paper-icon-button-ink-color, --primary-text-color);
        opacity: 0.6;
      }

      :host([disabled]) {
        color: var(--paper-icon-button-disabled-text, --disabled-text-color);
        pointer-events: none;
        cursor: auto;

        @apply(--paper-icon-button-disabled);
      }

      :host(:hover) {
        @apply(--paper-icon-button-hover);
      }

      iron-icon {
        --iron-icon-width: 100%;
        --iron-icon-height: 100%;
      }
    </style>

    <iron-icon id="icon" src="[[src]]" icon="[[icon]]" alt$="[[alt]]"></iron-icon>
  </template>

  <script>
    Polymer({
      is: 'paper-icon-button',

      hostAttributes: {
        role: 'button',
        tabindex: '0'
      },

      behaviors: [
        Polymer.PaperInkyFocusBehavior
      ],

      properties: {
        /**
         * The URL of an image for the icon. If the src property is specified,
         * the icon property should not be.
         */
        src: {
          type: String
        },

        /**
         * Specifies the icon name or index in the set of icons available in
         * the icon's icon set. If the icon property is specified,
         * the src property should not be.
         */
        icon: {
          type: String
        },

        /**
         * Specifies the alternate text for the button, for accessibility.
         */
        alt: {
          type: String,
          observer: "_altChanged"
        }
      },

      _altChanged: function(newValue, oldValue) {
        var label = this.getAttribute('aria-label');

        // Don't stomp over a user-set aria-label.
        if (!label || oldValue == label) {
          this.setAttribute('aria-label', newValue);
        }
      }
    });
  </script>
</dom-module>
<script>!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.moment=t()}(this,function(){"use strict";function e(){return _s.apply(null,arguments)}function t(e){_s=e}function n(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function s(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function i(e){var t;for(t in e)return!1;return!0}function r(e){return"number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function a(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function o(e,t){var n,s=[];for(n=0;n<e.length;++n)s.push(t(e[n],n));return s}function u(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function l(e,t){for(var n in t)u(t,n)&&(e[n]=t[n]);return u(t,"toString")&&(e.toString=t.toString),u(t,"valueOf")&&(e.valueOf=t.valueOf),e}function d(e,t,n,s){return gt(e,t,n,s,!0).utc()}function h(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null}}function c(e){return null==e._pf&&(e._pf=h()),e._pf}function f(e){if(null==e._isValid){var t=c(e),n=gs.call(t.parsedDateParts,function(e){return null!=e}),s=!isNaN(e._d.getTime())&&t.overflow<0&&!t.empty&&!t.invalidMonth&&!t.invalidWeekday&&!t.nullInput&&!t.invalidFormat&&!t.userInvalidated&&(!t.meridiem||t.meridiem&&n);if(e._strict&&(s=s&&0===t.charsLeftOver&&0===t.unusedTokens.length&&void 0===t.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return s;e._isValid=s}return e._isValid}function m(e){var t=d(NaN);return null!=e?l(c(t),e):c(t).userInvalidated=!0,t}function _(e){return void 0===e}function y(e,t){var n,s,i;if(_(t._isAMomentObject)||(e._isAMomentObject=t._isAMomentObject),_(t._i)||(e._i=t._i),_(t._f)||(e._f=t._f),_(t._l)||(e._l=t._l),_(t._strict)||(e._strict=t._strict),_(t._tzm)||(e._tzm=t._tzm),_(t._isUTC)||(e._isUTC=t._isUTC),_(t._offset)||(e._offset=t._offset),_(t._pf)||(e._pf=c(t)),_(t._locale)||(e._locale=t._locale),ps.length>0)for(n in ps)s=ps[n],i=t[s],_(i)||(e[s]=i);return e}function g(t){y(this,t),this._d=new Date(null!=t._d?t._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),ws===!1&&(ws=!0,e.updateOffset(this),ws=!1)}function p(e){return e instanceof g||null!=e&&null!=e._isAMomentObject}function w(e){return e<0?Math.ceil(e)||0:Math.floor(e)}function v(e){var t=+e,n=0;return 0!==t&&isFinite(t)&&(n=w(t)),n}function S(e,t,n){var s,i=Math.min(e.length,t.length),r=Math.abs(e.length-t.length),a=0;for(s=0;s<i;s++)(n&&e[s]!==t[s]||!n&&v(e[s])!==v(t[s]))&&a++;return a+r}function M(t){e.suppressDeprecationWarnings===!1&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+t)}function k(t,n){var s=!0;return l(function(){if(null!=e.deprecationHandler&&e.deprecationHandler(null,t),s){for(var i,r=[],a=0;a<arguments.length;a++){if(i="","object"==typeof arguments[a]){i+="\n["+a+"] ";for(var o in arguments[0])i+=o+": "+arguments[0][o]+", ";i=i.slice(0,-2)}else i=arguments[a];r.push(i)}M(t+"\nArguments: "+Array.prototype.slice.call(r).join("")+"\n"+(new Error).stack),s=!1}return n.apply(this,arguments)},n)}function D(t,n){null!=e.deprecationHandler&&e.deprecationHandler(t,n),vs[t]||(M(n),vs[t]=!0)}function Y(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function O(e){var t,n;for(n in e)t=e[n],Y(t)?this[n]=t:this["_"+n]=t;this._config=e,this._ordinalParseLenient=new RegExp(this._ordinalParse.source+"|"+/\d{1,2}/.source)}function x(e,t){var n,i=l({},e);for(n in t)u(t,n)&&(s(e[n])&&s(t[n])?(i[n]={},l(i[n],e[n]),l(i[n],t[n])):null!=t[n]?i[n]=t[n]:delete i[n]);for(n in e)u(e,n)&&!u(t,n)&&s(e[n])&&(i[n]=l({},i[n]));return i}function T(e){null!=e&&this.set(e)}function b(e,t,n){var s=this._calendar[e]||this._calendar.sameElse;return Y(s)?s.call(t,n):s}function P(e){var t=this._longDateFormat[e],n=this._longDateFormat[e.toUpperCase()];return t||!n?t:(this._longDateFormat[e]=n.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e])}function W(){return this._invalidDate}function R(e){return this._ordinal.replace("%d",e)}function U(e,t,n,s){var i=this._relativeTime[n];return Y(i)?i(e,t,n,s):i.replace(/%d/i,e)}function C(e,t){var n=this._relativeTime[e>0?"future":"past"];return Y(n)?n(t):n.replace(/%s/i,t)}function F(e,t){var n=e.toLowerCase();Ps[n]=Ps[n+"s"]=Ps[t]=e}function H(e){return"string"==typeof e?Ps[e]||Ps[e.toLowerCase()]:void 0}function L(e){var t,n,s={};for(n in e)u(e,n)&&(t=H(n),t&&(s[t]=e[n]));return s}function G(e,t){Ws[e]=t}function V(e){var t=[];for(var n in e)t.push({unit:n,priority:Ws[n]});return t.sort(function(e,t){return e.priority-t.priority}),t}function j(t,n){return function(s){return null!=s?(A(this,t,s),e.updateOffset(this,n),this):N(this,t)}}function N(e,t){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+t]():NaN}function A(e,t,n){e.isValid()&&e._d["set"+(e._isUTC?"UTC":"")+t](n)}function E(e){return e=H(e),Y(this[e])?this[e]():this}function I(e,t){if("object"==typeof e){e=L(e);for(var n=V(e),s=0;s<n.length;s++)this[n[s].unit](e[n[s].unit])}else if(e=H(e),Y(this[e]))return this[e](t);return this}function z(e,t,n){var s=""+Math.abs(e),i=t-s.length,r=e>=0;return(r?n?"+":"":"-")+Math.pow(10,Math.max(0,i)).toString().substr(1)+s}function Z(e,t,n,s){var i=s;"string"==typeof s&&(i=function(){return this[s]()}),e&&(Fs[e]=i),t&&(Fs[t[0]]=function(){return z(i.apply(this,arguments),t[1],t[2])}),n&&(Fs[n]=function(){return this.localeData().ordinal(i.apply(this,arguments),e)})}function $(e){return e.match(/\[[\s\S]/)?e.replace(/^\[|\]$/g,""):e.replace(/\\/g,"")}function q(e){var t,n,s=e.match(Rs);for(t=0,n=s.length;t<n;t++)Fs[s[t]]?s[t]=Fs[s[t]]:s[t]=$(s[t]);return function(t){var i,r="";for(i=0;i<n;i++)r+=s[i]instanceof Function?s[i].call(t,e):s[i];return r}}function B(e,t){return e.isValid()?(t=J(t,e.localeData()),Cs[t]=Cs[t]||q(t),Cs[t](e)):e.localeData().invalidDate()}function J(e,t){function n(e){return t.longDateFormat(e)||e}var s=5;for(Us.lastIndex=0;s>=0&&Us.test(e);)e=e.replace(Us,n),Us.lastIndex=0,s-=1;return e}function Q(e,t,n){Ks[e]=Y(t)?t:function(e,s){return e&&n?n:t}}function X(e,t){return u(Ks,e)?Ks[e](t._strict,t._locale):new RegExp(K(e))}function K(e){return ee(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,t,n,s,i){return t||n||s||i}))}function ee(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function te(e,t){var n,s=t;for("string"==typeof e&&(e=[e]),r(t)&&(s=function(e,n){n[t]=v(e)}),n=0;n<e.length;n++)ei[e[n]]=s}function ne(e,t){te(e,function(e,n,s,i){s._w=s._w||{},t(e,s._w,s,i)})}function se(e,t,n){null!=t&&u(ei,e)&&ei[e](t,n._a,n,e)}function ie(e,t){return new Date(Date.UTC(e,t+1,0)).getUTCDate()}function re(e,t){return e?n(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||hi).test(t)?"format":"standalone"][e.month()]:this._months}function ae(e,t){return e?n(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[hi.test(t)?"format":"standalone"][e.month()]:this._monthsShort}function oe(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],s=0;s<12;++s)r=d([2e3,s]),this._shortMonthsParse[s]=this.monthsShort(r,"").toLocaleLowerCase(),this._longMonthsParse[s]=this.months(r,"").toLocaleLowerCase();return n?"MMM"===t?(i=di.call(this._shortMonthsParse,a),i!==-1?i:null):(i=di.call(this._longMonthsParse,a),i!==-1?i:null):"MMM"===t?(i=di.call(this._shortMonthsParse,a),i!==-1?i:(i=di.call(this._longMonthsParse,a),i!==-1?i:null)):(i=di.call(this._longMonthsParse,a),i!==-1?i:(i=di.call(this._shortMonthsParse,a),i!==-1?i:null))}function ue(e,t,n){var s,i,r;if(this._monthsParseExact)return oe.call(this,e,t,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),s=0;s<12;s++){if(i=d([2e3,s]),n&&!this._longMonthsParse[s]&&(this._longMonthsParse[s]=new RegExp("^"+this.months(i,"").replace(".","")+"$","i"),this._shortMonthsParse[s]=new RegExp("^"+this.monthsShort(i,"").replace(".","")+"$","i")),n||this._monthsParse[s]||(r="^"+this.months(i,"")+"|^"+this.monthsShort(i,""),this._monthsParse[s]=new RegExp(r.replace(".",""),"i")),n&&"MMMM"===t&&this._longMonthsParse[s].test(e))return s;if(n&&"MMM"===t&&this._shortMonthsParse[s].test(e))return s;if(!n&&this._monthsParse[s].test(e))return s}}function le(e,t){var n;if(!e.isValid())return e;if("string"==typeof t)if(/^\d+$/.test(t))t=v(t);else if(t=e.localeData().monthsParse(t),!r(t))return e;return n=Math.min(e.date(),ie(e.year(),t)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](t,n),e}function de(t){return null!=t?(le(this,t),e.updateOffset(this,!0),this):N(this,"Month")}function he(){return ie(this.year(),this.month())}function ce(e){return this._monthsParseExact?(u(this,"_monthsRegex")||me.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(u(this,"_monthsShortRegex")||(this._monthsShortRegex=mi),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)}function fe(e){return this._monthsParseExact?(u(this,"_monthsRegex")||me.call(this),e?this._monthsStrictRegex:this._monthsRegex):(u(this,"_monthsRegex")||(this._monthsRegex=_i),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)}function me(){function e(e,t){return t.length-e.length}var t,n,s=[],i=[],r=[];for(t=0;t<12;t++)n=d([2e3,t]),s.push(this.monthsShort(n,"")),i.push(this.months(n,"")),r.push(this.months(n,"")),r.push(this.monthsShort(n,""));for(s.sort(e),i.sort(e),r.sort(e),t=0;t<12;t++)s[t]=ee(s[t]),i[t]=ee(i[t]);for(t=0;t<24;t++)r[t]=ee(r[t]);this._monthsRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+s.join("|")+")","i")}function _e(e){return ye(e)?366:365}function ye(e){return e%4===0&&e%100!==0||e%400===0}function ge(){return ye(this.year())}function pe(e,t,n,s,i,r,a){var o=new Date(e,t,n,s,i,r,a);return e<100&&e>=0&&isFinite(o.getFullYear())&&o.setFullYear(e),o}function we(e){var t=new Date(Date.UTC.apply(null,arguments));return e<100&&e>=0&&isFinite(t.getUTCFullYear())&&t.setUTCFullYear(e),t}function ve(e,t,n){var s=7+t-n,i=(7+we(e,0,s).getUTCDay()-t)%7;return-i+s-1}function Se(e,t,n,s,i){var r,a,o=(7+n-s)%7,u=ve(e,s,i),l=1+7*(t-1)+o+u;return l<=0?(r=e-1,a=_e(r)+l):l>_e(e)?(r=e+1,a=l-_e(e)):(r=e,a=l),{year:r,dayOfYear:a}}function Me(e,t,n){var s,i,r=ve(e.year(),t,n),a=Math.floor((e.dayOfYear()-r-1)/7)+1;return a<1?(i=e.year()-1,s=a+ke(i,t,n)):a>ke(e.year(),t,n)?(s=a-ke(e.year(),t,n),i=e.year()+1):(i=e.year(),s=a),{week:s,year:i}}function ke(e,t,n){var s=ve(e,t,n),i=ve(e+1,t,n);return(_e(e)-s+i)/7}function De(e){return Me(e,this._week.dow,this._week.doy).week}function Ye(){return this._week.dow}function Oe(){return this._week.doy}function xe(e){var t=this.localeData().week(this);return null==e?t:this.add(7*(e-t),"d")}function Te(e){var t=Me(this,1,4).week;return null==e?t:this.add(7*(e-t),"d")}function be(e,t){return"string"!=typeof e?e:isNaN(e)?(e=t.weekdaysParse(e),"number"==typeof e?e:null):parseInt(e,10)}function Pe(e,t){return"string"==typeof e?t.weekdaysParse(e)%7||7:isNaN(e)?null:e}function We(e,t){return e?n(this._weekdays)?this._weekdays[e.day()]:this._weekdays[this._weekdays.isFormat.test(t)?"format":"standalone"][e.day()]:this._weekdays}function Re(e){return e?this._weekdaysShort[e.day()]:this._weekdaysShort}function Ue(e){return e?this._weekdaysMin[e.day()]:this._weekdaysMin}function Ce(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],s=0;s<7;++s)r=d([2e3,1]).day(s),this._minWeekdaysParse[s]=this.weekdaysMin(r,"").toLocaleLowerCase(),this._shortWeekdaysParse[s]=this.weekdaysShort(r,"").toLocaleLowerCase(),this._weekdaysParse[s]=this.weekdays(r,"").toLocaleLowerCase();return n?"dddd"===t?(i=di.call(this._weekdaysParse,a),i!==-1?i:null):"ddd"===t?(i=di.call(this._shortWeekdaysParse,a),i!==-1?i:null):(i=di.call(this._minWeekdaysParse,a),i!==-1?i:null):"dddd"===t?(i=di.call(this._weekdaysParse,a),i!==-1?i:(i=di.call(this._shortWeekdaysParse,a),i!==-1?i:(i=di.call(this._minWeekdaysParse,a),i!==-1?i:null))):"ddd"===t?(i=di.call(this._shortWeekdaysParse,a),i!==-1?i:(i=di.call(this._weekdaysParse,a),i!==-1?i:(i=di.call(this._minWeekdaysParse,a),i!==-1?i:null))):(i=di.call(this._minWeekdaysParse,a),i!==-1?i:(i=di.call(this._weekdaysParse,a),i!==-1?i:(i=di.call(this._shortWeekdaysParse,a),i!==-1?i:null)))}function Fe(e,t,n){var s,i,r;if(this._weekdaysParseExact)return Ce.call(this,e,t,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),s=0;s<7;s++){if(i=d([2e3,1]).day(s),n&&!this._fullWeekdaysParse[s]&&(this._fullWeekdaysParse[s]=new RegExp("^"+this.weekdays(i,"").replace(".",".?")+"$","i"),this._shortWeekdaysParse[s]=new RegExp("^"+this.weekdaysShort(i,"").replace(".",".?")+"$","i"),this._minWeekdaysParse[s]=new RegExp("^"+this.weekdaysMin(i,"").replace(".",".?")+"$","i")),this._weekdaysParse[s]||(r="^"+this.weekdays(i,"")+"|^"+this.weekdaysShort(i,"")+"|^"+this.weekdaysMin(i,""),this._weekdaysParse[s]=new RegExp(r.replace(".",""),"i")),n&&"dddd"===t&&this._fullWeekdaysParse[s].test(e))return s;if(n&&"ddd"===t&&this._shortWeekdaysParse[s].test(e))return s;if(n&&"dd"===t&&this._minWeekdaysParse[s].test(e))return s;if(!n&&this._weekdaysParse[s].test(e))return s}}function He(e){if(!this.isValid())return null!=e?this:NaN;var t=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(e=be(e,this.localeData()),this.add(e-t,"d")):t}function Le(e){if(!this.isValid())return null!=e?this:NaN;var t=(this.day()+7-this.localeData()._week.dow)%7;return null==e?t:this.add(e-t,"d")}function Ge(e){if(!this.isValid())return null!=e?this:NaN;if(null!=e){var t=Pe(e,this.localeData());return this.day(this.day()%7?t:t-7)}return this.day()||7}function Ve(e){return this._weekdaysParseExact?(u(this,"_weekdaysRegex")||Ae.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(u(this,"_weekdaysRegex")||(this._weekdaysRegex=Si),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)}function je(e){return this._weekdaysParseExact?(u(this,"_weekdaysRegex")||Ae.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(u(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Mi),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)}function Ne(e){return this._weekdaysParseExact?(u(this,"_weekdaysRegex")||Ae.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(u(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=ki),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)}function Ae(){function e(e,t){return t.length-e.length}var t,n,s,i,r,a=[],o=[],u=[],l=[];for(t=0;t<7;t++)n=d([2e3,1]).day(t),s=this.weekdaysMin(n,""),i=this.weekdaysShort(n,""),r=this.weekdays(n,""),a.push(s),o.push(i),u.push(r),l.push(s),l.push(i),l.push(r);for(a.sort(e),o.sort(e),u.sort(e),l.sort(e),t=0;t<7;t++)o[t]=ee(o[t]),u[t]=ee(u[t]),l[t]=ee(l[t]);this._weekdaysRegex=new RegExp("^("+l.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+o.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+a.join("|")+")","i")}function Ee(){return this.hours()%12||12}function Ie(){return this.hours()||24}function ze(e,t){Z(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),t)})}function Ze(e,t){return t._meridiemParse}function $e(e){return"p"===(e+"").toLowerCase().charAt(0)}function qe(e,t,n){return e>11?n?"pm":"PM":n?"am":"AM"}function Be(e){return e?e.toLowerCase().replace("_","-"):e}function Je(e){for(var t,n,s,i,r=0;r<e.length;){for(i=Be(e[r]).split("-"),t=i.length,n=Be(e[r+1]),n=n?n.split("-"):null;t>0;){if(s=Qe(i.slice(0,t).join("-")))return s;if(n&&n.length>=t&&S(i,n,!0)>=t-1)break;t--}r++}return null}function Qe(e){var t=null;if(!Ti[e]&&"undefined"!=typeof module&&module&&module.exports)try{t=Di._abbr,require("./locale/"+e),Xe(t)}catch(e){}return Ti[e]}function Xe(e,t){var n;return e&&(n=_(t)?tt(e):Ke(e,t),n&&(Di=n)),Di._abbr}function Ke(e,t){if(null!==t){var n=xi;if(t.abbr=e,null!=Ti[e])D("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),n=Ti[e]._config;else if(null!=t.parentLocale){if(null==Ti[t.parentLocale])return bi[t.parentLocale]||(bi[t.parentLocale]=[]),bi[t.parentLocale].push({name:e,config:t}),null;n=Ti[t.parentLocale]._config}return Ti[e]=new T(x(n,t)),bi[e]&&bi[e].forEach(function(e){Ke(e.name,e.config)}),Xe(e),Ti[e]}return delete Ti[e],null}function et(e,t){if(null!=t){var n,s=xi;null!=Ti[e]&&(s=Ti[e]._config),t=x(s,t),n=new T(t),n.parentLocale=Ti[e],Ti[e]=n,Xe(e)}else null!=Ti[e]&&(null!=Ti[e].parentLocale?Ti[e]=Ti[e].parentLocale:null!=Ti[e]&&delete Ti[e]);return Ti[e]}function tt(e){var t;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return Di;if(!n(e)){if(t=Qe(e))return t;e=[e]}return Je(e)}function nt(){return ks(Ti)}function st(e){var t,n=e._a;return n&&c(e).overflow===-2&&(t=n[ni]<0||n[ni]>11?ni:n[si]<1||n[si]>ie(n[ti],n[ni])?si:n[ii]<0||n[ii]>24||24===n[ii]&&(0!==n[ri]||0!==n[ai]||0!==n[oi])?ii:n[ri]<0||n[ri]>59?ri:n[ai]<0||n[ai]>59?ai:n[oi]<0||n[oi]>999?oi:-1,c(e)._overflowDayOfYear&&(t<ti||t>si)&&(t=si),c(e)._overflowWeeks&&t===-1&&(t=ui),c(e)._overflowWeekday&&t===-1&&(t=li),c(e).overflow=t),e}function it(e){var t,n,s,i,r,a,o=e._i,u=Pi.exec(o)||Wi.exec(o);if(u){for(c(e).iso=!0,t=0,n=Ui.length;t<n;t++)if(Ui[t][1].exec(u[1])){i=Ui[t][0],s=Ui[t][2]!==!1;break}if(null==i)return void(e._isValid=!1);if(u[3]){for(t=0,n=Ci.length;t<n;t++)if(Ci[t][1].exec(u[3])){r=(u[2]||" ")+Ci[t][0];break}if(null==r)return void(e._isValid=!1)}if(!s&&null!=r)return void(e._isValid=!1);if(u[4]){if(!Ri.exec(u[4]))return void(e._isValid=!1);a="Z"}e._f=i+(r||"")+(a||""),dt(e)}else e._isValid=!1}function rt(t){var n=Fi.exec(t._i);return null!==n?void(t._d=new Date((+n[1]))):(it(t),void(t._isValid===!1&&(delete t._isValid,e.createFromInputFallback(t))))}function at(e,t,n){return null!=e?e:null!=t?t:n}function ot(t){var n=new Date(e.now());return t._useUTC?[n.getUTCFullYear(),n.getUTCMonth(),n.getUTCDate()]:[n.getFullYear(),n.getMonth(),n.getDate()]}function ut(e){var t,n,s,i,r=[];if(!e._d){for(s=ot(e),e._w&&null==e._a[si]&&null==e._a[ni]&&lt(e),e._dayOfYear&&(i=at(e._a[ti],s[ti]),e._dayOfYear>_e(i)&&(c(e)._overflowDayOfYear=!0),n=we(i,0,e._dayOfYear),e._a[ni]=n.getUTCMonth(),e._a[si]=n.getUTCDate()),t=0;t<3&&null==e._a[t];++t)e._a[t]=r[t]=s[t];for(;t<7;t++)e._a[t]=r[t]=null==e._a[t]?2===t?1:0:e._a[t];24===e._a[ii]&&0===e._a[ri]&&0===e._a[ai]&&0===e._a[oi]&&(e._nextDay=!0,e._a[ii]=0),e._d=(e._useUTC?we:pe).apply(null,r),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[ii]=24)}}function lt(e){var t,n,s,i,r,a,o,u;if(t=e._w,null!=t.GG||null!=t.W||null!=t.E)r=1,a=4,n=at(t.GG,e._a[ti],Me(pt(),1,4).year),s=at(t.W,1),i=at(t.E,1),(i<1||i>7)&&(u=!0);else{r=e._locale._week.dow,a=e._locale._week.doy;var l=Me(pt(),r,a);n=at(t.gg,e._a[ti],l.year),s=at(t.w,l.week),null!=t.d?(i=t.d,(i<0||i>6)&&(u=!0)):null!=t.e?(i=t.e+r,(t.e<0||t.e>6)&&(u=!0)):i=r}s<1||s>ke(n,r,a)?c(e)._overflowWeeks=!0:null!=u?c(e)._overflowWeekday=!0:(o=Se(n,s,i,r,a),e._a[ti]=o.year,e._dayOfYear=o.dayOfYear)}function dt(t){if(t._f===e.ISO_8601)return void it(t);t._a=[],c(t).empty=!0;var n,s,i,r,a,o=""+t._i,u=o.length,l=0;for(i=J(t._f,t._locale).match(Rs)||[],n=0;n<i.length;n++)r=i[n],s=(o.match(X(r,t))||[])[0],s&&(a=o.substr(0,o.indexOf(s)),a.length>0&&c(t).unusedInput.push(a),o=o.slice(o.indexOf(s)+s.length),l+=s.length),Fs[r]?(s?c(t).empty=!1:c(t).unusedTokens.push(r),se(r,s,t)):t._strict&&!s&&c(t).unusedTokens.push(r);c(t).charsLeftOver=u-l,o.length>0&&c(t).unusedInput.push(o),t._a[ii]<=12&&c(t).bigHour===!0&&t._a[ii]>0&&(c(t).bigHour=void 0),c(t).parsedDateParts=t._a.slice(0),c(t).meridiem=t._meridiem,t._a[ii]=ht(t._locale,t._a[ii],t._meridiem),ut(t),st(t)}function ht(e,t,n){var s;return null==n?t:null!=e.meridiemHour?e.meridiemHour(t,n):null!=e.isPM?(s=e.isPM(n),s&&t<12&&(t+=12),s||12!==t||(t=0),t):t}function ct(e){var t,n,s,i,r;if(0===e._f.length)return c(e).invalidFormat=!0,void(e._d=new Date(NaN));for(i=0;i<e._f.length;i++)r=0,t=y({},e),null!=e._useUTC&&(t._useUTC=e._useUTC),t._f=e._f[i],dt(t),f(t)&&(r+=c(t).charsLeftOver,r+=10*c(t).unusedTokens.length,c(t).score=r,(null==s||r<s)&&(s=r,n=t));l(e,n||t)}function ft(e){if(!e._d){var t=L(e._i);e._a=o([t.year,t.month,t.day||t.date,t.hour,t.minute,t.second,t.millisecond],function(e){return e&&parseInt(e,10)}),ut(e)}}function mt(e){var t=new g(st(_t(e)));return t._nextDay&&(t.add(1,"d"),t._nextDay=void 0),t}function _t(e){var t=e._i,s=e._f;return e._locale=e._locale||tt(e._l),null===t||void 0===s&&""===t?m({nullInput:!0}):("string"==typeof t&&(e._i=t=e._locale.preparse(t)),p(t)?new g(st(t)):(a(t)?e._d=t:n(s)?ct(e):s?dt(e):yt(e),f(e)||(e._d=null),e))}function yt(t){var s=t._i;void 0===s?t._d=new Date(e.now()):a(s)?t._d=new Date(s.valueOf()):"string"==typeof s?rt(t):n(s)?(t._a=o(s.slice(0),function(e){return parseInt(e,10)}),ut(t)):"object"==typeof s?ft(t):r(s)?t._d=new Date(s):e.createFromInputFallback(t)}function gt(e,t,r,a,o){var u={};return r!==!0&&r!==!1||(a=r,r=void 0),(s(e)&&i(e)||n(e)&&0===e.length)&&(e=void 0),u._isAMomentObject=!0,u._useUTC=u._isUTC=o,u._l=r,u._i=e,u._f=t,u._strict=a,mt(u)}function pt(e,t,n,s){return gt(e,t,n,s,!1)}function wt(e,t){var s,i;if(1===t.length&&n(t[0])&&(t=t[0]),!t.length)return pt();for(s=t[0],i=1;i<t.length;++i)t[i].isValid()&&!t[i][e](s)||(s=t[i]);return s}function vt(){var e=[].slice.call(arguments,0);return wt("isBefore",e)}function St(){var e=[].slice.call(arguments,0);return wt("isAfter",e)}function Mt(e){var t=L(e),n=t.year||0,s=t.quarter||0,i=t.month||0,r=t.week||0,a=t.day||0,o=t.hour||0,u=t.minute||0,l=t.second||0,d=t.millisecond||0;this._milliseconds=+d+1e3*l+6e4*u+1e3*o*60*60,this._days=+a+7*r,this._months=+i+3*s+12*n,this._data={},this._locale=tt(),this._bubble()}function kt(e){return e instanceof Mt}function Dt(e){return e<0?Math.round(-1*e)*-1:Math.round(e)}function Yt(e,t){Z(e,0,0,function(){var e=this.utcOffset(),n="+";return e<0&&(e=-e,n="-"),n+z(~~(e/60),2)+t+z(~~e%60,2)})}function Ot(e,t){var n=(t||"").match(e);if(null===n)return null;var s=n[n.length-1]||[],i=(s+"").match(Vi)||["-",0,0],r=+(60*i[1])+v(i[2]);return 0===r?0:"+"===i[0]?r:-r}function xt(t,n){var s,i;return n._isUTC?(s=n.clone(),i=(p(t)||a(t)?t.valueOf():pt(t).valueOf())-s.valueOf(),s._d.setTime(s._d.valueOf()+i),e.updateOffset(s,!1),s):pt(t).local()}function Tt(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function bt(t,n){var s,i=this._offset||0;if(!this.isValid())return null!=t?this:NaN;if(null!=t){if("string"==typeof t){if(t=Ot(Js,t),null===t)return this}else Math.abs(t)<16&&(t=60*t);return!this._isUTC&&n&&(s=Tt(this)),this._offset=t,this._isUTC=!0,null!=s&&this.add(s,"m"),i!==t&&(!n||this._changeInProgress?zt(this,jt(t-i,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,e.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?i:Tt(this)}function Pt(e,t){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,t),this):-this.utcOffset()}function Wt(e){return this.utcOffset(0,e)}function Rt(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Tt(this),"m")),this}function Ut(){if(null!=this._tzm)this.utcOffset(this._tzm);else if("string"==typeof this._i){var e=Ot(Bs,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0)}return this}function Ct(e){return!!this.isValid()&&(e=e?pt(e).utcOffset():0,(this.utcOffset()-e)%60===0)}function Ft(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()}function Ht(){if(!_(this._isDSTShifted))return this._isDSTShifted;var e={};if(y(e,this),e=_t(e),e._a){var t=e._isUTC?d(e._a):pt(e._a);this._isDSTShifted=this.isValid()&&S(e._a,t.toArray())>0}else this._isDSTShifted=!1;return this._isDSTShifted}function Lt(){return!!this.isValid()&&!this._isUTC}function Gt(){return!!this.isValid()&&this._isUTC}function Vt(){return!!this.isValid()&&this._isUTC&&0===this._offset}function jt(e,t){var n,s,i,a=e,o=null;return kt(e)?a={ms:e._milliseconds,d:e._days,M:e._months}:r(e)?(a={},t?a[t]=e:a.milliseconds=e):(o=ji.exec(e))?(n="-"===o[1]?-1:1,a={y:0,d:v(o[si])*n,h:v(o[ii])*n,m:v(o[ri])*n,s:v(o[ai])*n,ms:v(Dt(1e3*o[oi]))*n}):(o=Ni.exec(e))?(n="-"===o[1]?-1:1,a={y:Nt(o[2],n),M:Nt(o[3],n),w:Nt(o[4],n),d:Nt(o[5],n),h:Nt(o[6],n),m:Nt(o[7],n),s:Nt(o[8],n)}):null==a?a={}:"object"==typeof a&&("from"in a||"to"in a)&&(i=Et(pt(a.from),pt(a.to)),a={},a.ms=i.milliseconds,a.M=i.months),s=new Mt(a),kt(e)&&u(e,"_locale")&&(s._locale=e._locale),s}function Nt(e,t){var n=e&&parseFloat(e.replace(",","."));return(isNaN(n)?0:n)*t}function At(e,t){var n={milliseconds:0,months:0};return n.months=t.month()-e.month()+12*(t.year()-e.year()),e.clone().add(n.months,"M").isAfter(t)&&--n.months,n.milliseconds=+t-+e.clone().add(n.months,"M"),n}function Et(e,t){var n;return e.isValid()&&t.isValid()?(t=xt(t,e),e.isBefore(t)?n=At(e,t):(n=At(t,e),n.milliseconds=-n.milliseconds,n.months=-n.months),n):{milliseconds:0,months:0}}function It(e,t){return function(n,s){var i,r;return null===s||isNaN(+s)||(D(t,"moment()."+t+"(period, number) is deprecated. Please use moment()."+t+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),r=n,n=s,s=r),n="string"==typeof n?+n:n,i=jt(n,s),zt(this,i,e),this}}function zt(t,n,s,i){var r=n._milliseconds,a=Dt(n._days),o=Dt(n._months);t.isValid()&&(i=null==i||i,r&&t._d.setTime(t._d.valueOf()+r*s),a&&A(t,"Date",N(t,"Date")+a*s),o&&le(t,N(t,"Month")+o*s),i&&e.updateOffset(t,a||o))}function Zt(e,t){var n=e.diff(t,"days",!0);return n<-6?"sameElse":n<-1?"lastWeek":n<0?"lastDay":n<1?"sameDay":n<2?"nextDay":n<7?"nextWeek":"sameElse"}function $t(t,n){var s=t||pt(),i=xt(s,this).startOf("day"),r=e.calendarFormat(this,i)||"sameElse",a=n&&(Y(n[r])?n[r].call(this,s):n[r]);return this.format(a||this.localeData().calendar(r,this,pt(s)))}function qt(){return new g(this)}function Bt(e,t){var n=p(e)?e:pt(e);return!(!this.isValid()||!n.isValid())&&(t=H(_(t)?"millisecond":t),"millisecond"===t?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(t).valueOf())}function Jt(e,t){var n=p(e)?e:pt(e);return!(!this.isValid()||!n.isValid())&&(t=H(_(t)?"millisecond":t),"millisecond"===t?this.valueOf()<n.valueOf():this.clone().endOf(t).valueOf()<n.valueOf())}function Qt(e,t,n,s){return s=s||"()",("("===s[0]?this.isAfter(e,n):!this.isBefore(e,n))&&(")"===s[1]?this.isBefore(t,n):!this.isAfter(t,n))}function Xt(e,t){var n,s=p(e)?e:pt(e);return!(!this.isValid()||!s.isValid())&&(t=H(t||"millisecond"),"millisecond"===t?this.valueOf()===s.valueOf():(n=s.valueOf(),this.clone().startOf(t).valueOf()<=n&&n<=this.clone().endOf(t).valueOf()))}function Kt(e,t){return this.isSame(e,t)||this.isAfter(e,t)}function en(e,t){return this.isSame(e,t)||this.isBefore(e,t)}function tn(e,t,n){var s,i,r,a;return this.isValid()?(s=xt(e,this),s.isValid()?(i=6e4*(s.utcOffset()-this.utcOffset()),t=H(t),"year"===t||"month"===t||"quarter"===t?(a=nn(this,s),"quarter"===t?a/=3:"year"===t&&(a/=12)):(r=this-s,a="second"===t?r/1e3:"minute"===t?r/6e4:"hour"===t?r/36e5:"day"===t?(r-i)/864e5:"week"===t?(r-i)/6048e5:r),n?a:w(a)):NaN):NaN}function nn(e,t){var n,s,i=12*(t.year()-e.year())+(t.month()-e.month()),r=e.clone().add(i,"months");return t-r<0?(n=e.clone().add(i-1,"months"),s=(t-r)/(r-n)):(n=e.clone().add(i+1,"months"),s=(t-r)/(n-r)),-(i+s)||0}function sn(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")}function rn(){var e=this.clone().utc();return 0<e.year()&&e.year()<=9999?Y(Date.prototype.toISOString)?this.toDate().toISOString():B(e,"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"):B(e,"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")}function an(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var e="moment",t="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",t="Z");var n="["+e+'("]',s=0<this.year()&&this.year()<=9999?"YYYY":"YYYYYY",i="-MM-DD[T]HH:mm:ss.SSS",r=t+'[")]';return this.format(n+s+i+r)}function on(t){t||(t=this.isUtc()?e.defaultFormatUtc:e.defaultFormat);var n=B(this,t);return this.localeData().postformat(n)}function un(e,t){return this.isValid()&&(p(e)&&e.isValid()||pt(e).isValid())?jt({to:this,from:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()}function ln(e){return this.from(pt(),e)}function dn(e,t){return this.isValid()&&(p(e)&&e.isValid()||pt(e).isValid())?jt({from:this,to:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()}function hn(e){return this.to(pt(),e)}function cn(e){var t;return void 0===e?this._locale._abbr:(t=tt(e),null!=t&&(this._locale=t),this)}function fn(){return this._locale}function mn(e){switch(e=H(e)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":case"date":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===e&&this.weekday(0),"isoWeek"===e&&this.isoWeekday(1),"quarter"===e&&this.month(3*Math.floor(this.month()/3)),this}function _n(e){return e=H(e),void 0===e||"millisecond"===e?this:("date"===e&&(e="day"),this.startOf(e).add(1,"isoWeek"===e?"week":e).subtract(1,"ms"))}function yn(){return this._d.valueOf()-6e4*(this._offset||0)}function gn(){return Math.floor(this.valueOf()/1e3)}function pn(){return new Date(this.valueOf())}function wn(){var e=this;return[e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]}function vn(){var e=this;return{years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}}function Sn(){return this.isValid()?this.toISOString():null}function Mn(){return f(this)}function kn(){return l({},c(this))}function Dn(){return c(this).overflow}function Yn(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}}function On(e,t){Z(0,[e,e.length],0,t)}function xn(e){return Wn.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)}function Tn(e){return Wn.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)}function bn(){return ke(this.year(),1,4)}function Pn(){var e=this.localeData()._week;return ke(this.year(),e.dow,e.doy)}function Wn(e,t,n,s,i){var r;return null==e?Me(this,s,i).year:(r=ke(e,s,i),t>r&&(t=r),Rn.call(this,e,t,n,s,i))}function Rn(e,t,n,s,i){var r=Se(e,t,n,s,i),a=we(r.year,0,r.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}function Un(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)}function Cn(e){var t=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"d")}function Fn(e,t){t[oi]=v(1e3*("0."+e))}function Hn(){return this._isUTC?"UTC":""}function Ln(){return this._isUTC?"Coordinated Universal Time":""}function Gn(e){return pt(1e3*e)}function Vn(){return pt.apply(null,arguments).parseZone()}function jn(e){return e}function Nn(e,t,n,s){var i=tt(),r=d().set(s,t);return i[n](r,e)}function An(e,t,n){if(r(e)&&(t=e,e=void 0),e=e||"",null!=t)return Nn(e,t,n,"month");var s,i=[];for(s=0;s<12;s++)i[s]=Nn(e,s,n,"month");return i;
}function En(e,t,n,s){"boolean"==typeof e?(r(t)&&(n=t,t=void 0),t=t||""):(t=e,n=t,e=!1,r(t)&&(n=t,t=void 0),t=t||"");var i=tt(),a=e?i._week.dow:0;if(null!=n)return Nn(t,(n+a)%7,s,"day");var o,u=[];for(o=0;o<7;o++)u[o]=Nn(t,(o+a)%7,s,"day");return u}function In(e,t){return An(e,t,"months")}function zn(e,t){return An(e,t,"monthsShort")}function Zn(e,t,n){return En(e,t,n,"weekdays")}function $n(e,t,n){return En(e,t,n,"weekdaysShort")}function qn(e,t,n){return En(e,t,n,"weekdaysMin")}function Bn(){var e=this._data;return this._milliseconds=Xi(this._milliseconds),this._days=Xi(this._days),this._months=Xi(this._months),e.milliseconds=Xi(e.milliseconds),e.seconds=Xi(e.seconds),e.minutes=Xi(e.minutes),e.hours=Xi(e.hours),e.months=Xi(e.months),e.years=Xi(e.years),this}function Jn(e,t,n,s){var i=jt(t,n);return e._milliseconds+=s*i._milliseconds,e._days+=s*i._days,e._months+=s*i._months,e._bubble()}function Qn(e,t){return Jn(this,e,t,1)}function Xn(e,t){return Jn(this,e,t,-1)}function Kn(e){return e<0?Math.floor(e):Math.ceil(e)}function es(){var e,t,n,s,i,r=this._milliseconds,a=this._days,o=this._months,u=this._data;return r>=0&&a>=0&&o>=0||r<=0&&a<=0&&o<=0||(r+=864e5*Kn(ns(o)+a),a=0,o=0),u.milliseconds=r%1e3,e=w(r/1e3),u.seconds=e%60,t=w(e/60),u.minutes=t%60,n=w(t/60),u.hours=n%24,a+=w(n/24),i=w(ts(a)),o+=i,a-=Kn(ns(i)),s=w(o/12),o%=12,u.days=a,u.months=o,u.years=s,this}function ts(e){return 4800*e/146097}function ns(e){return 146097*e/4800}function ss(e){var t,n,s=this._milliseconds;if(e=H(e),"month"===e||"year"===e)return t=this._days+s/864e5,n=this._months+ts(t),"month"===e?n:n/12;switch(t=this._days+Math.round(ns(this._months)),e){case"week":return t/7+s/6048e5;case"day":return t+s/864e5;case"hour":return 24*t+s/36e5;case"minute":return 1440*t+s/6e4;case"second":return 86400*t+s/1e3;case"millisecond":return Math.floor(864e5*t)+s;default:throw new Error("Unknown unit "+e)}}function is(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*v(this._months/12)}function rs(e){return function(){return this.as(e)}}function as(e){return e=H(e),this[e+"s"]()}function os(e){return function(){return this._data[e]}}function us(){return w(this.days()/7)}function ls(e,t,n,s,i){return i.relativeTime(t||1,!!n,e,s)}function ds(e,t,n){var s=jt(e).abs(),i=mr(s.as("s")),r=mr(s.as("m")),a=mr(s.as("h")),o=mr(s.as("d")),u=mr(s.as("M")),l=mr(s.as("y")),d=i<_r.s&&["s",i]||r<=1&&["m"]||r<_r.m&&["mm",r]||a<=1&&["h"]||a<_r.h&&["hh",a]||o<=1&&["d"]||o<_r.d&&["dd",o]||u<=1&&["M"]||u<_r.M&&["MM",u]||l<=1&&["y"]||["yy",l];return d[2]=t,d[3]=+e>0,d[4]=n,ls.apply(null,d)}function hs(e){return void 0===e?mr:"function"==typeof e&&(mr=e,!0)}function cs(e,t){return void 0!==_r[e]&&(void 0===t?_r[e]:(_r[e]=t,!0))}function fs(e){var t=this.localeData(),n=ds(this,!e,t);return e&&(n=t.pastFuture(+this,n)),t.postformat(n)}function ms(){var e,t,n,s=yr(this._milliseconds)/1e3,i=yr(this._days),r=yr(this._months);e=w(s/60),t=w(e/60),s%=60,e%=60,n=w(r/12),r%=12;var a=n,o=r,u=i,l=t,d=e,h=s,c=this.asSeconds();return c?(c<0?"-":"")+"P"+(a?a+"Y":"")+(o?o+"M":"")+(u?u+"D":"")+(l||d||h?"T":"")+(l?l+"H":"")+(d?d+"M":"")+(h?h+"S":""):"P0D"}var _s,ys;ys=Array.prototype.some?Array.prototype.some:function(e){for(var t=Object(this),n=t.length>>>0,s=0;s<n;s++)if(s in t&&e.call(this,t[s],s,t))return!0;return!1};var gs=ys,ps=e.momentProperties=[],ws=!1,vs={};e.suppressDeprecationWarnings=!1,e.deprecationHandler=null;var Ss;Ss=Object.keys?Object.keys:function(e){var t,n=[];for(t in e)u(e,t)&&n.push(t);return n};var Ms,ks=Ss,Ds={sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},Ys={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},Os="Invalid date",xs="%d",Ts=/\d{1,2}/,bs={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},Ps={},Ws={},Rs=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,Us=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Cs={},Fs={},Hs=/\d/,Ls=/\d\d/,Gs=/\d{3}/,Vs=/\d{4}/,js=/[+-]?\d{6}/,Ns=/\d\d?/,As=/\d\d\d\d?/,Es=/\d\d\d\d\d\d?/,Is=/\d{1,3}/,zs=/\d{1,4}/,Zs=/[+-]?\d{1,6}/,$s=/\d+/,qs=/[+-]?\d+/,Bs=/Z|[+-]\d\d:?\d\d/gi,Js=/Z|[+-]\d\d(?::?\d\d)?/gi,Qs=/[+-]?\d+(\.\d{1,3})?/,Xs=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,Ks={},ei={},ti=0,ni=1,si=2,ii=3,ri=4,ai=5,oi=6,ui=7,li=8;Ms=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var t;for(t=0;t<this.length;++t)if(this[t]===e)return t;return-1};var di=Ms;Z("M",["MM",2],"Mo",function(){return this.month()+1}),Z("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),Z("MMMM",0,0,function(e){return this.localeData().months(this,e)}),F("month","M"),G("month",8),Q("M",Ns),Q("MM",Ns,Ls),Q("MMM",function(e,t){return t.monthsShortRegex(e)}),Q("MMMM",function(e,t){return t.monthsRegex(e)}),te(["M","MM"],function(e,t){t[ni]=v(e)-1}),te(["MMM","MMMM"],function(e,t,n,s){var i=n._locale.monthsParse(e,s,n._strict);null!=i?t[ni]=i:c(n).invalidMonth=e});var hi=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,ci="January_February_March_April_May_June_July_August_September_October_November_December".split("_"),fi="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),mi=Xs,_i=Xs;Z("Y",0,0,function(){var e=this.year();return e<=9999?""+e:"+"+e}),Z(0,["YY",2],0,function(){return this.year()%100}),Z(0,["YYYY",4],0,"year"),Z(0,["YYYYY",5],0,"year"),Z(0,["YYYYYY",6,!0],0,"year"),F("year","y"),G("year",1),Q("Y",qs),Q("YY",Ns,Ls),Q("YYYY",zs,Vs),Q("YYYYY",Zs,js),Q("YYYYYY",Zs,js),te(["YYYYY","YYYYYY"],ti),te("YYYY",function(t,n){n[ti]=2===t.length?e.parseTwoDigitYear(t):v(t)}),te("YY",function(t,n){n[ti]=e.parseTwoDigitYear(t)}),te("Y",function(e,t){t[ti]=parseInt(e,10)}),e.parseTwoDigitYear=function(e){return v(e)+(v(e)>68?1900:2e3)};var yi=j("FullYear",!0);Z("w",["ww",2],"wo","week"),Z("W",["WW",2],"Wo","isoWeek"),F("week","w"),F("isoWeek","W"),G("week",5),G("isoWeek",5),Q("w",Ns),Q("ww",Ns,Ls),Q("W",Ns),Q("WW",Ns,Ls),ne(["w","ww","W","WW"],function(e,t,n,s){t[s.substr(0,1)]=v(e)});var gi={dow:0,doy:6};Z("d",0,"do","day"),Z("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),Z("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),Z("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),Z("e",0,0,"weekday"),Z("E",0,0,"isoWeekday"),F("day","d"),F("weekday","e"),F("isoWeekday","E"),G("day",11),G("weekday",11),G("isoWeekday",11),Q("d",Ns),Q("e",Ns),Q("E",Ns),Q("dd",function(e,t){return t.weekdaysMinRegex(e)}),Q("ddd",function(e,t){return t.weekdaysShortRegex(e)}),Q("dddd",function(e,t){return t.weekdaysRegex(e)}),ne(["dd","ddd","dddd"],function(e,t,n,s){var i=n._locale.weekdaysParse(e,s,n._strict);null!=i?t.d=i:c(n).invalidWeekday=e}),ne(["d","e","E"],function(e,t,n,s){t[s]=v(e)});var pi="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),wi="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),vi="Su_Mo_Tu_We_Th_Fr_Sa".split("_"),Si=Xs,Mi=Xs,ki=Xs;Z("H",["HH",2],0,"hour"),Z("h",["hh",2],0,Ee),Z("k",["kk",2],0,Ie),Z("hmm",0,0,function(){return""+Ee.apply(this)+z(this.minutes(),2)}),Z("hmmss",0,0,function(){return""+Ee.apply(this)+z(this.minutes(),2)+z(this.seconds(),2)}),Z("Hmm",0,0,function(){return""+this.hours()+z(this.minutes(),2)}),Z("Hmmss",0,0,function(){return""+this.hours()+z(this.minutes(),2)+z(this.seconds(),2)}),ze("a",!0),ze("A",!1),F("hour","h"),G("hour",13),Q("a",Ze),Q("A",Ze),Q("H",Ns),Q("h",Ns),Q("HH",Ns,Ls),Q("hh",Ns,Ls),Q("hmm",As),Q("hmmss",Es),Q("Hmm",As),Q("Hmmss",Es),te(["H","HH"],ii),te(["a","A"],function(e,t,n){n._isPm=n._locale.isPM(e),n._meridiem=e}),te(["h","hh"],function(e,t,n){t[ii]=v(e),c(n).bigHour=!0}),te("hmm",function(e,t,n){var s=e.length-2;t[ii]=v(e.substr(0,s)),t[ri]=v(e.substr(s)),c(n).bigHour=!0}),te("hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ii]=v(e.substr(0,s)),t[ri]=v(e.substr(s,2)),t[ai]=v(e.substr(i)),c(n).bigHour=!0}),te("Hmm",function(e,t,n){var s=e.length-2;t[ii]=v(e.substr(0,s)),t[ri]=v(e.substr(s))}),te("Hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ii]=v(e.substr(0,s)),t[ri]=v(e.substr(s,2)),t[ai]=v(e.substr(i))});var Di,Yi=/[ap]\.?m?\.?/i,Oi=j("Hours",!0),xi={calendar:Ds,longDateFormat:Ys,invalidDate:Os,ordinal:xs,ordinalParse:Ts,relativeTime:bs,months:ci,monthsShort:fi,week:gi,weekdays:pi,weekdaysMin:vi,weekdaysShort:wi,meridiemParse:Yi},Ti={},bi={},Pi=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,Wi=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,Ri=/Z|[+-]\d\d(?::?\d\d)?/,Ui=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],Ci=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],Fi=/^\/?Date\((\-?\d+)/i;e.createFromInputFallback=k("value provided is not in a recognized ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""))}),e.ISO_8601=function(){};var Hi=k("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=pt.apply(null,arguments);return this.isValid()&&e.isValid()?e<this?this:e:m()}),Li=k("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=pt.apply(null,arguments);return this.isValid()&&e.isValid()?e>this?this:e:m()}),Gi=function(){return Date.now?Date.now():+new Date};Yt("Z",":"),Yt("ZZ",""),Q("Z",Js),Q("ZZ",Js),te(["Z","ZZ"],function(e,t,n){n._useUTC=!0,n._tzm=Ot(Js,e)});var Vi=/([\+\-]|\d\d)/gi;e.updateOffset=function(){};var ji=/^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,Ni=/^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;jt.fn=Mt.prototype;var Ai=It(1,"add"),Ei=It(-1,"subtract");e.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",e.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Ii=k("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});Z(0,["gg",2],0,function(){return this.weekYear()%100}),Z(0,["GG",2],0,function(){return this.isoWeekYear()%100}),On("gggg","weekYear"),On("ggggg","weekYear"),On("GGGG","isoWeekYear"),On("GGGGG","isoWeekYear"),F("weekYear","gg"),F("isoWeekYear","GG"),G("weekYear",1),G("isoWeekYear",1),Q("G",qs),Q("g",qs),Q("GG",Ns,Ls),Q("gg",Ns,Ls),Q("GGGG",zs,Vs),Q("gggg",zs,Vs),Q("GGGGG",Zs,js),Q("ggggg",Zs,js),ne(["gggg","ggggg","GGGG","GGGGG"],function(e,t,n,s){t[s.substr(0,2)]=v(e)}),ne(["gg","GG"],function(t,n,s,i){n[i]=e.parseTwoDigitYear(t)}),Z("Q",0,"Qo","quarter"),F("quarter","Q"),G("quarter",7),Q("Q",Hs),te("Q",function(e,t){t[ni]=3*(v(e)-1)}),Z("D",["DD",2],"Do","date"),F("date","D"),G("date",9),Q("D",Ns),Q("DD",Ns,Ls),Q("Do",function(e,t){return e?t._ordinalParse:t._ordinalParseLenient}),te(["D","DD"],si),te("Do",function(e,t){t[si]=v(e.match(Ns)[0],10)});var zi=j("Date",!0);Z("DDD",["DDDD",3],"DDDo","dayOfYear"),F("dayOfYear","DDD"),G("dayOfYear",4),Q("DDD",Is),Q("DDDD",Gs),te(["DDD","DDDD"],function(e,t,n){n._dayOfYear=v(e)}),Z("m",["mm",2],0,"minute"),F("minute","m"),G("minute",14),Q("m",Ns),Q("mm",Ns,Ls),te(["m","mm"],ri);var Zi=j("Minutes",!1);Z("s",["ss",2],0,"second"),F("second","s"),G("second",15),Q("s",Ns),Q("ss",Ns,Ls),te(["s","ss"],ai);var $i=j("Seconds",!1);Z("S",0,0,function(){return~~(this.millisecond()/100)}),Z(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),Z(0,["SSS",3],0,"millisecond"),Z(0,["SSSS",4],0,function(){return 10*this.millisecond()}),Z(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),Z(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),Z(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),Z(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),Z(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),F("millisecond","ms"),G("millisecond",16),Q("S",Is,Hs),Q("SS",Is,Ls),Q("SSS",Is,Gs);var qi;for(qi="SSSS";qi.length<=9;qi+="S")Q(qi,$s);for(qi="S";qi.length<=9;qi+="S")te(qi,Fn);var Bi=j("Milliseconds",!1);Z("z",0,0,"zoneAbbr"),Z("zz",0,0,"zoneName");var Ji=g.prototype;Ji.add=Ai,Ji.calendar=$t,Ji.clone=qt,Ji.diff=tn,Ji.endOf=_n,Ji.format=on,Ji.from=un,Ji.fromNow=ln,Ji.to=dn,Ji.toNow=hn,Ji.get=E,Ji.invalidAt=Dn,Ji.isAfter=Bt,Ji.isBefore=Jt,Ji.isBetween=Qt,Ji.isSame=Xt,Ji.isSameOrAfter=Kt,Ji.isSameOrBefore=en,Ji.isValid=Mn,Ji.lang=Ii,Ji.locale=cn,Ji.localeData=fn,Ji.max=Li,Ji.min=Hi,Ji.parsingFlags=kn,Ji.set=I,Ji.startOf=mn,Ji.subtract=Ei,Ji.toArray=wn,Ji.toObject=vn,Ji.toDate=pn,Ji.toISOString=rn,Ji.inspect=an,Ji.toJSON=Sn,Ji.toString=sn,Ji.unix=gn,Ji.valueOf=yn,Ji.creationData=Yn,Ji.year=yi,Ji.isLeapYear=ge,Ji.weekYear=xn,Ji.isoWeekYear=Tn,Ji.quarter=Ji.quarters=Un,Ji.month=de,Ji.daysInMonth=he,Ji.week=Ji.weeks=xe,Ji.isoWeek=Ji.isoWeeks=Te,Ji.weeksInYear=Pn,Ji.isoWeeksInYear=bn,Ji.date=zi,Ji.day=Ji.days=He,Ji.weekday=Le,Ji.isoWeekday=Ge,Ji.dayOfYear=Cn,Ji.hour=Ji.hours=Oi,Ji.minute=Ji.minutes=Zi,Ji.second=Ji.seconds=$i,Ji.millisecond=Ji.milliseconds=Bi,Ji.utcOffset=bt,Ji.utc=Wt,Ji.local=Rt,Ji.parseZone=Ut,Ji.hasAlignedHourOffset=Ct,Ji.isDST=Ft,Ji.isLocal=Lt,Ji.isUtcOffset=Gt,Ji.isUtc=Vt,Ji.isUTC=Vt,Ji.zoneAbbr=Hn,Ji.zoneName=Ln,Ji.dates=k("dates accessor is deprecated. Use date instead.",zi),Ji.months=k("months accessor is deprecated. Use month instead",de),Ji.years=k("years accessor is deprecated. Use year instead",yi),Ji.zone=k("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",Pt),Ji.isDSTShifted=k("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",Ht);var Qi=T.prototype;Qi.calendar=b,Qi.longDateFormat=P,Qi.invalidDate=W,Qi.ordinal=R,Qi.preparse=jn,Qi.postformat=jn,Qi.relativeTime=U,Qi.pastFuture=C,Qi.set=O,Qi.months=re,Qi.monthsShort=ae,Qi.monthsParse=ue,Qi.monthsRegex=fe,Qi.monthsShortRegex=ce,Qi.week=De,Qi.firstDayOfYear=Oe,Qi.firstDayOfWeek=Ye,Qi.weekdays=We,Qi.weekdaysMin=Ue,Qi.weekdaysShort=Re,Qi.weekdaysParse=Fe,Qi.weekdaysRegex=Ve,Qi.weekdaysShortRegex=je,Qi.weekdaysMinRegex=Ne,Qi.isPM=$e,Qi.meridiem=qe,Xe("en",{ordinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var t=e%10,n=1===v(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th";return e+n}}),e.lang=k("moment.lang is deprecated. Use moment.locale instead.",Xe),e.langData=k("moment.langData is deprecated. Use moment.localeData instead.",tt);var Xi=Math.abs,Ki=rs("ms"),er=rs("s"),tr=rs("m"),nr=rs("h"),sr=rs("d"),ir=rs("w"),rr=rs("M"),ar=rs("y"),or=os("milliseconds"),ur=os("seconds"),lr=os("minutes"),dr=os("hours"),hr=os("days"),cr=os("months"),fr=os("years"),mr=Math.round,_r={s:45,m:45,h:22,d:26,M:11},yr=Math.abs,gr=Mt.prototype;return gr.abs=Bn,gr.add=Qn,gr.subtract=Xn,gr.as=ss,gr.asMilliseconds=Ki,gr.asSeconds=er,gr.asMinutes=tr,gr.asHours=nr,gr.asDays=sr,gr.asWeeks=ir,gr.asMonths=rr,gr.asYears=ar,gr.valueOf=is,gr._bubble=es,gr.get=as,gr.milliseconds=or,gr.seconds=ur,gr.minutes=lr,gr.hours=dr,gr.days=hr,gr.weeks=us,gr.months=cr,gr.years=fr,gr.humanize=fs,gr.toISOString=ms,gr.toString=ms,gr.toJSON=ms,gr.locale=cn,gr.localeData=fn,gr.toIsoString=k("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",ms),gr.lang=Ii,Z("X",0,0,"unix"),Z("x",0,0,"valueOf"),Q("x",qs),Q("X",Qs),te("X",function(e,t,n){n._d=new Date(1e3*parseFloat(e,10))}),te("x",function(e,t,n){n._d=new Date(v(e))}),e.version="2.17.1",t(pt),e.fn=Ji,e.min=vt,e.max=St,e.now=Gi,e.utc=d,e.unix=Gn,e.months=In,e.isDate=a,e.locale=Xe,e.invalid=m,e.duration=jt,e.isMoment=p,e.weekdays=Zn,e.parseZone=Vn,e.localeData=tt,e.isDuration=kt,e.monthsShort=zn,e.weekdaysMin=qn,e.defineLocale=Ke,e.updateLocale=et,e.locales=nt,e.weekdaysShort=$n,e.normalizeUnits=H,e.relativeTimeRounding=hs,e.relativeTimeThreshold=cs,e.calendarFormat=Zt,e.prototype=Ji,e});</script><script>
  PatientPortal = PatientPortal || {};

  /**
   * @polymerBehavior
   */
  PatientPortal.Formatters = {
    formatDate: function(dateString){
      return moment(dateString).format('L');
    }, 

    capitalize: function(value){
      if (value) {
        return value.replace(/_/, ' ').toString().split(' ').map(word => {
          return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase()
       }).join(' ');
      } else {
        return '';
      }
    }
  }
</script><script>
  PatientPortal = PatientPortal || {};

  /**
   * @polymerBehavior
   */
  PatientPortal.NavHelpers = {

    /**
     * Navigates to given path.
     */
    navigateTo: function (path) {
      this.set('route.path', path);
    },

    /**
     * Returns the CSS class 'active' if the given link is active.
     * @param link - target link
     * @param page - current `app-router` page
     * @param additionalClasses
     * @returns {string}
     */
    activeClass: function (link, page, ...additionalClasses) {
      return (this.pageActive(link, page) ? 'active' : '') + additionalClasses.join(' ');
    },

    /**
     * Returns true if any of the given patterns match the link.
     * @param link
     * @param patterns
     */
    pageActive: function (link, ...patterns) {
      return !!patterns.find(pattern => link === pattern);
    }
  }
</script><dom-module id="patient-profile" include="shared-styles" assetpath="/">
  <template>
    <style>
      :host {
        display: flex;
        flex: 0!important;
        justify-content: space-around;
        align-items: flex-start;
        flex-wrap: wrap;
        width: 80%;
        margin: 0 auto;
      }
      
      .full-name {
        order: 1;
        width: 100%;
        margin-bottom: 30px;
      }
      
      .name-wrapper {
        margin-right: 8px;
        display: inline-block;
      }
      
      .patient-data {
        order: 2;
        width: 60%
      }
      
      .patient-data tr {
        height: 40px;
        line-height: 40px;
      }
      
      .patient-data td {
        padding: 0 20px;
      }
      
      .patient-data tr:nth-child(odd) {
        background: #FAFAFA;
      }
      
      .label {
        text-transform: uppercase;
        color: #B5B9BC;
      }
      
      .name-wrapper {
        font-size: 0.8em;
      }
      
      .name-wrapper .name {
        font-size: 24px;
        font-weight: 600;
        line-height: 40px;
      }
      
      .name-wrapper .name.first {
        text-decoration: underline;
      }
      
      .profile-pic {
        order: 3;
        width: 35%;
        line-height: 200px;
        text-align: center;
        background: #FAFAFA;
      }
      
      @media (max-width: 900px) {
        .container {
          flex-direction: column;
          align-items: center;
          width: 90%
        }
        .full-name {
          width: auto;
        }
        .patient-data {
          width: 100%;
        }
        .profile-pic {
          width: 60%;
        }
        .patient-data .label {
          text-align: right;
        }
        .profile-pic {
          order: 0;
          margin-bottom: 20px;
        }
      }
    </style>

    <div class="full-name">
      <div class="name-wrapper">
        <div class="label">First name</div>
        <div class="name first">[[patient.firstName]]</div>
      </div>
      <div class="name-wrapper">
        <div class="label">Middle name</div>
        <div class="name">[[patient.middleName]]</div>
      </div>
      <div class="name-wrapper">
        <div class="label">Last name</div>
        <div class="name">[[patient.lastName]]</div>
      </div>
    </div>

    <table class="patient-data">
      <tbody><tr>
        <td class="label">Gender</td>
        <td class="value">[[capitalize(patient.gender)]]</td>
      </tr>
      <tr>
        <td class="label">Date of birth</td>
        <td class="value">[[formatDate(patient.birthDate)]]</td>
      </tr>
      <tr>
        <td class="label">SSN</td>
        <td class="value">[[patient.ssn]]</td>
      </tr>
      <tr>
        <td class="label">Patient Id</td>
        <td class="value">[[patient.id]]</td>
      </tr>
      <tr>
        <td class="label">Doctor</td>
        <td class="value">[[patient.doctor.lastName]], [[patient.doctor.firstName]]</td>
      </tr>
      <tr>
        <td class="label">Medical Record</td>
        <td class="value">[[patient.medicalRecord]]</td>
      </tr>
      <tr>
        <td class="label">Last Visit</td>
        <td class="value">[[formatDate(patient.lastVisit)]]</td>
      </tr>
    </tbody></table>

    <img class="profile-pic" src="[[patient.pictureUrl]]">
  </template>
  <script>
    Polymer({
      is: 'patient-profile', 
      behaviors: [PatientPortal.Formatters],
      properties: {
        patient: {
          type: Object
        }
      }
    });
  </script>
</dom-module><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
Material design: [Text fields](https://www.google.com/design/spec/components/text-fields.html)

`<paper-input>` is a single-line text field with Material Design styling.

    <paper-input label="Input label"></paper-input>

It may include an optional error message or character counter.

    <paper-input error-message="Invalid input!" label="Input label"></paper-input>
    <paper-input char-counter label="Input label"></paper-input>

It can also include custom prefix or suffix elements, which are displayed
before or after the text input itself. In order for an element to be
considered as a prefix, it must have the `prefix` attribute (and similarly
for `suffix`).

    <paper-input label="total">
      <div prefix>$</div>
      <paper-icon-button suffix icon="clear"></paper-icon-button>
    </paper-input>

A `paper-input` can use the native `type=search` or `type=file` features.
However, since we can't control the native styling of the input (search icon,
file button, date placeholder, etc.), in these cases the label will be
automatically floated. The `placeholder` attribute can still be used for
additional informational text.

    <paper-input label="search!" type="search"
        placeholder="search for cats" autosave="test" results="5">
    </paper-input>

See `Polymer.PaperInputBehavior` for more API docs.

### Focus

To focus a paper-input, you can call the native `focus()` method as long as the
paper input has a tab index.

### Styling

See `Polymer.PaperInputContainer` for a list of custom properties used to
style this element.


@group Paper Elements
@element paper-input
@hero hero.svg
@demo demo/index.html
-->

<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>
  /**
  Polymer.IronFormElementBehavior enables a custom element to be included
  in an `iron-form`.

  @demo demo/index.html
  @polymerBehavior
  */
  Polymer.IronFormElementBehavior = {

    properties: {
      /**
       * Fired when the element is added to an `iron-form`.
       *
       * @event iron-form-element-register
       */

      /**
       * Fired when the element is removed from an `iron-form`.
       *
       * @event iron-form-element-unregister
       */

      /**
       * The name of this element.
       */
      name: {
        type: String
      },

      /**
       * The value for this element.
       */
      value: {
        notify: true,
        type: String
      },

      /**
       * Set to true to mark the input as required. If used in a form, a
       * custom element that uses this behavior should also use
       * Polymer.IronValidatableBehavior and define a custom validation method.
       * Otherwise, a `required` element will always be considered valid.
       * It's also strongly recommended to provide a visual style for the element
       * when its value is invalid.
       */
      required: {
        type: Boolean,
        value: false
      },

      /**
       * The form that the element is registered to.
       */
      _parentForm: {
        type: Object
      }
    },

    attached: function() {
      // Note: the iron-form that this element belongs to will set this
      // element's _parentForm property when handling this event.
      this.fire('iron-form-element-register');
    },

    detached: function() {
      if (this._parentForm) {
        this._parentForm.fire('iron-form-element-unregister', {target: this});
      }
    }

  };

</script><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
`iron-a11y-announcer` is a singleton element that is intended to add a11y
to features that require on-demand announcement from screen readers. In
order to make use of the announcer, it is best to request its availability
in the announcing element.

Example:

    Polymer({

      is: 'x-chatty',

      attached: function() {
        // This will create the singleton element if it has not
        // been created yet:
        Polymer.IronA11yAnnouncer.requestAvailability();
      }
    });

After the `iron-a11y-announcer` has been made available, elements can
make announces by firing bubbling `iron-announce` events.

Example:

    this.fire('iron-announce', {
      text: 'This is an announcement!'
    }, { bubbles: true });

Note: announcements are only audible if you have a screen reader enabled.

@group Iron Elements
@demo demo/index.html
-->

<dom-module id="iron-a11y-announcer" assetpath="../../../bower_components/iron-a11y-announcer/">
  <template>
    <style>
      :host {
        display: inline-block;
        position: fixed;
        clip: rect(0px,0px,0px,0px);
      }
    </style>
    <div aria-live$="[[mode]]">[[_text]]</div>
  </template>

  <script>

    (function() {
      'use strict';

      Polymer.IronA11yAnnouncer = Polymer({
        is: 'iron-a11y-announcer',

        properties: {

          /**
           * The value of mode is used to set the `aria-live` attribute
           * for the element that will be announced. Valid values are: `off`,
           * `polite` and `assertive`.
           */
          mode: {
            type: String,
            value: 'polite'
          },

          _text: {
            type: String,
            value: ''
          }
        },

        created: function() {
          if (!Polymer.IronA11yAnnouncer.instance) {
            Polymer.IronA11yAnnouncer.instance = this;
          }

          document.body.addEventListener('iron-announce', this._onIronAnnounce.bind(this));
        },

        /**
         * Cause a text string to be announced by screen readers.
         *
         * @param {string} text The text that should be announced.
         */
        announce: function(text) {
          this._text = '';
          this.async(function() {
            this._text = text;
          }, 100);
        },

        _onIronAnnounce: function(event) {
          if (event.detail && event.detail.text) {
            this.announce(event.detail.text);
          }
        }
      });

      Polymer.IronA11yAnnouncer.instance = null;

      Polymer.IronA11yAnnouncer.requestAvailability = function() {
        if (!Polymer.IronA11yAnnouncer.instance) {
          Polymer.IronA11yAnnouncer.instance = document.createElement('iron-a11y-announcer');
        }

        document.body.appendChild(Polymer.IronA11yAnnouncer.instance);
      };
    })();

  </script>
</dom-module>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>
  /**
   * Singleton IronMeta instance.
   */
  Polymer.IronValidatableBehaviorMeta = null;

  /**
   * `Use Polymer.IronValidatableBehavior` to implement an element that validates user input.
   * Use the related `Polymer.IronValidatorBehavior` to add custom validation logic to an iron-input.
   *
   * By default, an `<iron-form>` element validates its fields when the user presses the submit button.
   * To validate a form imperatively, call the form's `validate()` method, which in turn will
   * call `validate()` on all its children. By using `Polymer.IronValidatableBehavior`, your
   * custom element will get a public `validate()`, which
   * will return the validity of the element, and a corresponding `invalid` attribute,
   * which can be used for styling.
   *
   * To implement the custom validation logic of your element, you must override
   * the protected `_getValidity()` method of this behaviour, rather than `validate()`.
   * See [this](https://github.com/PolymerElements/iron-form/blob/master/demo/simple-element.html)
   * for an example.
   *
   * ### Accessibility
   *
   * Changing the `invalid` property, either manually or by calling `validate()` will update the
   * `aria-invalid` attribute.
   *
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronValidatableBehavior = {

    properties: {

      /**
       * Name of the validator to use.
       */
      validator: {
        type: String
      },

      /**
       * True if the last call to `validate` is invalid.
       */
      invalid: {
        notify: true,
        reflectToAttribute: true,
        type: Boolean,
        value: false
      },

      /**
       * This property is deprecated and should not be used. Use the global
       * validator meta singleton, `Polymer.IronValidatableBehaviorMeta` instead.
       */
      _validatorMeta: {
        type: Object
      },

      /**
       * Namespace for this validator. This property is deprecated and should
       * not be used. For all intents and purposes, please consider it a
       * read-only, config-time property.
       */
      validatorType: {
        type: String,
        value: 'validator'
      },

      _validator: {
        type: Object,
        computed: '__computeValidator(validator)'
      }
    },

    observers: [
      '_invalidChanged(invalid)'
    ],

    registered: function() {
      Polymer.IronValidatableBehaviorMeta = new Polymer.IronMeta({type: 'validator'});
    },

    _invalidChanged: function() {
      if (this.invalid) {
        this.setAttribute('aria-invalid', 'true');
      } else {
        this.removeAttribute('aria-invalid');
      }
    },

    /**
     * @return {boolean} True if the validator `validator` exists.
     */
    hasValidator: function() {
      return this._validator != null;
    },

    /**
     * Returns true if the `value` is valid, and updates `invalid`. If you want
     * your element to have custom validation logic, do not override this method;
     * override `_getValidity(value)` instead.

     * @param {Object} value The value to be validated. By default, it is passed
     * to the validator's `validate()` function, if a validator is set.
     * @return {boolean} True if `value` is valid.
     */
    validate: function(value) {
      this.invalid = !this._getValidity(value);
      return !this.invalid;
    },

    /**
     * Returns true if `value` is valid.  By default, it is passed
     * to the validator's `validate()` function, if a validator is set. You
     * should override this method if you want to implement custom validity
     * logic for your element.
     *
     * @param {Object} value The value to be validated.
     * @return {boolean} True if `value` is valid.
     */

    _getValidity: function(value) {
      if (this.hasValidator()) {
        return this._validator.validate(value);
      }
      return true;
    },

    __computeValidator: function() {
      return Polymer.IronValidatableBehaviorMeta &&
          Polymer.IronValidatableBehaviorMeta.byKey(this.validator);
    }
  };

</script><script>

/*
`<iron-input>` adds two-way binding and custom validators using `Polymer.IronValidatorBehavior`
to `<input>`.

### Two-way binding

By default you can only get notified of changes to an `input`'s `value` due to user input:

    <input value="{{myValue::input}}">

`iron-input` adds the `bind-value` property that mirrors the `value` property, and can be used
for two-way data binding. `bind-value` will notify if it is changed either by user input or by script.

    <input is="iron-input" bind-value="{{myValue}}">

### Custom validators

You can use custom validators that implement `Polymer.IronValidatorBehavior` with `<iron-input>`.

    <input is="iron-input" validator="my-custom-validator">

### Stopping invalid input

It may be desirable to only allow users to enter certain characters. You can use the
`prevent-invalid-input` and `allowed-pattern` attributes together to accomplish this. This feature
is separate from validation, and `allowed-pattern` does not affect how the input is validated.

    <!-- only allow characters that match [0-9] -->
    <input is="iron-input" prevent-invalid-input allowed-pattern="[0-9]">

@hero hero.svg
@demo demo/index.html
*/

  Polymer({

    is: 'iron-input',

    extends: 'input',

    behaviors: [
      Polymer.IronValidatableBehavior
    ],

    properties: {

      /**
       * Use this property instead of `value` for two-way data binding.
       */
      bindValue: {
        observer: '_bindValueChanged',
        type: String
      },

      /**
       * Set to true to prevent the user from entering invalid input. If `allowedPattern` is set,
       * any character typed by the user will be matched against that pattern, and rejected if it's not a match.
       * Pasted input will have each character checked individually; if any character
       * doesn't match `allowedPattern`, the entire pasted string will be rejected.
       * If `allowedPattern` is not set, it will use the `type` attribute (only supported for `type=number`).
       */
      preventInvalidInput: {
        type: Boolean
      },

      /**
       * Regular expression that list the characters allowed as input.
       * This pattern represents the allowed characters for the field; as the user inputs text,
       * each individual character will be checked against the pattern (rather than checking
       * the entire value as a whole). The recommended format should be a list of allowed characters;
       * for example, `[a-zA-Z0-9.+-!;:]`
       */
      allowedPattern: {
        type: String,
        observer: "_allowedPatternChanged"
      },

      _previousValidInput: {
        type: String,
        value: ''
      },

      _patternAlreadyChecked: {
        type: Boolean,
        value: false
      }

    },

    listeners: {
      'input': '_onInput',
      'keypress': '_onKeypress'
    },

    /** @suppress {checkTypes} */
    registered: function() {
      // Feature detect whether we need to patch dispatchEvent (i.e. on FF and IE).
      if (!this._canDispatchEventOnDisabled()) {
        this._origDispatchEvent = this.dispatchEvent;
        this.dispatchEvent = this._dispatchEventFirefoxIE;
      }
    },

    created: function() {
      Polymer.IronA11yAnnouncer.requestAvailability();
    },

    _canDispatchEventOnDisabled: function() {
      var input = document.createElement('input');
      var canDispatch = false;
      input.disabled = true;

      input.addEventListener('feature-check-dispatch-event', function() {
        canDispatch = true;
      });

      try {
        input.dispatchEvent(new Event('feature-check-dispatch-event'));
      } catch(e) {}

      return canDispatch;
    },

    _dispatchEventFirefoxIE: function() {
      // Due to Firefox bug, events fired on disabled form controls can throw
      // errors; furthermore, neither IE nor Firefox will actually dispatch
      // events from disabled form controls; as such, we toggle disable around
      // the dispatch to allow notifying properties to notify
      // See issue #47 for details
      var disabled = this.disabled;
      this.disabled = false;
      this._origDispatchEvent.apply(this, arguments);
      this.disabled = disabled;
    },

    get _patternRegExp() {
      var pattern;
      if (this.allowedPattern) {
        pattern = new RegExp(this.allowedPattern);
      } else {
        switch (this.type) {
          case 'number':
            pattern = /[0-9.,e-]/;
            break;
        }
      }
      return pattern;
    },

    ready: function() {
      this.bindValue = this.value;
    },

    /**
     * @suppress {checkTypes}
     */
    _bindValueChanged: function() {
      if (this.value !== this.bindValue) {
        this.value = !(this.bindValue || this.bindValue === 0 || this.bindValue === false) ? '' : this.bindValue;
      }
      // manually notify because we don't want to notify until after setting value
      this.fire('bind-value-changed', {value: this.bindValue});
    },

    _allowedPatternChanged: function() {
      // Force to prevent invalid input when an `allowed-pattern` is set
      this.preventInvalidInput = this.allowedPattern ? true : false;
    },

    _onInput: function() {
      // Need to validate each of the characters pasted if they haven't
      // been validated inside `_onKeypress` already.
      if (this.preventInvalidInput && !this._patternAlreadyChecked) {
        var valid = this._checkPatternValidity();
        if (!valid) {
          this._announceInvalidCharacter('Invalid string of characters not entered.');
          this.value = this._previousValidInput;
        }
      }

      this.bindValue = this.value;
      this._previousValidInput = this.value;
      this._patternAlreadyChecked = false;
    },

    _isPrintable: function(event) {
      // What a control/printable character is varies wildly based on the browser.
      // - most control characters (arrows, backspace) do not send a `keypress` event
      //   in Chrome, but the *do* on Firefox
      // - in Firefox, when they do send a `keypress` event, control chars have
      //   a charCode = 0, keyCode = xx (for ex. 40 for down arrow)
      // - printable characters always send a keypress event.
      // - in Firefox, printable chars always have a keyCode = 0. In Chrome, the keyCode
      //   always matches the charCode.
      // None of this makes any sense.

      // For these keys, ASCII code == browser keycode.
      var anyNonPrintable =
        (event.keyCode == 8)   ||  // backspace
        (event.keyCode == 9)   ||  // tab
        (event.keyCode == 13)  ||  // enter
        (event.keyCode == 27);     // escape

      // For these keys, make sure it's a browser keycode and not an ASCII code.
      var mozNonPrintable =
        (event.keyCode == 19)  ||  // pause
        (event.keyCode == 20)  ||  // caps lock
        (event.keyCode == 45)  ||  // insert
        (event.keyCode == 46)  ||  // delete
        (event.keyCode == 144) ||  // num lock
        (event.keyCode == 145) ||  // scroll lock
        (event.keyCode > 32 && event.keyCode < 41)   || // page up/down, end, home, arrows
        (event.keyCode > 111 && event.keyCode < 124); // fn keys

      return !anyNonPrintable && !(event.charCode == 0 && mozNonPrintable);
    },

    _onKeypress: function(event) {
      if (!this.preventInvalidInput && this.type !== 'number') {
        return;
      }
      var regexp = this._patternRegExp;
      if (!regexp) {
        return;
      }

      // Handle special keys and backspace
      if (event.metaKey || event.ctrlKey || event.altKey)
        return;

      // Check the pattern either here or in `_onInput`, but not in both.
      this._patternAlreadyChecked = true;

      var thisChar = String.fromCharCode(event.charCode);
      if (this._isPrintable(event) && !regexp.test(thisChar)) {
        event.preventDefault();
        this._announceInvalidCharacter('Invalid character ' + thisChar + ' not entered.');
      }
    },

    _checkPatternValidity: function() {
      var regexp = this._patternRegExp;
      if (!regexp) {
        return true;
      }
      for (var i = 0; i < this.value.length; i++) {
        if (!regexp.test(this.value[i])) {
          return false;
        }
      }
      return true;
    },

    /**
     * Returns true if `value` is valid. The validator provided in `validator` will be used first,
     * then any constraints.
     * @return {boolean} True if the value is valid.
     */
    validate: function() {
      // First, check what the browser thinks. Some inputs (like type=number)
      // behave weirdly and will set the value to "" if something invalid is
      // entered, but will set the validity correctly.
      var valid =  this.checkValidity();

      // Only do extra checking if the browser thought this was valid.
      if (valid) {
        // Empty, required input is invalid
        if (this.required && this.value === '') {
          valid = false;
        } else if (this.hasValidator()) {
          valid = Polymer.IronValidatableBehavior.validate.call(this, this.value);
        }
      }

      this.invalid = !valid;
      this.fire('iron-input-validate');
      return valid;
    },

    _announceInvalidCharacter: function(message) {
      this.fire('iron-announce', { text: message });
    }
  });

  /*
  The `iron-input-validate` event is fired whenever `validate()` is called.
  @event iron-input-validate
  */

</script><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>

  // Generate unique, monotonically increasing IDs for labels (needed by
  // aria-labelledby) and add-ons.
  Polymer.PaperInputHelper = {};
  Polymer.PaperInputHelper.NextLabelID = 1;
  Polymer.PaperInputHelper.NextAddonID = 1;

  /**
   * Use `Polymer.PaperInputBehavior` to implement inputs with `<paper-input-container>`. This
   * behavior is implemented by `<paper-input>`. It exposes a number of properties from
   * `<paper-input-container>` and `<input is="iron-input">` and they should be bound in your
   * template.
   *
   * The input element can be accessed by the `inputElement` property if you need to access
   * properties or methods that are not exposed.
   * @polymerBehavior Polymer.PaperInputBehavior
   */
  Polymer.PaperInputBehaviorImpl = {

    properties: {
      /**
       * Fired when the input changes due to user interaction.
       *
       * @event change
       */

      /**
       * The label for this input. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * `<label>`'s content and `hidden` property, e.g.
       * `<label hidden$="[[!label]]">[[label]]</label>` in your `template`
       */
      label: {
        type: String
      },

      /**
       * The value for this input. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input is="iron-input">`'s `bindValue`
       * property, or the value property of your input that is `notify:true`.
       */
      value: {
        notify: true,
        type: String
      },

      /**
       * Set to true to disable this input. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * both the `<paper-input-container>`'s and the input's `disabled` property.
       */
      disabled: {
        type: Boolean,
        value: false
      },

      /**
       * Returns true if the value is invalid. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to both the
       * `<paper-input-container>`'s and the input's `invalid` property.
       *
       * If `autoValidate` is true, the `invalid` attribute is managed automatically,
       * which can clobber attempts to manage it manually.
       */
      invalid: {
        type: Boolean,
        value: false,
        notify: true
      },

      /**
       * Set to true to prevent the user from entering invalid input. If you're
       * using PaperInputBehavior to  implement your own paper-input-like element,
       * bind this to `<input is="iron-input">`'s `preventInvalidInput` property.
       */
      preventInvalidInput: {
        type: Boolean
      },

      /**
       * Set this to specify the pattern allowed by `preventInvalidInput`. If
       * you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `allowedPattern`
       * property.
       */
      allowedPattern: {
        type: String
      },

      /**
       * The type of the input. The supported types are `text`, `number` and `password`.
       * If you're using PaperInputBehavior to implement your own paper-input-like element,
       * bind this to the `<input is="iron-input">`'s `type` property.
       */
      type: {
        type: String
      },

      /**
       * The datalist of the input (if any). This should match the id of an existing `<datalist>`.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `list` property.
       */
      list: {
        type: String
      },

      /**
       * A pattern to validate the `input` with. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input is="iron-input">`'s `pattern` property.
       */
      pattern: {
        type: String
      },

      /**
       * Set to true to mark the input as required. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input is="iron-input">`'s `required` property.
       */
      required: {
        type: Boolean,
        value: false
      },

      /**
       * The error message to display when the input is invalid. If you're using
       * PaperInputBehavior to implement your own paper-input-like element,
       * bind this to the `<paper-input-error>`'s content, if using.
       */
      errorMessage: {
        type: String
      },

      /**
       * Set to true to show a character counter.
       */
      charCounter: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable the floating label. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<paper-input-container>`'s `noLabelFloat` property.
       */
      noLabelFloat: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to always float the label. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<paper-input-container>`'s `alwaysFloatLabel` property.
       */
      alwaysFloatLabel: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to auto-validate the input value. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<paper-input-container>`'s `autoValidate` property.
       */
      autoValidate: {
        type: Boolean,
        value: false
      },

      /**
       * Name of the validator to use. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input is="iron-input">`'s `validator` property.
       */
      validator: {
        type: String
      },

      // HTMLInputElement attributes for binding if needed

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autocomplete` property.
       */
      autocomplete: {
        type: String,
        value: 'off'
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autofocus` property.
       */
      autofocus: {
        type: Boolean,
        observer: '_autofocusChanged'
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `inputmode` property.
       */
      inputmode: {
        type: String
      },

      /**
       * The minimum length of the input value.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `minlength` property.
       */
      minlength: {
        type: Number
      },

      /**
       * The maximum length of the input value.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `maxlength` property.
       */
      maxlength: {
        type: Number
      },

      /**
       * The minimum (numeric or date-time) input value.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `min` property.
       */
      min: {
        type: String
      },

      /**
       * The maximum (numeric or date-time) input value.
       * Can be a String (e.g. `"2000-01-01"`) or a Number (e.g. `2`).
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `max` property.
       */
      max: {
        type: String
      },

      /**
       * Limits the numeric or date-time increments.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `step` property.
       */
      step: {
        type: String
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `name` property.
       */
      name: {
        type: String
      },

      /**
       * A placeholder string in addition to the label. If this is set, the label will always float.
       */
      placeholder: {
        type: String,
        // need to set a default so _computeAlwaysFloatLabel is run
        value: ''
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `readonly` property.
       */
      readonly: {
        type: Boolean,
        value: false
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `size` property.
       */
      size: {
        type: Number
      },

      // Nonstandard attributes for binding if needed

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autocapitalize` property.
       */
      autocapitalize: {
        type: String,
        value: 'none'
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autocorrect` property.
       */
      autocorrect: {
        type: String,
        value: 'off'
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autosave` property,
       * used with type=search.
       */
      autosave: {
        type: String
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `results` property,
       * used with type=search.
       */
      results: {
        type: Number
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `accept` property,
       * used with type=file.
       */
      accept: {
        type: String
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the`<input is="iron-input">`'s `multiple` property,
       * used with type=file.
       */
      multiple: {
        type: Boolean
      },

      _ariaDescribedBy: {
        type: String,
        value: ''
      },

      _ariaLabelledBy: {
        type: String,
        value: ''
      }

    },

    listeners: {
      'addon-attached': '_onAddonAttached',
    },

    keyBindings: {
      'shift+tab:keydown': '_onShiftTabDown'
    },

    hostAttributes: {
      tabindex: 0
    },

    /**
     * Returns a reference to the input element.
     */
    get inputElement() {
      return this.$.input;
    },

    /**
     * Returns a reference to the focusable element.
     */
    get _focusableElement() {
      return this.inputElement;
    },

    registered: function() {
      // These types have some default placeholder text; overlapping
      // the label on top of it looks terrible. Auto-float the label in this case.
      this._typesThatHaveText = ["date", "datetime", "datetime-local", "month",
          "time", "week", "file"];
    },

    attached: function() {
      this._updateAriaLabelledBy();

      if (this.inputElement &&
          this._typesThatHaveText.indexOf(this.inputElement.type) !== -1) {
        this.alwaysFloatLabel = true;
      }
    },

    _appendStringWithSpace: function(str, more) {
      if (str) {
        str = str + ' ' + more;
      } else {
        str = more;
      }
      return str;
    },

    _onAddonAttached: function(event) {
      var target = event.path ? event.path[0] : event.target;
      if (target.id) {
        this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, target.id);
      } else {
        var id = 'paper-input-add-on-' + Polymer.PaperInputHelper.NextAddonID++;
        target.id = id;
        this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, id);
      }
    },

    /**
     * Validates the input element and sets an error style if needed.
     *
     * @return {boolean}
     */
    validate: function() {
      return this.inputElement.validate();
    },

    /**
     * Forward focus to inputElement. Overriden from IronControlState.
     */
    _focusBlurHandler: function(event) {
      Polymer.IronControlState._focusBlurHandler.call(this, event);

      // Forward the focus to the nested input.
      if (this.focused && !this._shiftTabPressed)
        this._focusableElement.focus();
    },

    /**
     * Handler that is called when a shift+tab keypress is detected by the menu.
     *
     * @param {CustomEvent} event A key combination event.
     */
    _onShiftTabDown: function(event) {
      var oldTabIndex = this.getAttribute('tabindex');
      this._shiftTabPressed = true;
      this.setAttribute('tabindex', '-1');
      this.async(function() {
        this.setAttribute('tabindex', oldTabIndex);
        this._shiftTabPressed = false;
      }, 1);
    },

    /**
     * If `autoValidate` is true, then validates the element.
     */
    _handleAutoValidate: function() {
      if (this.autoValidate)
        this.validate();
    },

    /**
     * Restores the cursor to its original position after updating the value.
     * @param {string} newValue The value that should be saved.
     */
    updateValueAndPreserveCaret: function(newValue) {
      // Not all elements might have selection, and even if they have the
      // right properties, accessing them might throw an exception (like for
      // <input type=number>)
      try {
        var start = this.inputElement.selectionStart;
        this.value = newValue;

        // The cursor automatically jumps to the end after re-setting the value,
        // so restore it to its original position.
        this.inputElement.selectionStart = start;
        this.inputElement.selectionEnd = start;
      } catch (e) {
        // Just set the value and give up on the caret.
        this.value = newValue;
      }
    },

    _computeAlwaysFloatLabel: function(alwaysFloatLabel, placeholder) {
      return placeholder || alwaysFloatLabel;
    },

    _updateAriaLabelledBy: function() {
      var label = Polymer.dom(this.root).querySelector('label');
      if (!label) {
        this._ariaLabelledBy = '';
        return;
      }
      var labelledBy;
      if (label.id) {
        labelledBy = label.id;
      } else {
        labelledBy = 'paper-input-label-' + Polymer.PaperInputHelper.NextLabelID++;
        label.id = labelledBy;
      }
      this._ariaLabelledBy = labelledBy;
    },

    _onChange:function(event) {
      // In the Shadow DOM, the `change` event is not leaked into the
      // ancestor tree, so we must do this manually.
      // See https://w3c.github.io/webcomponents/spec/shadow/#events-that-are-not-leaked-into-ancestor-trees.
      if (this.shadowRoot) {
        this.fire(event.type, {sourceEvent: event}, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    },

    _autofocusChanged: function() {
      // Firefox doesn't respect the autofocus attribute if it's applied after
      // the page is loaded (Chrome/WebKit do respect it), preventing an
      // autofocus attribute specified in markup from taking effect when the
      // element is upgraded. As a workaround, if the autofocus property is set,
      // and the focus hasn't already been moved elsewhere, we take focus.
      if (this.autofocus && this._focusableElement) {

        // In IE 11, the default document.activeElement can be the page's
        // outermost html element, but there are also cases (under the
        // polyfill?) in which the activeElement is not a real HTMLElement, but
        // just a plain object. We identify the latter case as having no valid
        // activeElement.
        var activeElement = document.activeElement;
        var isActiveElementValid = activeElement instanceof HTMLElement;

        // Has some other element has already taken the focus?
        var isSomeElementActive = isActiveElementValid &&
            activeElement !== document.body &&
            activeElement !== document.documentElement; /* IE 11 */
        if (!isSomeElementActive) {
          // No specific element has taken the focus yet, so we can take it.
          this._focusableElement.focus();
        }
      }
    }
  };

  /** @polymerBehavior */
  Polymer.PaperInputBehavior = [
    Polymer.IronControlState,
    Polymer.IronA11yKeysBehavior,
    Polymer.PaperInputBehaviorImpl
  ];
</script><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
`<paper-input-char-counter>` is a character counter for use with `<paper-input-container>`. It
shows the number of characters entered in the input and the max length if it is specified.

    <paper-input-container>
      <input is="iron-input" maxlength="20">
      <paper-input-char-counter></paper-input-char-counter>
    </paper-input-container>

### Styling

The following mixin is available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-input-char-counter` | Mixin applied to the element | `{}`
-->

<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic,500,500italic,700,700italic">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700">
<style is="custom-style">

  :root {

    /* Shared Styles */
    --paper-font-common-base: {
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
    };

    --paper-font-common-code: {
      font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
      -webkit-font-smoothing: antialiased;
    };

    --paper-font-common-expensive-kerning: {
      text-rendering: optimizeLegibility;
    };

    --paper-font-common-nowrap: {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    };

    /* Material Font Styles */

    --paper-font-display4: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 112px;
      font-weight: 300;
      letter-spacing: -.044em;
      line-height: 120px;
    };

    --paper-font-display3: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 56px;
      font-weight: 400;
      letter-spacing: -.026em;
      line-height: 60px;
    };

    --paper-font-display2: {
      @apply(--paper-font-common-base);

      font-size: 45px;
      font-weight: 400;
      letter-spacing: -.018em;
      line-height: 48px;
    };

    --paper-font-display1: {
      @apply(--paper-font-common-base);

      font-size: 34px;
      font-weight: 400;
      letter-spacing: -.01em;
      line-height: 40px;
    };

    --paper-font-headline: {
      @apply(--paper-font-common-base);

      font-size: 24px;
      font-weight: 400;
      letter-spacing: -.012em;
      line-height: 32px;
    };

    --paper-font-title: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 20px;
      font-weight: 500;
      line-height: 28px;
    };

    --paper-font-subhead: {
      @apply(--paper-font-common-base);

      font-size: 16px;
      font-weight: 400;
      line-height: 24px;
    };

    --paper-font-body2: {
      @apply(--paper-font-common-base);

      font-size: 14px;
      font-weight: 500;
      line-height: 24px;
    };

    --paper-font-body1: {
      @apply(--paper-font-common-base);

      font-size: 14px;
      font-weight: 400;
      line-height: 20px;
    };

    --paper-font-caption: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 12px;
      font-weight: 400;
      letter-spacing: 0.011em;
      line-height: 20px;
    };

    --paper-font-menu: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 13px;
      font-weight: 500;
      line-height: 24px;
    };

    --paper-font-button: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.018em;
      line-height: 24px;
      text-transform: uppercase;
    };

    --paper-font-code2: {
      @apply(--paper-font-common-code);

      font-size: 14px;
      font-weight: 700;
      line-height: 20px;
    };

    --paper-font-code1: {
      @apply(--paper-font-common-code);

      font-size: 14px;
      font-weight: 500;
      line-height: 20px;
    };

  }

</style><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>

  /**
   * Use `Polymer.PaperInputAddonBehavior` to implement an add-on for `<paper-input-container>`. A
   * add-on appears below the input, and may display information based on the input value and
   * validity such as a character counter or an error message.
   * @polymerBehavior
   */
  Polymer.PaperInputAddonBehavior = {

    hostAttributes: {
      'add-on': ''
    },

    attached: function() {
      this.fire('addon-attached');
    },

    /**
     * The function called by `<paper-input-container>` when the input value or validity changes.
     * @param {{
     *   inputElement: (Element|undefined),
     *   value: (string|undefined),
     *   invalid: boolean
     * }} state -
     *     inputElement: The input element.
     *     value: The input value.
     *     invalid: True if the input value is invalid.
     */
    update: function(state) {
    }

  };

</script><dom-module id="paper-input-char-counter" assetpath="../../../bower_components/paper-input/">
  <template>
    <style>
      :host {
        display: inline-block;
        float: right;

        @apply(--paper-font-caption);
        @apply(--paper-input-char-counter);
      }

      :host([hidden]) {
        display: none !important;
      }

      :host-context([dir="rtl"]) {
        float: left;
      }
    </style>

    <span>[[_charCounterStr]]</span>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-input-char-counter',

    behaviors: [
      Polymer.PaperInputAddonBehavior
    ],

    properties: {
      _charCounterStr: {
        type: String,
        value: '0'
      }
    },

    /**
     * This overrides the update function in PaperInputAddonBehavior.
     * @param {{
     *   inputElement: (Element|undefined),
     *   value: (string|undefined),
     *   invalid: boolean
     * }} state -
     *     inputElement: The input element.
     *     value: The input value.
     *     invalid: True if the input value is invalid.
     */
    update: function(state) {
      if (!state.inputElement) {
        return;
      }

      state.value = state.value || '';

      var counter = state.value.toString().length.toString();

      if (state.inputElement.hasAttribute('maxlength')) {
        counter += '/' + state.inputElement.getAttribute('maxlength');
      }

      this._charCounterStr = counter;
    }
  });
</script>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
`<paper-input-container>` is a container for a `<label>`, an `<input is="iron-input">` or
`<textarea>` and optional add-on elements such as an error message or character
counter, used to implement Material Design text fields.

For example:

    <paper-input-container>
      <label>Your name</label>
      <input is="iron-input">
    </paper-input-container>

Do not wrap `<paper-input-container>` around elements that already include it, such as `<paper-input>`.
Doing so may cause events to bounce infintely between the container and its contained element.

### Listening for input changes

By default, it listens for changes on the `bind-value` attribute on its children nodes and perform
tasks such as auto-validating and label styling when the `bind-value` changes. You can configure
the attribute it listens to with the `attr-for-value` attribute.

### Using a custom input element

You can use a custom input element in a `<paper-input-container>`, for example to implement a
compound input field like a social security number input. The custom input element should have the
`paper-input-input` class, have a `notify:true` value property and optionally implements
`Polymer.IronValidatableBehavior` if it is validatable.

    <paper-input-container attr-for-value="ssn-value">
      <label>Social security number</label>
      <ssn-input class="paper-input-input"></ssn-input>
    </paper-input-container>


If you're using a `<paper-input-container>` imperatively, it's important to make sure
that you attach its children (the `iron-input` and the optional `label`) before you
attach the `<paper-input-container>` itself, so that it can be set up correctly.

### Validation

If the `auto-validate` attribute is set, the input container will validate the input and update
the container styling when the input value changes.

### Add-ons

Add-ons are child elements of a `<paper-input-container>` with the `add-on` attribute and
implements the `Polymer.PaperInputAddonBehavior` behavior. They are notified when the input value
or validity changes, and may implement functionality such as error messages or character counters.
They appear at the bottom of the input.

### Prefixes and suffixes
These are child elements of a `<paper-input-container>` with the `prefix`
or `suffix` attribute, and are displayed inline with the input, before or after.

    <paper-input-container>
      <div prefix>$</div>
      <label>Total</label>
      <input is="iron-input">
      <paper-icon-button suffix icon="clear"></paper-icon-button>
    </paper-input-container>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-input-container-color` | Label and underline color when the input is not focused | `--secondary-text-color`
`--paper-input-container-focus-color` | Label and underline color when the input is focused | `--primary-color`
`--paper-input-container-invalid-color` | Label and underline color when the input is is invalid | `--error-color`
`--paper-input-container-input-color` | Input foreground color | `--primary-text-color`
`--paper-input-container` | Mixin applied to the container | `{}`
`--paper-input-container-disabled` | Mixin applied to the container when it's disabled | `{}`
`--paper-input-container-label` | Mixin applied to the label | `{}`
`--paper-input-container-label-focus` | Mixin applied to the label when the input is focused | `{}`
`--paper-input-container-label-floating` | Mixin applied to the label when floating | `{}`
`--paper-input-container-input` | Mixin applied to the input | `{}`
`--paper-input-container-input-webkit-spinner` | Mixin applied to the webkit spinner | `{}`
`--paper-input-container-underline` | Mixin applied to the underline | `{}`
`--paper-input-container-underline-focus` | Mixin applied to the underline when the input is focused | `{}`
`--paper-input-container-underline-disabled` | Mixin applied to the underline when the input is disabled | `{}`
`--paper-input-prefix` | Mixin applied to the input prefix | `{}`
`--paper-input-suffix` | Mixin applied to the input suffix | `{}`

This element is `display:block` by default, but you can set the `inline` attribute to make it
`display:inline-block`.
-->

<dom-module id="paper-input-container" assetpath="../../../bower_components/paper-input/">
  <template>
    <style>
      :host {
        display: block;
        padding: 8px 0;

        @apply(--paper-input-container);
      }

      :host([inline]) {
        display: inline-block;
      }

      :host([disabled]) {
        pointer-events: none;
        opacity: 0.33;

        @apply(--paper-input-container-disabled);
      }

      :host([hidden]) {
        display: none !important;
      }

      .floated-label-placeholder {
        @apply(--paper-font-caption);
      }

      .underline {
        height: 2px;
        position: relative;
      }

      .focused-line {
        @apply(--layout-fit);

        border-bottom: 2px solid var(--paper-input-container-focus-color, --primary-color);

        -webkit-transform-origin: center center;
        transform-origin: center center;
        -webkit-transform: scale3d(0,1,1);
        transform: scale3d(0,1,1);

        @apply(--paper-input-container-underline-focus);
      }

      .underline.is-highlighted .focused-line {
        -webkit-transform: none;
        transform: none;
        -webkit-transition: -webkit-transform 0.25s;
        transition: transform 0.25s;

        @apply(--paper-transition-easing);
      }

      .underline.is-invalid .focused-line {
        border-color: var(--paper-input-container-invalid-color, --error-color);
        -webkit-transform: none;
        transform: none;
        -webkit-transition: -webkit-transform 0.25s;
        transition: transform 0.25s;

        @apply(--paper-transition-easing);
      }

      .unfocused-line {
        @apply(--layout-fit);

        border-bottom: 1px solid var(--paper-input-container-color, --secondary-text-color);

        @apply(--paper-input-container-underline);
      }

      :host([disabled]) .unfocused-line {
        border-bottom: 1px dashed;
        border-color: var(--paper-input-container-color, --secondary-text-color);

        @apply(--paper-input-container-underline-disabled);
      }

      .label-and-input-container {
        @apply(--layout-flex-auto);
        @apply(--layout-relative);

        width: 100%;
        max-width: 100%;
      }

      .input-content {
        @apply(--layout-horizontal);
        @apply(--layout-center);

        position: relative;
      }

      .input-content ::content label,
      .input-content ::content .paper-input-label {
        position: absolute;
        top: 0;
        right: 0;
        left: 0;
        width: 100%;
        font: inherit;
        color: var(--paper-input-container-color, --secondary-text-color);
        -webkit-transition: -webkit-transform 0.25s, width 0.25s;
        transition: transform 0.25s, width 0.25s;
        -webkit-transform-origin: left top;
        transform-origin: left top;

        @apply(--paper-font-common-nowrap);
        @apply(--paper-font-subhead);
        @apply(--paper-input-container-label);
        @apply(--paper-transition-easing);
      }

      .input-content.label-is-floating ::content label,
      .input-content.label-is-floating ::content .paper-input-label {
        -webkit-transform: translateY(-75%) scale(0.75);
        transform: translateY(-75%) scale(0.75);

        /* Since we scale to 75/100 of the size, we actually have 100/75 of the
        original space now available */
        width: 133%;

        @apply(--paper-input-container-label-floating);
      }

      :host-context([dir="rtl"]) .input-content.label-is-floating ::content label,
      :host-context([dir="rtl"]) .input-content.label-is-floating ::content .paper-input-label {
        /* TODO(noms): Figure out why leaving the width at 133% before the animation
         * actually makes
         * it wider on the right side, not left side, as you would expect in RTL */
        width: 100%;
        -webkit-transform-origin: right top;
        transform-origin: right top;
      }

      .input-content.label-is-highlighted ::content label,
      .input-content.label-is-highlighted ::content .paper-input-label {
        color: var(--paper-input-container-focus-color, --primary-color);

        @apply(--paper-input-container-label-focus);
      }

      .input-content.is-invalid ::content label,
      .input-content.is-invalid ::content .paper-input-label {
        color: var(--paper-input-container-invalid-color, --error-color);
      }

      .input-content.label-is-hidden ::content label,
      .input-content.label-is-hidden ::content .paper-input-label {
        visibility: hidden;
      }

      .input-content ::content input,
      .input-content ::content textarea,
      .input-content ::content iron-autogrow-textarea,
      .input-content ::content .paper-input-input {
        position: relative; /* to make a stacking context */
        outline: none;
        box-shadow: none;
        padding: 0;
        width: 100%;
        max-width: 100%;
        background: transparent;
        border: none;
        color: var(--paper-input-container-input-color, --primary-text-color);
        -webkit-appearance: none;
        text-align: inherit;
        vertical-align: bottom;

        @apply(--paper-font-subhead);
        @apply(--paper-input-container-input);
      }

      .input-content ::content input::-webkit-outer-spin-button,
      .input-content ::content input::-webkit-inner-spin-button {
        @apply(--paper-input-container-input-webkit-spinner);
      }

      ::content [prefix] {
        @apply(--paper-font-subhead);

        @apply(--paper-input-prefix);
        @apply(--layout-flex-none);
      }

      ::content [suffix] {
        @apply(--paper-font-subhead);

        @apply(--paper-input-suffix);
        @apply(--layout-flex-none);
      }

      /* Firefox sets a min-width on the input, which can cause layout issues */
      .input-content ::content input {
        min-width: 0;
      }

      .input-content ::content textarea {
        resize: none;
      }

      .add-on-content {
        position: relative;
      }

      .add-on-content.is-invalid ::content * {
        color: var(--paper-input-container-invalid-color, --error-color);
      }

      .add-on-content.is-highlighted ::content * {
        color: var(--paper-input-container-focus-color, --primary-color);
      }
    </style>

    <template is="dom-if" if="[[!noLabelFloat]]">
      <div class="floated-label-placeholder" aria-hidden="true">&nbsp;</div>
    </template>

    <div class$="[[_computeInputContentClass(noLabelFloat,alwaysFloatLabel,focused,invalid,_inputHasContent)]]">
      <content select="[prefix]" id="prefix"></content>

      <div class="label-and-input-container" id="labelAndInputContainer">
        <content select=":not([add-on]):not([prefix]):not([suffix])"></content>
      </div>

      <content select="[suffix]"></content>
    </div>

    <div class$="[[_computeUnderlineClass(focused,invalid)]]">
      <div class="unfocused-line"></div>
      <div class="focused-line"></div>
    </div>

    <div class$="[[_computeAddOnContentClass(focused,invalid)]]">
      <content id="addOnContent" select="[add-on]"></content>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-input-container',

    properties: {
      /**
       * Set to true to disable the floating label. The label disappears when the input value is
       * not null.
       */
      noLabelFloat: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to always float the floating label.
       */
      alwaysFloatLabel: {
        type: Boolean,
        value: false
      },

      /**
       * The attribute to listen for value changes on.
       */
      attrForValue: {
        type: String,
        value: 'bind-value'
      },

      /**
       * Set to true to auto-validate the input value when it changes.
       */
      autoValidate: {
        type: Boolean,
        value: false
      },

      /**
       * True if the input is invalid. This property is set automatically when the input value
       * changes if auto-validating, or when the `iron-input-validate` event is heard from a child.
       */
      invalid: {
        observer: '_invalidChanged',
        type: Boolean,
        value: false
      },

      /**
       * True if the input has focus.
       */
      focused: {
        readOnly: true,
        type: Boolean,
        value: false,
        notify: true
      },

      _addons: {
        type: Array
        // do not set a default value here intentionally - it will be initialized lazily when a
        // distributed child is attached, which may occur before configuration for this element
        // in polyfill.
      },

      _inputHasContent: {
        type: Boolean,
        value: false
      },

      _inputSelector: {
        type: String,
        value: 'input,textarea,.paper-input-input'
      },

      _boundOnFocus: {
        type: Function,
        value: function() {
          return this._onFocus.bind(this);
        }
      },

      _boundOnBlur: {
        type: Function,
        value: function() {
          return this._onBlur.bind(this);
        }
      },

      _boundOnInput: {
        type: Function,
        value: function() {
          return this._onInput.bind(this);
        }
      },

      _boundValueChanged: {
        type: Function,
        value: function() {
          return this._onValueChanged.bind(this);
        }
      }
    },

    listeners: {
      'addon-attached': '_onAddonAttached',
      'iron-input-validate': '_onIronInputValidate'
    },

    get _valueChangedEvent() {
      return this.attrForValue + '-changed';
    },

    get _propertyForValue() {
      return Polymer.CaseMap.dashToCamelCase(this.attrForValue);
    },

    get _inputElement() {
      return Polymer.dom(this).querySelector(this._inputSelector);
    },

    get _inputElementValue() {
      return this._inputElement[this._propertyForValue] || this._inputElement.value;
    },

    ready: function() {
      if (!this._addons) {
        this._addons = [];
      }
      this.addEventListener('focus', this._boundOnFocus, true);
      this.addEventListener('blur', this._boundOnBlur, true);
    },

    attached: function() {
      if (this.attrForValue) {
        this._inputElement.addEventListener(this._valueChangedEvent, this._boundValueChanged);
      } else {
        this.addEventListener('input', this._onInput);
      }

      // Only validate when attached if the input already has a value.
      if (this._inputElementValue != '') {
        this._handleValueAndAutoValidate(this._inputElement);
      } else {
        this._handleValue(this._inputElement);
      }
    },

    _onAddonAttached: function(event) {
      if (!this._addons) {
        this._addons = [];
      }
      var target = event.target;
      if (this._addons.indexOf(target) === -1) {
        this._addons.push(target);
        if (this.isAttached) {
          this._handleValue(this._inputElement);
        }
      }
    },

    _onFocus: function() {
      this._setFocused(true);
    },

    _onBlur: function() {
      this._setFocused(false);
      this._handleValueAndAutoValidate(this._inputElement);
    },

    _onInput: function(event) {
      this._handleValueAndAutoValidate(event.target);
    },

    _onValueChanged: function(event) {
      this._handleValueAndAutoValidate(event.target);
    },

    _handleValue: function(inputElement) {
      var value = this._inputElementValue;

      // type="number" hack needed because this.value is empty until it's valid
      if (value || value === 0 || (inputElement.type === 'number' && !inputElement.checkValidity())) {
        this._inputHasContent = true;
      } else {
        this._inputHasContent = false;
      }

      this.updateAddons({
        inputElement: inputElement,
        value: value,
        invalid: this.invalid
      });
    },

    _handleValueAndAutoValidate: function(inputElement) {
      if (this.autoValidate) {
        var valid;
        if (inputElement.validate) {
          valid = inputElement.validate(this._inputElementValue);
        } else {
          valid = inputElement.checkValidity();
        }
        this.invalid = !valid;
      }

      // Call this last to notify the add-ons.
      this._handleValue(inputElement);
    },

    _onIronInputValidate: function(event) {
      this.invalid = this._inputElement.invalid;
    },

    _invalidChanged: function() {
      if (this._addons) {
        this.updateAddons({invalid: this.invalid});
      }
    },

    /**
     * Call this to update the state of add-ons.
     * @param {Object} state Add-on state.
     */
    updateAddons: function(state) {
      for (var addon, index = 0; addon = this._addons[index]; index++) {
        addon.update(state);
      }
    },

    _computeInputContentClass: function(noLabelFloat, alwaysFloatLabel, focused, invalid, _inputHasContent) {
      var cls = 'input-content';
      if (!noLabelFloat) {
        var label = this.querySelector('label');

        if (alwaysFloatLabel || _inputHasContent) {
          cls += ' label-is-floating';
          // If the label is floating, ignore any offsets that may have been
          // applied from a prefix element.
          this.$.labelAndInputContainer.style.position = 'static';

          if (invalid) {
            cls += ' is-invalid';
          } else if (focused) {
            cls += " label-is-highlighted";
          }
        } else {
          // When the label is not floating, it should overlap the input element.
          if (label) {
            this.$.labelAndInputContainer.style.position = 'relative';
          }
        }
      } else {
        if (_inputHasContent) {
          cls += ' label-is-hidden';
        }
      }
      return cls;
    },

    _computeUnderlineClass: function(focused, invalid) {
      var cls = 'underline';
      if (invalid) {
        cls += ' is-invalid';
      } else if (focused) {
        cls += ' is-highlighted'
      }
      return cls;
    },

    _computeAddOnContentClass: function(focused, invalid) {
      var cls = 'add-on-content';
      if (invalid) {
        cls += ' is-invalid';
      } else if (focused) {
        cls += ' is-highlighted'
      }
      return cls;
    }
  });
</script>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
`<paper-input-error>` is an error message for use with `<paper-input-container>`. The error is
displayed when the `<paper-input-container>` is `invalid`.

    <paper-input-container>
      <input is="iron-input" pattern="[0-9]*">
      <paper-input-error>Only numbers are allowed!</paper-input-error>
    </paper-input-container>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-input-container-invalid-color` | The foreground color of the error | `--error-color`
`--paper-input-error`                   | Mixin applied to the error        | `{}`
-->

<dom-module id="paper-input-error" assetpath="../../../bower_components/paper-input/">
  <template>
    <style>
      :host {
        display: inline-block;
        visibility: hidden;

        color: var(--paper-input-container-invalid-color, --error-color);

        @apply(--paper-font-caption);
        @apply(--paper-input-error);
        position: absolute;
        left:0;
        right:0;
      }

      :host([invalid]) {
        visibility: visible;
      };
    </style>

    <content></content>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-input-error',

    behaviors: [
      Polymer.PaperInputAddonBehavior
    ],

    properties: {
      /**
       * True if the error is showing.
       */
      invalid: {
        readOnly: true,
        reflectToAttribute: true,
        type: Boolean
      }
    },

    /**
     * This overrides the update function in PaperInputAddonBehavior.
     * @param {{
     *   inputElement: (Element|undefined),
     *   value: (string|undefined),
     *   invalid: boolean
     * }} state -
     *     inputElement: The input element.
     *     value: The input value.
     *     invalid: True if the input value is invalid.
     */
    update: function(state) {
      this._setInvalid(state.invalid);
    }
  });
</script>
<dom-module id="paper-input" assetpath="../../../bower_components/paper-input/">
  <template>
    <style>
      :host {
        display: block;
      }

      :host([focused]) {
        outline: none;
      }

      :host([hidden]) {
        display: none !important;
      }

      input::-webkit-input-placeholder {
        color: var(--paper-input-container-color, --secondary-text-color);
      }

      input:-moz-placeholder {
        color: var(--paper-input-container-color, --secondary-text-color);
      }

      input::-moz-placeholder {
        color: var(--paper-input-container-color, --secondary-text-color);
      }

      input:-ms-input-placeholder {
        color: var(--paper-input-container-color, --secondary-text-color);
      }

      label {
        pointer-events: none;
      }
    </style>

    <paper-input-container no-label-float="[[noLabelFloat]]" always-float-label="[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]" auto-validate$="[[autoValidate]]" disabled$="[[disabled]]" invalid="[[invalid]]">

      <content select="[prefix]"></content>

      <label hidden$="[[!label]]" aria-hidden="true" for="input">[[label]]</label>

      <input is="iron-input" id="input" aria-labelledby$="[[_ariaLabelledBy]]" aria-describedby$="[[_ariaDescribedBy]]" disabled$="[[disabled]]" title$="[[title]]" bind-value="{{value}}" invalid="{{invalid}}" prevent-invalid-input="[[preventInvalidInput]]" allowed-pattern="[[allowedPattern]]" validator="[[validator]]" type$="[[type]]" pattern$="[[pattern]]" required$="[[required]]" autocomplete$="[[autocomplete]]" autofocus$="[[autofocus]]" inputmode$="[[inputmode]]" minlength$="[[minlength]]" maxlength$="[[maxlength]]" min$="[[min]]" max$="[[max]]" step$="[[step]]" name$="[[name]]" placeholder$="[[placeholder]]" readonly$="[[readonly]]" list$="[[list]]" size$="[[size]]" autocapitalize$="[[autocapitalize]]" autocorrect$="[[autocorrect]]" on-change="_onChange" tabindex$="[[tabindex]]" autosave$="[[autosave]]" results$="[[results]]" accept$="[[accept]]" multiple$="[[multiple]]">

      <content select="[suffix]"></content>

      <template is="dom-if" if="[[errorMessage]]">
        <paper-input-error aria-live="assertive">[[errorMessage]]</paper-input-error>
      </template>

      <template is="dom-if" if="[[charCounter]]">
        <paper-input-char-counter></paper-input-char-counter>
      </template>

    </paper-input-container>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-input',

    behaviors: [
      Polymer.IronFormElementBehavior,
      Polymer.PaperInputBehavior
    ]
  });
</script>
<!--
@license
Copyright (c) 2015 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
--><script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.combobox = vaadin.elements.combobox || {};

  /** @polymerBehavior vaadin.elements.combobox.DropdownBehavior */
  vaadin.elements.combobox.DropdownBehavior = {
    properties: {
      /**
       * True if the dropdown is open, false otherwise.
       */
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true,
        observer: '_openedChanged'
      },

      /**
       * Set to true to disable this element.
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * When present, it specifies that the element field is read-only.
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    },

    /**
     * Fired after the `vaadin-dropdown` opens.
     *
     * @event vaadin-dropdown-opened
     */
    /**
     * Fired after the `vaadin-dropdown` closes.
     *
     * @event vaadin-dropdown-closed
     */

    /**
     * Opens the dropdown list.
     */
    open: function() {
      // Prevent _open() being called when input is disabled or read-only
      if (!this.disabled && !this.readonly) {
        this.opened = true;
      }
    },

    /**
     * Closes the dropdown list.
     */
    close: function() {
      this.opened = false;
    },

    detached: function() {
      // Making sure the overlay is closed and removed from DOM after detaching the dropdown.
      this.close();
    },

    _openedChanged: function(value, old) {
      // Prevent _close() being called when opened is set to its default value (false).
      if (old === undefined) {
        return;
      }

      if (this.opened) {
        this._open();
      } else {
        this._close();
      }
    },

    _open: function() {
      this.$.overlay._moveTo(document.body);

      this._addOutsideClickListener();

      // For touch devices, we don't want to popup virtual keyboard on touch devices unless input
      // is explicitly focused by the user.
      if (!this.$.overlay.touchDevice) {
        // If the inputElement is a paper-input, it would trigger an
        // unnecessary blur event on focus. Check to see if there is a
        // focused property and if it's already true.
        // See also https://github.com/PolymerElements/paper-input/issues/341
        if (!this.inputElement.focused) {
          this.inputElement.focus();
        }
      }

      this.fire('vaadin-dropdown-opened');
    },

    _close: function() {
      this.$.overlay._moveTo(this.root);

      this._removeOutsideClickListener();

      this.fire('vaadin-dropdown-closed');
    },

    // We need to listen on 'click' / 'tap' event and capture it and close the overlay before
    // propagating the event to the listener in the button. Otherwise, if the clicked button would call
    // open(), this would happen: https://www.youtube.com/watch?v=Z86V_ICUCD4
    _outsideClickListener: function(event) {
      var eventPath = Polymer.dom(event).path;
      if (eventPath.indexOf(this) < 0 && eventPath.indexOf(this.$.overlay) < 0) {
        this.opened = false;
      }
    },

    _addOutsideClickListener: function() {
      // With desktop mouse, 'click' will make Polymer to fire 'tap' event.
      // With touch devices, 'touchend' will make Polymer to fire 'tap' event, but browser will also fire 'click'.
      // So, 'click' and 'tap' can come in any order and we need to make sure that the first one fired will close the overlay.
      if (this.$.overlay.touchDevice) {
        Polymer.Gestures.add(document, 'tap', null);
        document.addEventListener('tap', this._outsideClickListener.bind(this), true);
      } else {
        document.addEventListener('click', this._outsideClickListener.bind(this), true);
      }
    },

    _removeOutsideClickListener: function() {
      if (this.$.overlay.touchDevice) {
        // Not sure if this is a good idea to remove this Gesture globally, but that's how the iron-overlay-behavior does it.
        Polymer.Gestures.remove(document, 'tap', null);
        document.removeEventListener('tap', this._outsideClickListener.bind(this), true);
      } else {
        document.removeEventListener('click', this._outsideClickListener.bind(this), true);
      }
    }
  };
</script>
<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.combobox = vaadin.elements.combobox || {};

  /** @polymerBehavior vaadin.elements.combobox.ComboBoxBehavior */
  vaadin.elements.combobox.ComboBoxBehaviorImpl = {
    properties: {
      /**
       * A full set of items to filter the visible options from.
       * The items can be of either `String` or `Object` type.
       */
      items: {
        type: Array
      },

      /**
       * If `true`, the user can input a value that is not present in the items list.
       * `value` property will be set to the input value in this case.
       * Also, when `value` is set programmatically, the input value will be set
       * to reflect that value.
       */
      allowCustomValue: {
        type: Boolean,
        value: false
      },

      /**
       * A subset of items, filtered based on the user input. Filtered items
       * can be assigned directly to omit the internal filtering functionality.
       * The items can be of either `String` or `Object` type.
       */
      filteredItems: {
        type: Array
      },

      /**
       * The `String` value for the selected item of the combo box. Provides
       * the value for `iron-form`.
       *
       * When there’s no item selected, the value is an empty string.
       *
       * Use `selectedItem` property to get the raw selected item from
       * the `items` array.
       */
      value: {
        type: String,
        observer: '_valueChanged',
        // notify: true already set in IronFormBehavior, setting this to true will make two value-changed events(?)
        notify: false
      },

      /**
       * A read-only property indicating whether this combo box has a value
       * selected or not. It can be used for example in styling of the component.
       */
      hasValue: {
        type: Boolean,
        value: false,
        readOnly: true,
        reflectToAttribute: true
      },

      /*
       * When set to `true`, a loading spinner is displayed on top of the list of options.
       */
      loading: {
        type: Boolean,
        value: false
      },

      _focusedIndex: {
        type: Number,
        value: -1
      },

      /**
       * Filtering string the user has typed into the input field.
       */
      filter: {
        type: String,
        value: '',
        notify: true
      },

      /**
       * The selected item from the `items` array.
       */
      selectedItem: {
        type: Object,
        notify: true,
        value: function() {
          return null;
        }
      },

      /**
       * Path for label of the item. If `items` is an array of objects, the
       * `itemLabelPath` is used to fetch the displayed string label for each
       * item.
       *
       * The item label is also used for matching items when processing user
       * input, i.e., for filtering and selecting items.
       *
       * When using item templates, the property is still needed because it is used
       * for filtering, and for displaying the selected item value in the input box.
       */
      itemLabelPath: {
        type: String,
        value: 'label'
      },

      /**
       * Path for the value of the item. If `items` is an array of objects, the
       * `itemValuePath:` is used to fetch the string value for the selected
       * item.
       *
       * The item value is used in the `value` property of the combo box,
       * to provide the form value.
       */
      itemValuePath: {
        type: String,
        value: 'value'
      },

      /**
       * Returns a reference to the input element.
       */
      inputElement: {
        type: HTMLElement,
        readOnly: true
      },
      _toggleElement: Object,
      _clearElement: Object,

      _inputElementValue: String,

      _closeOnBlurIsPrevented: Boolean,

      _templatized: Boolean,
      _itemTemplate: Boolean,

      _previousDocumentPointerEvents: String
    },

    observers: [
      '_filterChanged(filter, itemValuePath, itemLabelPath)',
      '_itemsChanged(items.*, itemValuePath, itemLabelPath)',
      '_filteredItemsChanged(filteredItems.*, itemValuePath, itemLabelPath)',
      '_loadingChanged(loading)',
      '_selectedItemChanged(selectedItem)'
    ],

    listeners: {
      'vaadin-dropdown-opened': '_onOpened',
      'vaadin-dropdown-closed': '_onClosed',
      'keydown': '_onKeyDown',
      'tap': '_onTap',
      'overlay.selection-changed': '_overlaySelectedItemChanged'
    },

    ready: function() {
      // The value property is also defined in IronFormElementBehavior, which
      // will mix up the default value if set in the property.
      if (this.value === undefined) {
        this.value = '';
      }
      Polymer.IronA11yAnnouncer.requestAvailability();
    },

    _onBlur: function() {
      if (!this._closeOnBlurIsPrevented) {
        this.close();
      }
    },

    _onOverlayDown: function(event) {
      if (this.$.overlay.touchDevice && event.target !== this.$.overlay.$.scroller) {
        // On touch devices, blur the input on touch start inside the overlay, in order to hide
        // the virtual keyboard. But don't close the overlay on this blur.
        this._closeOnBlurIsPrevented = true;
        this.inputElement.blur();
        this._closeOnBlurIsPrevented = false;
      }
    },

    _onTap: function(e) {
      this._closeOnBlurIsPrevented = true;

      var path = Polymer.dom(e).path;
      if (path.indexOf(this._clearElement) !== -1) {
        this._clear();
      } else if (path.indexOf(this._toggleElement) !== -1) {
        this._toggle();
      } else if (path.indexOf(this.inputElement) !== -1) {
        this._openAsync();
      }

      this._closeOnBlurIsPrevented = false;
    },

    /**
     * Keyboard navigation
     */

    _onKeyDown: function(e) {
      if (this._isEventKey(e, 'down')) {
        this._closeOnBlurIsPrevented = true;
        this._onArrowDown();
        this._closeOnBlurIsPrevented = false;

        // prevent caret from moving
        e.preventDefault();
      } else if (this._isEventKey(e, 'up')) {
        this._closeOnBlurIsPrevented = true;
        this._onArrowUp();
        this._closeOnBlurIsPrevented = false;

        // prevent caret from moving
        e.preventDefault();
      } else if (this._isEventKey(e, 'enter')) {
        this._onEnter(e);
      } else if (this._isEventKey(e, 'esc')) {
        this._onEscape();
      }
    },

    _isEventKey: function(e, k) {
      return Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(e, k);
    },

    _getItemLabel: function(item) {
      return this.$.overlay.getItemLabel(item);
    },

    _getItemValue: function(item) {
      var value = item ? this.get(this.itemValuePath, item) : undefined;
      if (value === undefined) {
        value = item ? item.toString() : '';
      }
      return value;
    },

    _onArrowDown: function() {
      if (this.opened) {
        if (this.$.overlay._items) {
          this._focusedIndex = Math.min(this.$.overlay._items.length - 1, this._focusedIndex + 1);
          this._prefillFocusedItemLabel();
        }
      } else {
        this.open();
      }
    },

    _onArrowUp: function() {
      if (this.opened) {
        if (this._focusedIndex > -1) {
          this._focusedIndex = Math.max(0, this._focusedIndex - 1);
        } else {
          if (this.$.overlay._items) {
            this._focusedIndex = this.$.overlay._items.length - 1;
          }
        }

        this._prefillFocusedItemLabel();
      } else {
        this.open();
      }
    },

    _prefillFocusedItemLabel: function() {
      if (this._focusedIndex > -1) {
        // Reset the input value asyncronously to prevent partial value changes
        // announce. Makes OSX VoiceOver to announce the complete value instead.
        this._inputElementValue = '';
        this.async(function() {
          this._inputElementValue = this._getItemLabel(this.$.overlay._focusedItem);
          this._setSelectionRange();
        }, 1); // 1ms delay needed for OSX VoiceOver to realise input value was reset
      }
    },

    _setSelectionRange: function() {
      if (this.inputElement.setSelectionRange) {
        this.inputElement.setSelectionRange(0, this._inputElementValue.length);
      }
    },

    _onEnter: function(e) {
      // should close on enter when custom values are allowed, input field is cleared, or when an existing
      // item is focused with keyboard.
      if (this.opened && (this.allowCustomValue || this._inputElementValue === '' || this._focusedIndex > -1)) {
        this.close();

        // Do not submit the surrounding form.
        e.preventDefault();
      }
    },

    _onEscape: function() {
      if (this.opened) {
        if (this._focusedIndex > -1) {
          this._focusedIndex = -1;
          this._revertInputValue();
        } else {
          this.cancel();
        }
      }
    },

    /**
     * Opening and closing related functionality
     */

    /**
     * Opens the dropdown list asynchronously.
     */
    _openAsync: function() {
      // Needed for MS Edge. Otherwise, it does not pop the virtual keyboard up
      // when tapping the combobox that has non-empty value.
      this.async(this.open);
    },

    /**
     * Opens and closes the dropdown list.
     */
    _toggle: function() {
      if (this.opened) {
        this.close();
      } else {
        this.open();
      }
    },

    /**
     * Clears the current value.
     */
    _clear: function() {
      this.selectedItem = null;

      if (this.allowCustomValue) {
        this.value = '';
      }

      this.close();
    },

    /**
     * Reverts back to original value.
     */
    cancel: function() {
      this._revertInputValueToValue();
      this.close();
    },

    _onOpened: function() {
      this.$.overlay.hidden = !this._hasItems(this.$.overlay._items) && !this.loading;

      // With iron-list v1.3.9, calling `notifyResize()` no longer renders
      // the items synchonously. It is required to have the items rendered
      // before we update the overlay and the list positions and sizes.
      this.$.overlay.ensureItemsRendered();

      // Ensure metrics are up-to-date
      this.$.overlay.updateViewportBoundaries();
      this.$.overlay.async(this.$.overlay.adjustScrollPosition);
      this.$.overlay.async(this.$.overlay.notifyResize, 1);

      // Set body pointer-events to 'none' to disable mouse interactions with
      // other document nodes (combo-box is "modal")
      this._previousDocumentPointerEvents = document.body.style.pointerEvents;
      document.body.style.pointerEvents = 'none';
    },

    _onClosed: function() {
      if (this._focusedIndex > -1) {
        var focusedItem = this.$.overlay._items[this._focusedIndex];
        if (this.selectedItem !== focusedItem) {
          this.selectedItem = focusedItem;
        }
        // make sure input field is updated in case value doesn't change (i.e. FOO -> foo)
        this._inputElementValue = this._getItemLabel(this.selectedItem);
      } else if (this._inputElementValue === '') {
        this._clear();
      } else {
        if (this.allowCustomValue) {
          var e = this.fire('custom-value-set', this._inputElementValue, {cancelable: true});
          if (!e.defaultPrevented) {
            var customValue = this._inputElementValue;
            this.selectedItem = null;
            this.value = customValue;
          }
        } else {
          this._inputElementValue = this._getItemLabel(this.selectedItem);
        }
      }

      this._clearSelectionRange();

      this.filter = '';

      document.body.style.pointerEvents = this._previousDocumentPointerEvents;
    },

    /**
     *  Filtering and items handling
     */
    _inputValueChanged: function(e) {
      // Handle only input events from our inputElement.
      if (Polymer.dom(e).path.indexOf(this.inputElement) !== -1) {
        if (this.filter === this._inputElementValue) {
          // Filter and input value might get out of sync, while keyboard navigating for example.
          // Afterwards, input value might be changed to the same value as used in filtering.
          // In situation like these, we need to make sure all the filter changes handlers are run.
          this._filterChanged(this.filter);
        } else {
          this._userDefinedFilter = true;
          this.filter = this._inputElementValue;
          this._userDefinedFilter = false;
        }

        if (!this.opened) {
          this.open();
        }
      }
    },

    _clearSelectionRange: function() {
      // Setting selection range focuses and/or moves the caret in some browsers,
      // and there's no need to modify the selection range if the input isn't focused anyway.
      if (document.activeElement === this.inputElement && this.inputElement.setSelectionRange) {
        var caretIndex = this._inputElementValue ? this._inputElementValue.length : 0;
        this.inputElement.setSelectionRange(caretIndex, caretIndex);
      }
    },

    _filterChanged: function(filter) {
      if (this.items) {
        this.filteredItems = this._filterItems(this.items, filter);
      }
    },

    _loadingChanged: function(loading) {
      if (loading) {
        this._focusedIndex = -1;
      }
    },

    _revertInputValue: function() {
      if (this.filter !== '') {
        this._inputElementValue = this.filter;
      } else {
        this._revertInputValueToValue();
      }

      this._clearSelectionRange();
    },

    _revertInputValueToValue: function() {
      if (this.allowCustomValue && !this.selectedItem) {
        this._inputElementValue = this.value;
      } else {
        this._inputElementValue = this._getItemLabel(this.selectedItem);
      }
    },

    _selectedItemChanged: function(selectedItem) {
      if (!this.filteredItems) {
        return;
      }

      if (selectedItem === null) {
        if (!this.allowCustomValue) {
          this.value = '';
        }

        this._setHasValue(this.value !== '');
        this._inputElementValue = this.value;
      } else {
        var value = this._getItemValue(selectedItem);
        if (this.value !== value) {
          this.value = value;
        }

        this._setHasValue(true);
        this._inputElementValue = this._getItemLabel(selectedItem);
      }

      this.$.overlay._selectedItem = selectedItem;
      this._focusedIndex = this.filteredItems.indexOf(selectedItem);
    },

    _valueChanged: function(value) {
      if (this._isValidValue(value)) {
        if (this._getItemValue(this.selectedItem) !== value) {
          var valueIndex = this._indexOfValue(value, this.filteredItems);
          this.selectedItem = valueIndex >= 0 ? this.filteredItems[valueIndex] : null;
        } else {
          var item = this.selectedItem;
        }

        if (!item && this.allowCustomValue) {
          this._inputElementValue = value;
        }

        this._setHasValue(this.value !== '');
      } else {
        this.selectedItem = null;
      }

      this.fire('change', undefined, {bubbles: true});
    },

    _itemsChanged: function(e) {
      if (e.path === 'items' || e.path === 'items.splices') {
        this.filteredItems = this.items ? this.items.slice(0) : this.items;

        var valueIndex = this._indexOfValue(this.value, this.items);
        this._focusedIndex = valueIndex;

        var item = valueIndex > -1 && this.items[valueIndex];
        if (item) {
          this.selectedItem = item;
        }
      }
    },

    _filteredItemsChanged: function(e) {
      if (e.path === 'filteredItems' || e.path === 'filteredItems.splices') {
        this._setOverlayItems(this.filteredItems);

        this._focusedIndex = (this.opened || this._userDefinedFilter) ?
            this.$.overlay.indexOfLabel(this.filter) :
            this._indexOfValue(this.value, this.filteredItems);

        // async needed to reposition correctly after filtering
        // (especially when aligned on top of input)
        this.async(function() {
          this.$.overlay.notifyResize();
        }, 1);
      }
    },

    _filterItems: function(arr, filter) {
      if (!arr) {
        return arr;
      }

      return arr.filter((function(item) {
        filter = filter ? filter.toString().toLowerCase() : '';

        // Check if item contains input value.
        return this._getItemLabel(item).toString().toLowerCase()
          .indexOf(filter) > -1;
      }).bind(this));
    },

    _setOverlayItems: function(items) {
      // TODO: There is something wrong with observers and using set function
      // see here: https://github.com/Polymer/polymer/issues/3254
      // As a workaround setting/notifying the observer with the value undefined helps
      this.$.overlay.notifyPath('_items', undefined);
      this.$.overlay.set('_items', items);

      this.$.overlay.hidden = !this._hasItems(items);
      this.$.overlay.notifyResize();
    },

    _hasItems: function(array) {
      return array && array.length;
    },

    _indexOfValue: function(value, items) {
      if (items && this._isValidValue(value)) {
        for (var i = 0; i < items.length; i++) {
          if (this._getItemValue(items[i]) === value) {
            return i;
          }
        }
      }

      return -1;
    },

    /**
     * Checks if the value is supported as an item value in this control.
     *
     * @return {boolean}
     */
    _isValidValue: function(value) {
      return value !== undefined && value !== null;
    },

    _overlaySelectedItemChanged: function(event, detail) {
      if (this.selectedItem !== detail.item) {
        this.selectedItem = detail.item;
      }

      if (this.opened) {
        this.close();
      }

      // stop this private event from leaking outside.
      event.stopPropagation();
    },

    /**
     * Validates the input element and sets an error style if needed.
     *
     * @return {boolean}
     */
    _getValidity: function() {
      if (this.inputElement.validate) {
        return this.inputElement.validate();
      }
    },

    get _instanceProps() {
      return {
        item: true,
        index: true,
        selected: true,
        focused: true
      };
    },

    _ensureTemplatized: function() {
      if (!this._templatized) {
        this._templatized = true;
        this._itemTemplate = Polymer.dom(this).querySelector('template');
        if (this._itemTemplate) {
          this.templatize(this._itemTemplate);
        }
      }
    },

    _forwardParentProp: function(prop, value) {
      var items = this.$.overlay.$.selector.querySelectorAll('vaadin-combo-box-item');
      Array.prototype.forEach.call(items, function(item) {
        item._itemTemplateInstance[prop] = value;
      });
    },

    _forwardParentPath: function(path, value) {
      var items = this.$.overlay.$.selector.querySelectorAll('vaadin-combo-box-item');
      Array.prototype.forEach.call(items, function(item) {
        item._itemTemplateInstance.notifyPath(path, value, true);
      });
    },

    _preventInputBlur: function() {
      if (this._toggleElement) {
        this.listen(this._toggleElement, 'down', '_preventDefault');
      }
      if (this._clearElement) {
        this.listen(this._clearElement, 'down', '_preventDefault');
      }
    },

    _restoreInputBlur: function() {
      if (this._toggleElement) {
        this.unlisten(this._toggleElement, 'down', '_preventDefault');
      }
      if (this._clearElement) {
        this.unlisten(this._clearElement, 'down', '_preventDefault');
      }
    },

    _preventDefault: function(e) {
      e.preventDefault();
    },

    _stopPropagation: function(e) {
      e.stopPropagation();
    }
  };

  /** @polymerBehavior vaadin.elements.combobox.ComboBoxBehavior */
  vaadin.elements.combobox.ComboBoxBehavior = [
    Polymer.IronFormElementBehavior,
    Polymer.Templatizer,
    vaadin.elements.combobox.DropdownBehavior,
    vaadin.elements.combobox.ComboBoxBehaviorImpl
  ];

  /**
   * Fired when the value changes.
   *
   * @event value-changed
   * @param {Object} detail
   *  @param {String} detail.value the combobox value
   */

  /**
   * Fired when selected item changes.
   *
   * @event selected-item-changed
   * @param {Object} detail
   *  @param {Object|String} detail.value the selected item. Type is the same as the type of `items`.
   */

  /**
   * Fired when the user sets a custom value.
   * @event custom-value-set
   * @param {String} detail the custom value
   */

  /**
   * Fired when value changes.
   * To comply with https://developer.mozilla.org/en-US/docs/Web/Events/change
   * @event change
   */
</script><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--

`iron-list` displays a virtual, 'infinite' list. The template inside
the iron-list element represents the DOM to create for each list item.
The `items` property specifies an array of list item data.

For performance reasons, not every item in the list is rendered at once;
instead a small subset of actual template elements *(enough to fill the viewport)*
are rendered and reused as the user scrolls. As such, it is important that all
state of the list template be bound to the model driving it, since the view may
be reused with a new model at any time. Particularly, any state that may change
as the result of a user interaction with the list item must be bound to the model
to avoid view state inconsistency.

### Sizing iron-list

`iron-list` must either be explicitly sized, or delegate scrolling to an
explicitly sized parent. By "explicitly sized", we mean it either has an explicit
CSS `height` property set via a class or inline style, or else is sized by other
layout means (e.g. the `flex` or `fit` classes).

#### Flexbox - [jsbin](http://jsbin.com/kokaki/edit?html,output)

```html
<template is="x-list">
  <style>
    :host {
      display: block;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    iron-list {
      flex: 1 1 auto;
    }
  </style>

  <app-toolbar>App name</app-toolbar>
  <iron-list items="[[items]]">
    <template>
      ...
    </template>
  </iron-list>
</template>
```
#### Explicit size - [jsbin](http://jsbin.com/pibefo/edit?html,output)
```html
<template is="x-list">
  <style>
    :host {
      display: block;
    }

    iron-list {
      height: 100vh; /* don't use % values unless the parent element is sized. */
    }
  </style>
  <iron-list items="[[items]]">
    <template>
      ...
    </template>
  </iron-list>
</template>
```
#### Main document scrolling - [jsbin](http://jsbin.com/cojuli/edit?html,output)
```html
<head>
  <style>
    body {
      height: 100vh;
      margin: 0;
      display: flex;
      flex-direction: column;
    }

    app-toolbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
    }

    iron-list {
      /* add padding since the app-toolbar is fixed at the top */
      padding-top: 64px;
    }
  </style>
</head>
<body>
  <template is="dom-bind">
    <app-toolbar>App name</app-toolbar>
    <iron-list scroll-target="document" items="[[items]]">
      <template>
        ...
      </template>
    </iron-list>
  </template>
</body>
```

### Template model

List item templates should bind to template models of the following structure:

```js
{
  index: 0,        // index in the item array
  selected: false, // true if the current item is selected
  tabIndex: -1,    // a dynamically generated tabIndex for focus management
  item: {}         // user data corresponding to items[index]
}
```

Alternatively, you can change the property name used as data index by changing the
`indexAs` property. The `as` property defines the name of the variable to add to the binding
scope for the array.

For example, given the following `data` array:

##### data.json

```js
[
  {"name": "Bob"},
  {"name": "Tim"},
  {"name": "Mike"}
]
```

The following code would render the list (note the name and checked properties are
bound from the model object provided to the template scope):

```html
<template is="dom-bind">
  <iron-ajax url="data.json" last-response="{{data}}" auto></iron-ajax>
  <iron-list items="[[data]]" as="item">
    <template>
      <div>
        Name: [[item.name]]
      </div>
    </template>
  </iron-list>
</template>
```

### Grid layout

`iron-list` supports a grid layout in addition to linear layout by setting
the `grid` attribute.  In this case, the list template item must have both fixed
width and height (e.g. via CSS). Based on this, the number of items
per row are determined automatically based on the size of the list viewport.

### Accessibility

`iron-list` automatically manages the focus state for the items. It also provides
a `tabIndex` property within the template scope that can be used for keyboard navigation.
For example, users can press the up and down keys to move to previous and next
items in the list:

```html
<iron-list items="[[data]]" as="item">
  <template>
    <div tabindex$="[[tabIndex]]">
      Name: [[item.name]]
    </div>
  </template>
</iron-list>
```

### Styling

You can use the `--iron-list-items-container` mixin to style the container of items:

```css
iron-list {
 --iron-list-items-container: {
    margin: auto;
  };
}
```

### Resizing

`iron-list` lays out the items when it receives a notification via the `iron-resize` event.
This event is fired by any element that implements `IronResizableBehavior`.

By default, elements such as `iron-pages`, `paper-tabs` or `paper-dialog` will trigger
this event automatically. If you hide the list manually (e.g. you use `display: none`)
you might want to implement `IronResizableBehavior` or fire this event manually right
after the list became visible again. For example:

```js
document.querySelector('iron-list').fire('iron-resize');
```

### When should `<iron-list>` be used?

`iron-list` should be used when a page has significantly more DOM nodes than the ones
visible on the screen. e.g. the page has 500 nodes, but only 20 are visible at the time.
This is why we refer to it as a `virtual` list. In this case, a `dom-repeat` will still
create 500 nodes which could slow down the web app, but `iron-list` will only create 20.

However, having an `iron-list` does not mean that you can load all the data at once.
Say, you have a million records in the database, you want to split the data into pages
so you can bring a page at the time. The page could contain 500 items, and iron-list
will only render 20.

@group Iron Element
@element iron-list
@demo demo/index.html

-->

<dom-module id="iron-list" assetpath="../../../bower_components/iron-list/">
  <template>
    <style>
      :host {
        display: block;
      }

      @media only screen and (-webkit-max-device-pixel-ratio: 1) {
        :host {
          will-change: transform;
        }
      }

      #items {
        @apply(--iron-list-items-container);
        position: relative;
      }

      :host(:not([grid])) #items > ::content > * {
        width: 100%;
      }

      #items > ::content > * {
        box-sizing: border-box;
        margin: 0;
        position: absolute;
        top: 0;
        will-change: transform;
      }
    </style>

    <array-selector id="selector" items="{{items}}" selected="{{selectedItems}}" selected-item="{{selectedItem}}">
    </array-selector>

    <div id="items">
      <content></content>
    </div>

  </template>
</dom-module>

<script>

(function() {

  var IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
  var IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;
  var DEFAULT_PHYSICAL_COUNT = 3;
  var HIDDEN_Y = '-10000px';
  var ITEM_WIDTH = 0;
  var ITEM_HEIGHT = 1;
  var SECRET_TABINDEX = -100;

  Polymer({

    is: 'iron-list',

    properties: {

      /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */
      items: {
        type: Array
      },

      /**
       * The max count of physical items the pool can extend to.
       */
      maxPhysicalCount: {
        type: Number,
        value: 500
      },

      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: 'item'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * for the row.
       */
      indexAs: {
        type: String,
        value: 'index'
      },

      /**
       * The name of the variable to add to the binding scope to indicate
       * if the row is selected.
       */
      selectedAs: {
        type: String,
        value: 'selected'
      },

      /**
       * When true, the list is rendered as a grid. Grid items must have
       * fixed width and height set via CSS. e.g.
       *
       * ```html
       * <iron-list grid>
       *   <template>
       *      <div style="width: 100px; height: 100px;"> 100x100 </div>
       *   </template>
       * </iron-list>
       * ```
       */
      grid: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * When true, tapping a row will select the item, placing its data model
       * in the set of selected items retrievable via the selection property.
       *
       * Note that tapping focusable elements within the list item will not
       * result in selection, since they are presumed to have their * own action.
       */
      selectionEnabled: {
        type: Boolean,
        value: false
      },

      /**
       * When `multiSelection` is false, this is the currently selected item, or `null`
       * if no item is selected.
       */
      selectedItem: {
        type: Object,
        notify: true
      },

      /**
       * When `multiSelection` is true, this is an array that contains the selected items.
       */
      selectedItems: {
        type: Object,
        notify: true
      },

      /**
       * When `true`, multiple items may be selected at once (in this case,
       * `selected` is an array of currently selected items).  When `false`,
       * only one item may be selected at a time.
       */
      multiSelection: {
        type: Boolean,
        value: false
      },

      /**
       * The offset top from the scrolling element to the iron-list element.
       * This value can be computed using the position returned by `getBoundingClientRect()`
       * although it's preferred to use a constant value when possible.
       *
       * This property is useful when an external scrolling element is used and there's
       * some offset between the scrolling element and the list.
       * For example: a header is placed above the list.
       */
      scrollOffset: {
        type: Number,
        value: 0
      }
    },

    observers: [
      '_itemsChanged(items.*)',
      '_selectionEnabledChanged(selectionEnabled)',
      '_multiSelectionChanged(multiSelection)',
      '_setOverflow(scrollTarget, scrollOffset)'
    ],

    behaviors: [
      Polymer.Templatizer,
      Polymer.IronResizableBehavior,
      Polymer.IronA11yKeysBehavior,
      Polymer.IronScrollTargetBehavior
    ],

    keyBindings: {
      'up': '_didMoveUp',
      'down': '_didMoveDown',
      'enter': '_didEnter'
    },

    /**
     * The ratio of hidden tiles that should remain in the scroll direction.
     * Recommended value ~0.5, so it will distribute tiles evely in both directions.
     */
    _ratio: 0.5,

    /**
     * The padding-top value for the list.
     */
    _scrollerPaddingTop: 0,

    /**
     * This value is the same as `scrollTop`.
     */
    _scrollPosition: 0,

    /**
     * The sum of the heights of all the tiles in the DOM.
     */
    _physicalSize: 0,

    /**
     * The average `offsetHeight` of the tiles observed till now.
     */
    _physicalAverage: 0,

    /**
     * The number of tiles which `offsetHeight` > 0 observed until now.
     */
    _physicalAverageCount: 0,

    /**
     * The Y position of the item rendered in the `_physicalStart`
     * tile relative to the scrolling list.
     */
    _physicalTop: 0,

    /**
     * The number of items in the list.
     */
    _virtualCount: 0,

    /**
     * A map between an item key and its physical item index
     */
    _physicalIndexForKey: null,

    /**
     * The estimated scroll height based on `_physicalAverage`
     */
    _estScrollHeight: 0,

    /**
     * The scroll height of the dom node
     */
    _scrollHeight: 0,

    /**
     * The height of the list. This is referred as the viewport in the context of list.
     */
    _viewportHeight: 0,

    /**
     * The width of the list. This is referred as the viewport in the context of list.
     */
    _viewportWidth: 0,

    /**
     * An array of DOM nodes that are currently in the tree
     * @type {?Array<!TemplatizerNode>}
     */
    _physicalItems: null,

    /**
     * An array of heights for each item in `_physicalItems`
     * @type {?Array<number>}
     */
    _physicalSizes: null,

    /**
     * A cached value for the first visible index.
     * See `firstVisibleIndex`
     * @type {?number}
     */
    _firstVisibleIndexVal: null,

    /**
     * A cached value for the last visible index.
     * See `lastVisibleIndex`
     * @type {?number}
     */
    _lastVisibleIndexVal: null,

    /**
     * A Polymer collection for the items.
     * @type {?Polymer.Collection}
     */
    _collection: null,

    /**
     * The max number of pages to render. One page is equivalent to the height of the list.
     */
    _maxPages: 2,

    /**
     * The currently focused physical item.
     */
    _focusedItem: null,

    /**
     * The index of the `_focusedItem`.
     */
    _focusedIndex: -1,

    /**
     * The the item that is focused if it is moved offscreen.
     * @private {?TemplatizerNode}
     */
    _offscreenFocusedItem: null,

    /**
     * The item that backfills the `_offscreenFocusedItem` in the physical items
     * list when that item is moved offscreen.
     */
    _focusBackfillItem: null,

    /**
     * The maximum items per row
     */
    _itemsPerRow: 1,

    /**
     * The width of each grid item
     */
    _itemWidth: 0,

    /**
     * The height of the row in grid layout.
     */
    _rowHeight: 0,

    /**
     * The cost of stamping a template in ms.
     */
    _templateCost: 0,

    /**
     * The bottom of the physical content.
     */
    get _physicalBottom() {
      return this._physicalTop + this._physicalSize;
    },

    /**
     * The bottom of the scroll.
     */
    get _scrollBottom() {
      return this._scrollPosition + this._viewportHeight;
    },

    /**
     * The n-th item rendered in the last physical item.
     */
    get _virtualEnd() {
      return this._virtualStart + this._physicalCount - 1;
    },

    /**
     * The height of the physical content that isn't on the screen.
     */
    get _hiddenContentSize() {
      var size = this.grid ? this._physicalRows * this._rowHeight : this._physicalSize;
      return size - this._viewportHeight;
    },

    /**
     * The parent node for the _userTemplate.
     */
    get _itemsParent() {
      return Polymer.dom(Polymer.dom(this._userTemplate).parentNode);
    },

    /**
     * The maximum scroll top value.
     */
    get _maxScrollTop() {
      return this._estScrollHeight - this._viewportHeight + this._scrollOffset;
    },

    /**
     * The lowest n-th value for an item such that it can be rendered in `_physicalStart`.
     */
    _minVirtualStart: 0,

    /**
     * The largest n-th value for an item such that it can be rendered in `_physicalStart`.
     */
    get _maxVirtualStart() {
      return Math.max(0, this._virtualCount - this._physicalCount);
    },

    /**
     * The n-th item rendered in the `_physicalStart` tile.
     */
    _virtualStartVal: 0,

    set _virtualStart(val) {
      this._virtualStartVal = Math.min(this._maxVirtualStart, Math.max(this._minVirtualStart, val));
    },

    get _virtualStart() {
      return this._virtualStartVal || 0;
    },

    /**
     * The k-th tile that is at the top of the scrolling list.
     */
    _physicalStartVal: 0,

    set _physicalStart(val) {
      this._physicalStartVal = val % this._physicalCount;
      if (this._physicalStartVal < 0) {
        this._physicalStartVal = this._physicalCount + this._physicalStartVal;
      }
      this._physicalEnd = (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
    },

    get _physicalStart() {
      return this._physicalStartVal || 0;
    },

    /**
     * The number of tiles in the DOM.
     */
    _physicalCountVal: 0,

    set _physicalCount(val) {
      this._physicalCountVal = val;
      this._physicalEnd = (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
    },

    get _physicalCount() {
      return this._physicalCountVal;
    },

    /**
     * The k-th tile that is at the bottom of the scrolling list.
     */
    _physicalEnd: 0,

    /**
     * An optimal physical size such that we will have enough physical items
     * to fill up the viewport and recycle when the user scrolls.
     *
     * This default value assumes that we will at least have the equivalent
     * to a viewport of physical items above and below the user's viewport.
     */
    get _optPhysicalSize() {
      if (this.grid) {
        return this._estRowsInView * this._rowHeight * this._maxPages;
      }
      return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;
    },

   /**
    * True if the current list is visible.
    */
    get _isVisible() {
      return Boolean(this.offsetWidth || this.offsetHeight);
    },

    /**
     * Gets the index of the first visible item in the viewport.
     *
     * @type {number}
     */
    get firstVisibleIndex() {
      var idx = this._firstVisibleIndexVal;
      if (idx == null) {
        var physicalOffset = this._physicalTop + this._scrollOffset;

        idx = this._iterateItems(function(pidx, vidx) {
          physicalOffset += this._getPhysicalSizeIncrement(pidx);

          if (physicalOffset > this._scrollPosition) {
            return this.grid ? vidx - (vidx % this._itemsPerRow) : vidx;
          }
          // Handle a partially rendered final row in grid mode
          if (this.grid && this._virtualCount - 1 === vidx) {
            return vidx - (vidx % this._itemsPerRow);
          }
        }) || 0;
        this._firstVisibleIndexVal = idx;
      }
      return idx;
    },

    /**
     * Gets the index of the last visible item in the viewport.
     *
     * @type {number}
     */
    get lastVisibleIndex() {
      var idx = this._lastVisibleIndexVal;
      if (idx == null) {
        if (this.grid) {
          idx = Math.min(this._virtualCount,
              this.firstVisibleIndex + this._estRowsInView * this._itemsPerRow - 1);
        } else {
          var physicalOffset = this._physicalTop + this._scrollOffset;
          this._iterateItems(function(pidx, vidx) {
            if (physicalOffset < this._scrollBottom) {
              idx = vidx;
            }
            physicalOffset += this._getPhysicalSizeIncrement(pidx);
          });
        }
        this._lastVisibleIndexVal = idx;
      }
      return idx;
    },

    get _defaultScrollTarget() {
      return this;
    },

    get _virtualRowCount() {
      return Math.ceil(this._virtualCount / this._itemsPerRow);
    },

    get _estRowsInView() {
      return Math.ceil(this._viewportHeight / this._rowHeight);
    },

    get _physicalRows() {
      return Math.ceil(this._physicalCount / this._itemsPerRow);
    },

    get _scrollOffset() {
      return this._scrollerPaddingTop + this.scrollOffset;
    },

    ready: function() {
      this.addEventListener('focus', this._didFocus.bind(this), true);
    },

    attached: function() {
      if (this._physicalCount === 0) {
        this._debounceTemplate(this._render);
      }
      // `iron-resize` is fired when the list is attached if the event is added
      // before attached causing unnecessary work.
      this.listen(this, 'iron-resize', '_resizeHandler');
    },

    detached: function() {
      this.unlisten(this, 'iron-resize', '_resizeHandler');
    },

    /**
     * Set the overflow property if this element has its own scrolling region
     */
    _setOverflow: function(scrollTarget) {
      this.style.webkitOverflowScrolling = scrollTarget === this ? 'touch' : '';
      this.style.overflow = scrollTarget === this ? 'auto' : '';
      // Clear cache.
      this._lastVisibleIndexVal = null;
      this._firstVisibleIndexVal = null;
      this._debounceTemplate(this._render);
    },

    /**
     * Invoke this method if you dynamically update the viewport's
     * size or CSS padding.
     *
     * @method updateViewportBoundaries
     */
    updateViewportBoundaries: function() {
      var styles = window.getComputedStyle(this);
      this._scrollerPaddingTop = this.scrollTarget === this ? 0 :
          parseInt(styles['padding-top'], 10);
      this._isRTL = Boolean(styles.direction === 'rtl');
      this._viewportWidth = this.$.items.offsetWidth;
      this._viewportHeight = this._scrollTargetHeight;
      this.grid && this._updateGridMetrics();
    },

    /**
     * Recycles the physical items when needed.
     */
    _scrollHandler: function() {
      var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
      var delta = scrollTop - this._scrollPosition;
      var isScrollingDown = delta >= 0;
      // Track the current scroll position.
      this._scrollPosition = scrollTop;
      // Clear indexes.
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;

      // Random access.
      if (Math.abs(delta) > this._physicalSize) {
        delta = delta - this._scrollOffset;
        var idxAdjustment = Math.round(delta / this._physicalAverage) * this._itemsPerRow;
        this._physicalTop = this._physicalTop + delta;
        this._virtualStart = this._virtualStart + idxAdjustment;
        this._physicalStart = this._physicalStart + idxAdjustment;
        this._update();
      } else {
        var reusables = this._getReusables(isScrollingDown);
        if (isScrollingDown) {
          this._physicalTop = reusables.physicalTop;
          this._virtualStart = this._virtualStart + reusables.indexes.length;
          this._physicalStart = this._physicalStart + reusables.indexes.length;
        } else {
          this._virtualStart = this._virtualStart - reusables.indexes.length;
          this._physicalStart = this._physicalStart - reusables.indexes.length;
        }
        if (reusables.indexes.length === 0) {
          this._increasePoolIfNeeded();
        } else {
          this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);
        }
      }
    },

    /**
     * Returns an object that contains the indexes of the physical items
     * that might be reused and the physicalTop.
     *
     * @param {boolean} fromTop If the potential reusable items are above the scrolling region.
     */
    _getReusables: function(fromTop) {
      var ith, lastIth, offsetContent, physicalItemHeight;
      var idxs = [];
      var protectedOffsetContent = this._hiddenContentSize * this._ratio;
      var virtualStart = this._virtualStart;
      var virtualEnd = this._virtualEnd;
      var physicalCount = this._physicalCount;
      var top = this._physicalTop + this._scrollOffset;
      var bottom = this._physicalBottom + this._scrollOffset;
      var scrollTop = this._scrollTop;
      var scrollBottom = this._scrollBottom;

      if (fromTop) {
        ith = this._physicalStart;
        lastIth = this._physicalEnd;
        offsetContent = scrollTop - top;
      } else {
        ith = this._physicalEnd;
        lastIth = this._physicalStart;
        offsetContent = bottom - scrollBottom;
      }
      while (true) {
        physicalItemHeight = this._getPhysicalSizeIncrement(ith);
        offsetContent = offsetContent - physicalItemHeight;
        if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {
          break;
        }
        if (fromTop) {
          // Check that index is within the valid range.
          if (virtualEnd + idxs.length + 1 >= this._virtualCount) {
            break;
          }
          // Check that the index is not visible.
          if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {
            break;
          }
          idxs.push(ith);
          top = top + physicalItemHeight;
          ith = (ith + 1) % physicalCount;
        } else {
          // Check that index is within the valid range.
          if (virtualStart - idxs.length <= 0) {
            break;
          }
          // Check that the index is not visible.
          if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {
            break;
          }
          idxs.push(ith);
          top = top - physicalItemHeight;
          ith = (ith === 0) ? physicalCount - 1 : ith - 1;
        }
      }
      return { indexes: idxs, physicalTop: top - this._scrollOffset };
    },

    /**
     * Update the list of items, starting from the `_virtualStart` item.
     * @param {!Array<number>=} itemSet
     * @param {!Array<number>=} movingUp
     */
    _update: function(itemSet, movingUp) {
      if (itemSet && itemSet.length === 0) {
        return;
      }
      this._manageFocus();
      this._assignModels(itemSet);
      this._updateMetrics(itemSet);
      // Adjust offset after measuring.
      if (movingUp) {
        while (movingUp.length) {
          var idx = movingUp.pop();
          this._physicalTop -= this._getPhysicalSizeIncrement(idx);
        }
      }
      this._positionItems();
      this._updateScrollerSize();
      this._increasePoolIfNeeded();
    },

    /**
     * Creates a pool of DOM elements and attaches them to the local dom.
     *
     * @param {number} size Size of the pool
     */
    _createPool: function(size) {
      var physicalItems = new Array(size);

      this._ensureTemplatized();

      for (var i = 0; i < size; i++) {
        var inst = this.stamp(null);
        // First element child is item; Safari doesn't support children[0]
        // on a doc fragment.
        physicalItems[i] = inst.root.querySelector('*');
        this._itemsParent.appendChild(inst.root);
      }
      return physicalItems;
    },

    /**
     * Increases the pool of physical items only if needed.
     *
     * @return {boolean} True if the pool was increased.
     */
    _increasePoolIfNeeded: function() {
      var self = this;
      var isClientFull = this._physicalBottom + this._scrollOffset >= this._scrollBottom &&
          this._physicalTop - this._scrollOffset <= this._scrollPosition;
      // Base case 1: if the physical size is optimal and the list's client height is full
      // with physical items, don't increase the pool.
      if (this._physicalSize >= this._optPhysicalSize && isClientFull) {
        return false;
      }
      var maxPoolSize = Math.round(this._physicalCount * 0.5);
      // Increase the pool synchronously until the client is filled.
      if (!isClientFull) {
        this._debounceTemplate(this._increasePool.bind(this, maxPoolSize));
        return true;
      }
      this._yield(function() {
        self._increasePool(Math.min(maxPoolSize, Math.max(1, Math.round(50 / self._templateCost))));
      });
      return true;
    },

    _yield: function(cb) {
      var g = window;
      var handle = g.requestIdleCallback ? g.requestIdleCallback(cb) : g.setTimeout(cb, 16);
      // Polymer/issues/3895
      Polymer.dom.addDebouncer(/** @type {!Polymer.Debouncer} */({
        complete: function() {
          g.cancelIdleCallback ? g.cancelIdleCallback(handle) : g.clearTimeout(handle);
          cb();
        }
      }));
    },

    /**
     * Increases the pool size.
     */
    _increasePool: function(missingItems) {
      var nextPhysicalCount = Math.min(
          this._physicalCount + missingItems,
          this._virtualCount - this._virtualStart,
          Math.max(this.maxPhysicalCount, DEFAULT_PHYSICAL_COUNT)
        );
      var prevPhysicalCount = this._physicalCount;
      var delta = nextPhysicalCount - prevPhysicalCount;
      var ts = window.performance.now();

      if (delta <= 0) {
        return;
      }
      // Concat arrays in place.
      [].push.apply(this._physicalItems, this._createPool(delta));
      [].push.apply(this._physicalSizes, new Array(delta));
      this._physicalCount = prevPhysicalCount + delta;
      // Update the physical start if it needs to preserve the model of the focused item.
      // In this situation, the focused item is currently rendered and its model would
      // have changed after increasing the pool if the physical start remained unchanged.
      if (this._physicalStart > this._physicalEnd &&
          this._isIndexRendered(this._focusedIndex) &&
          this._getPhysicalIndex(this._focusedIndex) < this._physicalEnd) {
        this._physicalStart = this._physicalStart + delta;
      }
      this._update();
      this._templateCost = (window.performance.now() - ts) / delta;
    },

    /**
     * Renders the a new list.
     */
    _render: function() {
      if (this.isAttached && this._isVisible) {
        if (this._physicalCount === 0) {
          this.updateViewportBoundaries();
          this._increasePool(DEFAULT_PHYSICAL_COUNT);
        } else {
          // Try to recycle nodes
          var reusables = this._getReusables(true);
          this._physicalTop = reusables.physicalTop;
          this._virtualStart = this._virtualStart + reusables.indexes.length;
          this._physicalStart = this._physicalStart + reusables.indexes.length;
          this._update(reusables.indexes);
          this._update();
        }
      }
    },

    /**
     * Templetizes the user template.
     */
    _ensureTemplatized: function() {
      if (!this.ctor) {
        // Template instance props that should be excluded from forwarding
        var props = {};
        props.__key__ = true;
        props[this.as] = true;
        props[this.indexAs] = true;
        props[this.selectedAs] = true;
        props.tabIndex = true;
        this._instanceProps = props;
        this._userTemplate = this.queryEffectiveChildren('template');

        if (this._userTemplate) {
          this.templatize(this._userTemplate);
        } else {
          console.warn('iron-list requires a template to be provided in light-dom');
        }
      }
    },

    /**
     * Implements extension point from Templatizer mixin.
     */
    _getStampedChildren: function() {
      return this._physicalItems;
    },

    /**
     * Implements extension point from Templatizer
     * Called as a side effect of a template instance path change, responsible
     * for notifying items.<key-for-instance>.<path> change up to host.
     */
    _forwardInstancePath: function(inst, path, value) {
      if (path.indexOf(this.as + '.') === 0) {
        this.notifyPath('items.' + inst.__key__ + '.' +
          path.slice(this.as.length + 1), value);
      }
    },

    /**
     * Implements extension point from Templatizer mixin
     * Called as side-effect of a host property change, responsible for
     * notifying parent path change on each row.
     */
    _forwardParentProp: function(prop, value) {
      (this._physicalItems || [])
        .concat([this._offscreenFocusedItem, this._focusBackfillItem])
        .forEach(function(item) {
          if (item) {
            item._templateInstance[prop] = value;
          }
        });
    },

    /**
     * Implements extension point from Templatizer
     * Called as side-effect of a host path change, responsible for
     * notifying parent.<path> path change on each row.
     */
    _forwardParentPath: function(path, value) {
      (this._physicalItems || [])
        .concat([this._offscreenFocusedItem, this._focusBackfillItem])
        .forEach(function(item) {
          if (item) {
            item._templateInstance.notifyPath(path, value, true);
          }
        });
    },

    /**
     * Called as a side effect of a host items.<key>.<path> path change,
     * responsible for notifying item.<path> changes.
     */
    _forwardItemPath: function(path, value) {
      if (!this._physicalIndexForKey) {
        return;
      }
      var dot = path.indexOf('.');
      var key = path.substring(0, dot < 0 ? path.length : dot);
      var idx = this._physicalIndexForKey[key];
      var offscreenItem = this._offscreenFocusedItem;
      var el = offscreenItem && offscreenItem._templateInstance.__key__ === key ?
          offscreenItem : this._physicalItems[idx];

      if (!el || el._templateInstance.__key__ !== key) {
        return;
      }
      if (dot >= 0) {
        path = this.as + '.' + path.substring(dot+1);
        el._templateInstance.notifyPath(path, value, true);
      } else {
        // Update selection if needed
        var currentItem = el._templateInstance[this.as];
        if (Array.isArray(this.selectedItems)) {
          for (var i = 0; i < this.selectedItems.length; i++) {
            if (this.selectedItems[i] === currentItem) {
              this.set('selectedItems.' + i, value);
              break;
            }
          }
        } else if (this.selectedItem === currentItem) {
          this.set('selectedItem', value);
        }
        el._templateInstance[this.as] = value;
      }
    },

    /**
     * Called when the items have changed. That is, ressignments
     * to `items`, splices or updates to a single item.
     */
    _itemsChanged: function(change) {
      if (change.path === 'items') {
        this._virtualStart = 0;
        this._physicalTop = 0;
        this._virtualCount = this.items ? this.items.length : 0;
        this._collection = this.items ? Polymer.Collection.get(this.items) : null;
        this._physicalIndexForKey = {};
        this._firstVisibleIndexVal = null;
        this._lastVisibleIndexVal = null;
        this._physicalCount = this._physicalCount || 0;
        this._physicalItems = this._physicalItems || [];
        this._physicalSizes = this._physicalSizes || [];
        this._physicalStart = 0;
        if (this._scrollTop > this._scrollOffset) {
          this._resetScrollPosition(0);
        }
        this._removeFocusedItem();
        this._debounceTemplate(this._render);

      } else if (change.path === 'items.splices') {
        this._adjustVirtualIndex(change.value.indexSplices);
        this._virtualCount = this.items ? this.items.length : 0;

        this._debounceTemplate(this._render);
      } else {
        this._forwardItemPath(change.path.split('.').slice(1).join('.'), change.value);
      }
    },

    /**
     * @param {!Array<!PolymerSplice>} splices
     */
    _adjustVirtualIndex: function(splices) {
      splices.forEach(function(splice) {
        // deselect removed items
        splice.removed.forEach(this._removeItem, this);
        // We only need to care about changes happening above the current position
        if (splice.index < this._virtualStart) {
          var delta = Math.max(
              splice.addedCount - splice.removed.length,
              splice.index - this._virtualStart);

          this._virtualStart = this._virtualStart + delta;

          if (this._focusedIndex >= 0) {
            this._focusedIndex = this._focusedIndex + delta;
          }
        }
      }, this);
    },

    _removeItem: function(item) {
      this.$.selector.deselect(item);
      // remove the current focused item
      if (this._focusedItem && this._focusedItem._templateInstance[this.as] === item) {
        this._removeFocusedItem();
      }
    },

    /**
     * Executes a provided function per every physical index in `itemSet`
     * `itemSet` default value is equivalent to the entire set of physical indexes.
     *
     * @param {!function(number, number)} fn
     * @param {!Array<number>=} itemSet
     */
    _iterateItems: function(fn, itemSet) {
      var pidx, vidx, rtn, i;

      if (arguments.length === 2 && itemSet) {
        for (i = 0; i < itemSet.length; i++) {
          pidx = itemSet[i];
          vidx = this._computeVidx(pidx);
          if ((rtn = fn.call(this, pidx, vidx)) != null) {
            return rtn;
          }
        }
      } else {
        pidx = this._physicalStart;
        vidx = this._virtualStart;

        for (; pidx < this._physicalCount; pidx++, vidx++) {
          if ((rtn = fn.call(this, pidx, vidx)) != null) {
            return rtn;
          }
        }
        for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {
          if ((rtn = fn.call(this, pidx, vidx)) != null) {
            return rtn;
          }
        }
      }
    },

    /**
     * Returns the virtual index for a given physical index
     *
     * @param {number} pidx Physical index
     * @return {number}
     */
    _computeVidx: function(pidx) {
      if (pidx >= this._physicalStart) {
        return this._virtualStart + (pidx - this._physicalStart);
      }
      return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;
    },

    /**
     * Assigns the data models to a given set of items.
     * @param {!Array<number>=} itemSet
     */
    _assignModels: function(itemSet) {
      this._iterateItems(function(pidx, vidx) {
        var el = this._physicalItems[pidx];
        var inst = el._templateInstance;
        var item = this.items && this.items[vidx];
        if (item != null) {
          inst[this.as] = item;
          inst.__key__ = this._collection.getKey(item);
          inst[this.selectedAs] = /** @type {!ArraySelectorElement} */ (this.$.selector).isSelected(item);
          inst[this.indexAs] = vidx;
          inst.tabIndex = this._focusedIndex === vidx ? 0 : -1;
          this._physicalIndexForKey[inst.__key__] = pidx;
          el.removeAttribute('hidden');
        } else {
          inst.__key__ = null;
          el.setAttribute('hidden', '');
        }
      }, itemSet);
    },

    /**
     * Updates the height for a given set of items.
     *
     * @param {!Array<number>=} itemSet
     */
     _updateMetrics: function(itemSet) {
      // Make sure we distributed all the physical items
      // so we can measure them.
      Polymer.dom.flush();

      var newPhysicalSize = 0;
      var oldPhysicalSize = 0;
      var prevAvgCount = this._physicalAverageCount;
      var prevPhysicalAvg = this._physicalAverage;

      this._iterateItems(function(pidx, vidx) {
        oldPhysicalSize += this._physicalSizes[pidx] || 0;
        this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;
        newPhysicalSize += this._physicalSizes[pidx];
        this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;
      }, itemSet);

      if (this.grid) {
        this._updateGridMetrics();
        this._physicalSize = Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;
      } else {
        this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;
      }
      // Update the average if it measured something.
      if (this._physicalAverageCount !== prevAvgCount) {
        this._physicalAverage = Math.round(
            ((prevPhysicalAvg * prevAvgCount) + newPhysicalSize) /
            this._physicalAverageCount);
      }
    },

    _updateGridMetrics: function() {
      this._itemWidth = this._physicalCount > 0 ? this._physicalItems[0].getBoundingClientRect().width : 200;
      this._rowHeight = this._physicalCount > 0 ? this._physicalItems[0].offsetHeight : 200;
      this._itemsPerRow = this._itemWidth ? Math.floor(this._viewportWidth / this._itemWidth) : this._itemsPerRow;
    },

    /**
     * Updates the position of the physical items.
     */
    _positionItems: function() {
      this._adjustScrollPosition();

      var y = this._physicalTop;

      if (this.grid) {
        var totalItemWidth = this._itemsPerRow * this._itemWidth;
        var rowOffset = (this._viewportWidth - totalItemWidth) / 2;

        this._iterateItems(function(pidx, vidx) {
          var modulus = vidx % this._itemsPerRow;
          var x = Math.floor((modulus * this._itemWidth) + rowOffset);
          if (this._isRTL) {
            x = x * -1;
          }
          this.translate3d(x + 'px', y + 'px', 0, this._physicalItems[pidx]);
          if (this._shouldRenderNextRow(vidx)) {
            y += this._rowHeight;
          }
        });
      } else {
        this._iterateItems(function(pidx, vidx) {
          this.translate3d(0, y + 'px', 0, this._physicalItems[pidx]);
          y += this._physicalSizes[pidx];
        });
      }
    },

    _getPhysicalSizeIncrement: function(pidx) {
      if (!this.grid) {
        return this._physicalSizes[pidx];
      }
      if (this._computeVidx(pidx) % this._itemsPerRow !== this._itemsPerRow - 1) {
        return 0;
      }
      return this._rowHeight;
    },

    /**
     * Returns, based on the current index,
     * whether or not the next index will need
     * to be rendered on a new row.
     *
     * @param {number} vidx Virtual index
     * @return {boolean}
     */
    _shouldRenderNextRow: function(vidx) {
      return vidx % this._itemsPerRow === this._itemsPerRow - 1;
    },

    /**
     * Adjusts the scroll position when it was overestimated.
     */
    _adjustScrollPosition: function() {
      var deltaHeight = this._virtualStart === 0 ? this._physicalTop :
          Math.min(this._scrollPosition + this._physicalTop, 0);

      if (deltaHeight) {
        this._physicalTop = this._physicalTop - deltaHeight;
        // juking scroll position during interial scrolling on iOS is no bueno
        if (!IOS_TOUCH_SCROLLING && this._physicalTop !== 0) {
          this._resetScrollPosition(this._scrollTop - deltaHeight);
        }
      }
    },

    /**
     * Sets the position of the scroll.
     */
    _resetScrollPosition: function(pos) {
      if (this.scrollTarget) {
        this._scrollTop = pos;
        this._scrollPosition = this._scrollTop;
      }
    },

    /**
     * Sets the scroll height, that's the height of the content,
     *
     * @param {boolean=} forceUpdate If true, updates the height no matter what.
     */
    _updateScrollerSize: function(forceUpdate) {
      if (this.grid) {
        this._estScrollHeight = this._virtualRowCount * this._rowHeight;
      } else {
        this._estScrollHeight = (this._physicalBottom +
            Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage);
      }

      forceUpdate = forceUpdate || this._scrollHeight === 0;
      forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;
      forceUpdate = forceUpdate || this.grid && this.$.items.style.height < this._estScrollHeight;

      // Amortize height adjustment, so it won't trigger large repaints too often.
      if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._optPhysicalSize) {
        this.$.items.style.height = this._estScrollHeight + 'px';
        this._scrollHeight = this._estScrollHeight;
      }
    },

    /**
     * Scroll to a specific item in the virtual list regardless
     * of the physical items in the DOM tree.
     *
     * @method scrollToItem
     * @param {(Object)} item The item to be scrolled to
     */
    scrollToItem: function(item){
      return this.scrollToIndex(this.items.indexOf(item));
    },

    /**
     * Scroll to a specific index in the virtual list regardless
     * of the physical items in the DOM tree.
     *
     * @method scrollToIndex
     * @param {number} idx The index of the item
     */
    scrollToIndex: function(idx) {
      if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {
        return;
      }
      Polymer.dom.flush();
      // Items should have been rendered prior scrolling to an index.
      if (this._physicalCount === 0) {
        return;
      }
      idx = Math.min(Math.max(idx, 0), this._virtualCount-1);
      // Update the virtual start only when needed.
      if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {
        this._virtualStart = this.grid ? (idx - this._itemsPerRow * 2) : (idx - 1);
      }
      this._manageFocus();
      this._assignModels();
      this._updateMetrics();
      // Estimate new physical offset.
      this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow)  * this._physicalAverage;

      var currentTopItem = this._physicalStart;
      var currentVirtualItem = this._virtualStart;
      var targetOffsetTop = 0;
      var hiddenContentSize = this._hiddenContentSize;
      // scroll to the item as much as we can.
      while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {
        targetOffsetTop = targetOffsetTop + this._getPhysicalSizeIncrement(currentTopItem);
        currentTopItem = (currentTopItem + 1) % this._physicalCount;
        currentVirtualItem++;
      }
      this._updateScrollerSize(true);
      this._positionItems();
      this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);
      this._increasePoolIfNeeded();
      // clear cached visible index.
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;
    },

    /**
     * Reset the physical average and the average count.
     */
    _resetAverage: function() {
      this._physicalAverage = 0;
      this._physicalAverageCount = 0;
    },

    /**
     * A handler for the `iron-resize` event triggered by `IronResizableBehavior`
     * when the element is resized.
     */
    _resizeHandler: function() {
      this._debounceTemplate(function() {
        // Skip the resize event on touch devices when the address bar slides up.
        var delta = Math.abs(this._viewportHeight - this._scrollTargetHeight);
        this.updateViewportBoundaries();
        if (('ontouchstart' in window || navigator.maxTouchPoints > 0) && delta > 0 && delta < 100) {
          return;
        }
        if (this._isVisible) {
          // Reinstall the scroll event listener.
          this.toggleScrollListener(true);
          this._resetAverage();
          this._render();
        } else {
          // Uninstall the scroll event listener.
          this.toggleScrollListener(false);
        }
      }.bind(this));
    },

    _getModelFromItem: function(item) {
      var key = this._collection.getKey(item);
      var pidx = this._physicalIndexForKey[key];

      if (pidx != null) {
        return this._physicalItems[pidx]._templateInstance;
      }
      return null;
    },

    /**
     * Gets a valid item instance from its index or the object value.
     *
     * @param {(Object|number)} item The item object or its index
     */
    _getNormalizedItem: function(item) {
      if (this._collection.getKey(item) === undefined) {
        if (typeof item === 'number') {
          item = this.items[item];
          if (!item) {
            throw new RangeError('<item> not found');
          }
          return item;
        }
        throw new TypeError('<item> should be a valid item');
      }
      return item;
    },

    /**
     * Select the list item at the given index.
     *
     * @method selectItem
     * @param {(Object|number)} item The item object or its index
     */
    selectItem: function(item) {
      item = this._getNormalizedItem(item);
      var model = this._getModelFromItem(item);

      if (!this.multiSelection && this.selectedItem) {
        this.deselectItem(this.selectedItem);
      }
      if (model) {
        model[this.selectedAs] = true;
      }
      this.$.selector.select(item);
      this.updateSizeForItem(item);
    },

    /**
     * Deselects the given item list if it is already selected.
     *

     * @method deselect
     * @param {(Object|number)} item The item object or its index
     */
    deselectItem: function(item) {
      item = this._getNormalizedItem(item);
      var model = this._getModelFromItem(item);

      if (model) {
        model[this.selectedAs] = false;
      }
      this.$.selector.deselect(item);
      this.updateSizeForItem(item);
    },

    /**
     * Select or deselect a given item depending on whether the item
     * has already been selected.
     *
     * @method toggleSelectionForItem
     * @param {(Object|number)} item The item object or its index
     */
    toggleSelectionForItem: function(item) {
      item = this._getNormalizedItem(item);
      if (/** @type {!ArraySelectorElement} */ (this.$.selector).isSelected(item)) {
        this.deselectItem(item);
      } else {
        this.selectItem(item);
      }
    },

    /**
     * Clears the current selection state of the list.
     *
     * @method clearSelection
     */
    clearSelection: function() {
      function unselect(item) {
        var model = this._getModelFromItem(item);
        if (model) {
          model[this.selectedAs] = false;
        }
      }

      if (Array.isArray(this.selectedItems)) {
        this.selectedItems.forEach(unselect, this);
      } else if (this.selectedItem) {
        unselect.call(this, this.selectedItem);
      }

      /** @type {!ArraySelectorElement} */ (this.$.selector).clearSelection();
    },

    /**
     * Add an event listener to `tap` if `selectionEnabled` is true,
     * it will remove the listener otherwise.
     */
    _selectionEnabledChanged: function(selectionEnabled) {
      var handler = selectionEnabled ? this.listen : this.unlisten;
      handler.call(this, this, 'tap', '_selectionHandler');
    },

    /**
     * Select an item from an event object.
     */
    _selectionHandler: function(e) {
      var model = this.modelForElement(e.target);
      if (!model) {
        return;
      }
      var modelTabIndex, activeElTabIndex;
      var target = Polymer.dom(e).path[0];
      var itemsHost = this._itemsParent.node.domHost;
      var activeEl = Polymer.dom(itemsHost ? itemsHost.root : document).activeElement;
      var physicalItem = this._physicalItems[this._getPhysicalIndex(model[this.indexAs])];
      // Safari does not focus certain form controls via mouse
      // https://bugs.webkit.org/show_bug.cgi?id=118043
      if (target.localName === 'input' ||
          target.localName === 'button' ||
          target.localName === 'select') {
        return;
      }
      // Set a temporary tabindex
      modelTabIndex = model.tabIndex;
      model.tabIndex = SECRET_TABINDEX;
      activeElTabIndex = activeEl ? activeEl.tabIndex : -1;
      model.tabIndex = modelTabIndex;
      // Only select the item if the tap wasn't on a focusable child
      // or the element bound to `tabIndex`
      if (activeEl && physicalItem !== activeEl && physicalItem.contains(activeEl) && activeElTabIndex !== SECRET_TABINDEX) {
        return;
      }
      this.toggleSelectionForItem(model[this.as]);
    },

    _multiSelectionChanged: function(multiSelection) {
      this.clearSelection();
      this.$.selector.multi = multiSelection;
    },

    /**
     * Updates the size of an item.
     *
     * @method updateSizeForItem
     * @param {(Object|number)} item The item object or its index
     */
    updateSizeForItem: function(item) {
      item = this._getNormalizedItem(item);
      var key = this._collection.getKey(item);
      var pidx = this._physicalIndexForKey[key];

      if (pidx != null) {
        this._updateMetrics([pidx]);
        this._positionItems();
      }
    },

    /**
     * Creates a temporary backfill item in the rendered pool of physical items
     * to replace the main focused item. The focused item has tabIndex = 0
     * and might be currently focused by the user.
     *
     * This dynamic replacement helps to preserve the focus state.
     */
    _manageFocus: function() {
      var fidx = this._focusedIndex;

      if (fidx >= 0 && fidx < this._virtualCount) {
        // if it's a valid index, check if that index is rendered
        // in a physical item.
        if (this._isIndexRendered(fidx)) {
          this._restoreFocusedItem();
        } else {
          this._createFocusBackfillItem();
        }
      } else if (this._virtualCount > 0 && this._physicalCount > 0) {
        // otherwise, assign the initial focused index.
        this._focusedIndex = this._virtualStart;
        this._focusedItem = this._physicalItems[this._physicalStart];
      }
    },

    _isIndexRendered: function(idx) {
      return idx >= this._virtualStart && idx <= this._virtualEnd;
    },

    _isIndexVisible: function(idx) {
      return idx >= this.firstVisibleIndex && idx <= this.lastVisibleIndex;
    },

    _getPhysicalIndex: function(idx) {
      return this._physicalIndexForKey[this._collection.getKey(this._getNormalizedItem(idx))];
    },

    _focusPhysicalItem: function(idx) {
      if (idx < 0 || idx >= this._virtualCount) {
        return;
      }
      this._restoreFocusedItem();
      // scroll to index to make sure it's rendered
      if (!this._isIndexRendered(idx)) {
        this.scrollToIndex(idx);
      }

      var physicalItem = this._physicalItems[this._getPhysicalIndex(idx)];
      var model = physicalItem._templateInstance;
      var focusable;
      // set a secret tab index
      model.tabIndex = SECRET_TABINDEX;
      // check if focusable element is the physical item
      if (physicalItem.tabIndex === SECRET_TABINDEX) {
       focusable = physicalItem;
      }
      // search for the element which tabindex is bound to the secret tab index
      if (!focusable) {
        focusable = Polymer.dom(physicalItem).querySelector('[tabindex="' + SECRET_TABINDEX + '"]');
      }
      // restore the tab index
      model.tabIndex = 0;
      // focus the focusable element
      this._focusedIndex = idx;
      focusable && focusable.focus();
    },

    _removeFocusedItem: function() {
      if (this._offscreenFocusedItem) {
        this._itemsParent.removeChild(this._offscreenFocusedItem);
      }
      this._offscreenFocusedItem = null;
      this._focusBackfillItem = null;
      this._focusedItem = null;
      this._focusedIndex = -1;
    },

    _createFocusBackfillItem: function() {
      var fidx = this._focusedIndex;
      var pidx = this._getPhysicalIndex(fidx);

      if (this._offscreenFocusedItem || pidx == null || fidx < 0) {
        return;
      }
      if (!this._focusBackfillItem) {
        // Create a physical item.
        var stampedTemplate = this.stamp(null);
        this._focusBackfillItem = stampedTemplate.root.querySelector('*');
        this._itemsParent.appendChild(stampedTemplate.root);
      }
      // Set the offcreen focused physical item.
      this._offscreenFocusedItem = this._physicalItems[pidx];
      this._offscreenFocusedItem._templateInstance.tabIndex = 0;
      this._physicalItems[pidx] = this._focusBackfillItem;
      // Hide the focused physical.
      this.translate3d(0, HIDDEN_Y, 0, this._offscreenFocusedItem);
    },

    _restoreFocusedItem: function() {
      var pidx, fidx = this._focusedIndex;

      if (!this._offscreenFocusedItem || this._focusedIndex < 0) {
        return;
      }
      // Assign models to the focused index.
      this._assignModels();
      // Get the new physical index for the focused index.
      pidx = this._getPhysicalIndex(fidx);

      if (pidx != null) {
        // Flip the focus backfill.
        this._focusBackfillItem = this._physicalItems[pidx];
        this._focusBackfillItem._templateInstance.tabIndex = -1;
        // Restore the focused physical item.
        this._physicalItems[pidx] = this._offscreenFocusedItem;
        // Reset the offscreen focused item.
        this._offscreenFocusedItem = null;
        // Hide the physical item that backfills.
        this.translate3d(0, HIDDEN_Y, 0, this._focusBackfillItem);
      }
    },

    _didFocus: function(e) {
      var targetModel = this.modelForElement(e.target);
      var focusedModel = this._focusedItem ? this._focusedItem._templateInstance : null;
      var hasOffscreenFocusedItem = this._offscreenFocusedItem !== null;
      var fidx = this._focusedIndex;

      if (!targetModel || !focusedModel) {
        return;
      }
      if (focusedModel === targetModel) {
        // if the user focused the same item, then bring it into view if it's not visible
        if (!this._isIndexVisible(fidx)) {
          this.scrollToIndex(fidx);
        }
      } else {
        this._restoreFocusedItem();
        // restore tabIndex for the currently focused item
        focusedModel.tabIndex = -1;
        // set the tabIndex for the next focused item
        targetModel.tabIndex = 0;
        fidx = targetModel[this.indexAs];
        this._focusedIndex = fidx;
        this._focusedItem = this._physicalItems[this._getPhysicalIndex(fidx)];
        if (hasOffscreenFocusedItem && !this._offscreenFocusedItem) {
          this._update();
        }
      }
    },

    _didMoveUp: function() {
      this._focusPhysicalItem(this._focusedIndex - 1);
    },

    _didMoveDown: function(e) {
      // disable scroll when pressing the down key
      e.detail.keyboardEvent.preventDefault();
      this._focusPhysicalItem(this._focusedIndex + 1);
    },

    _didEnter: function(e) {
      this._focusPhysicalItem(this._focusedIndex);
      this._selectionHandler(e.detail.keyboardEvent);
    }
  });

})();

</script>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><style is="custom-style">

  :root {

    --shadow-transition: {
      transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
    };

    --shadow-none: {
      box-shadow: none;
    };

    /* from http://codepen.io/shyndman/pen/c5394ddf2e8b2a5c9185904b57421cdb */

    --shadow-elevation-2dp: {
      box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                  0 1px 5px 0 rgba(0, 0, 0, 0.12),
                  0 3px 1px -2px rgba(0, 0, 0, 0.2);
    };

    --shadow-elevation-3dp: {
      box-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14),
                  0 1px 8px 0 rgba(0, 0, 0, 0.12),
                  0 3px 3px -2px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-4dp: {
      box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
                  0 1px 10px 0 rgba(0, 0, 0, 0.12),
                  0 2px 4px -1px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-6dp: {
      box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14),
                  0 1px 18px 0 rgba(0, 0, 0, 0.12),
                  0 3px 5px -1px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-8dp: {
      box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14),
                  0 3px 14px 2px rgba(0, 0, 0, 0.12),
                  0 5px 5px -3px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-12dp: {
      box-shadow: 0 12px 16px 1px rgba(0, 0, 0, 0.14),
                  0 4px 22px 3px rgba(0, 0, 0, 0.12),
                  0 6px 7px -4px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-16dp: {
      box-shadow: 0 16px 24px 2px rgba(0, 0, 0, 0.14),
                  0  6px 30px 5px rgba(0, 0, 0, 0.12),
                  0  8px 10px -5px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-24dp: {
      box-shadow: 0 24px 38px 3px rgba(0, 0, 0, 0.14),
                  0 9px 46px 8px rgba(0, 0, 0, 0.12),
                  0 11px 15px -7px rgba(0, 0, 0, 0.4);
    };
  }

</style><script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.combobox = vaadin.elements.combobox || {};

  /** @polymerBehavior vaadin.elements.combobox.OverlayBehavior */
  vaadin.elements.combobox.OverlayBehaviorImpl = {
    properties: {
      /**
       * The element to position/align the dropdown by.
       */
      positionTarget: {
        type: Object
      },

      /**
       * Vertical offset for the overlay position.
       */
      verticalOffset: {
        type: Number,
        value: 0
      },

      /**
       * If `true`, overlay is aligned above the `positionTarget`
       */
      _alignedAbove: {
        type: Boolean,
        value: false
      }
    },

    listeners: {
      'iron-resize': '_setPosition'
    },

    created: function() {
      this._boundSetPosition = this._setPosition.bind(this);
    },

    _unwrapIfNeeded: function(element) {
      var isWrapped = Polymer.Settings.hasShadow && !Polymer.Settings.nativeShadow;
      return isWrapped ? window.unwrap(element) : element;
    },

    _processPendingMutationObserversFor: function(node) {
      if (!Polymer.Settings.useNativeCustomElements) {
        CustomElements.takeRecords(node);
      }
    },

    _moveTo: function(target) {
      // `attached` and `detached` callbacks are unreliable with Shadow DOM polyfill. They are asynchonous and sometimes
      // cancel each other. We need to process mutation observers synchonously after moving the overlay. :-(
      var oldParentNode = this.parentNode;
      Polymer.dom(target).appendChild(this);

      if (oldParentNode) {
        this._processPendingMutationObserversFor(oldParentNode);
        if (oldParentNode.host) {
          // When moving from local DOM, ensure to remove the old style scope
          Polymer.StyleTransformer.dom(this, oldParentNode.host.is, this._scopeCssViaAttr, true);
        }
      }

      this._processPendingMutationObserversFor(this);
      if (target.host) {
        // When moving to local DOM, ensure to add the new style scope
        Polymer.StyleTransformer.dom(this, target.host.is, this._scopeCssViaAttr);
      }

      if (target === document.body) {
        this.style.position = this._isPositionFixed(this.positionTarget) ? 'fixed' : 'absolute';
        window.addEventListener('scroll', this._boundSetPosition, true);
        this._setPosition();
      } else {
        window.removeEventListener('scroll', this._boundSetPosition, true);
      }
    },

    _verticalOffset: function(overlayRect, targetRect) {
      if (this._alignedAbove) {
        return -overlayRect.height;
      } else {
        return targetRect.height + this.verticalOffset;
      }
    },

    _isPositionFixed: function(element) {
      var offsetParent = element.offsetParent;

      return window.getComputedStyle(this._unwrapIfNeeded(element)).position === 'fixed' ||
        (offsetParent && this._isPositionFixed(offsetParent));
    },

    _maxHeight: function(targetRect) {
      var margin = 8;
      var minHeight = 116; // Height of two items in combo-box
      var bottom = Math.min(window.innerHeight, document.body.scrollHeight - document.body.scrollTop);

      if (this._alignedAbove) {
        return Math.max(targetRect.top - margin + Math.min(document.body.scrollTop, 0), minHeight) + 'px';
      } else {
        return Math.max(bottom - targetRect.bottom - margin, minHeight) + 'px';
      }
    },

    _setPosition: function(e) {
      if (e && e.target) {
        var target = e.target === document ? document.body : e.target;
        var parent = this._unwrapIfNeeded(this.parentElement);
        if (!(target.contains(this) || target.contains(this.positionTarget)) || parent !== document.body) {
          return;
        }
      }

      var targetRect = this.positionTarget.getBoundingClientRect();
      this._alignedAbove = this._shouldAlignAbove();

      // overlay max height is restrained by the #scroller max height which is set to 65vh in CSS.
      this.style.maxHeight = this._maxHeight(targetRect);

      // we need to set height for iron-list to make its `firstVisibleIndex` work correctly.
      this.$.selector.style.maxHeight = this._maxHeight(targetRect);

      var overlayRect = this.getBoundingClientRect();
      this._translateX = targetRect.left - overlayRect.left + (this._translateX || 0);
      this._translateY = targetRect.top - overlayRect.top + (this._translateY || 0) +
        this._verticalOffset(overlayRect, targetRect);

      var _devicePixelRatio = window.devicePixelRatio || 1;
      this._translateX = Math.round(this._translateX * _devicePixelRatio) / _devicePixelRatio;
      this._translateY = Math.round(this._translateY * _devicePixelRatio) / _devicePixelRatio;
      this.translate3d(this._translateX + 'px', this._translateY + 'px', '0');

      this.style.width = this.positionTarget.clientWidth + 'px';

      this.updateViewportBoundaries();
    },

    _shouldAlignAbove: function() {
      var spaceBelow = (
          window.innerHeight -
          this.positionTarget.getBoundingClientRect().bottom -
          Math.min(document.body.scrollTop, 0)
        ) / window.innerHeight;

      return spaceBelow < 0.30;
    }
  };

  /** @polymerBehavior */
  vaadin.elements.combobox.OverlayBehavior = [
    Polymer.IronResizableBehavior,
    vaadin.elements.combobox.OverlayBehaviorImpl
  ];
</script><!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
--><dom-module id="vaadin-combo-box-item" assetpath="/">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    [[label]]
  </template>
</dom-module>

<script>
  Polymer({
    is: 'vaadin-combo-box-item',

    properties: {
      /**
       * The index of the item
       */
      index: Number,

      /**
       * The item to render
       * @type {(String|Object)}
       */
      item: Object,

      /**
       * The text label corresponding to the item
       */
      label: String,

      /**
       * True when item is selected
       */
      selected: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * True when item is focused
       */
      focused: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * The template instance corresponding to the item
       */
      _itemTemplateInstance: Object
    },

    observers: [
      '_updateTemplateInstanceVariable("index", index, _itemTemplateInstance)',
      '_updateTemplateInstanceVariable("item", item, _itemTemplateInstance)',
      '_updateTemplateInstanceVariable("selected", selected, _itemTemplateInstance)',
      '_updateTemplateInstanceVariable("focused", focused, _itemTemplateInstance)'
    ],

    attached: function() {
      if (!this._itemTemplateInstance) {
        var comboBox = this.domHost.dataHost;
        comboBox._ensureTemplatized();
        if (comboBox._itemTemplate) {
          this._itemTemplateInstance = comboBox.stamp();
          Polymer.dom(this.root).textContent = '';
          Polymer.dom(this.root).appendChild(this._itemTemplateInstance.root);
        }
      }
    },

    _updateTemplateInstanceVariable: function(variable, value, _itemTemplateInstance) {
      this._itemTemplateInstance[variable] = value;
    }
  });
</script>
<dom-module id="vaadin-spinner" assetpath="/">
  <template>
    <style>
      /* Anim */
      @keyframes vaadin-spin-360 {
        100% {
          transform: rotate(1turn);
        }
      }

      :host {
        display: block;
        box-sizing: border-box;
        border: 2px solid var(--primary-color, #03A9F4);
        border-radius: 50%;
        border-right-color: transparent;
        border-top-color: transparent;
        content: "";
        height: 24px;
        left: 50%;
        margin-left: -12px;
        margin-top: -12px;
        position: absolute;
        top: 50%;
        width: 24px;
        pointer-events: none;
        opacity: 0;
      }

      :host([active]) {
        opacity: 1;
        animation: vaadin-spin-360 400ms linear infinite;
      }
    </style>
  </template>
  <script>
    Polymer({
      is: 'vaadin-spinner',

      properties: {
        active: {
          type: Boolean,
          reflectToAttribute: true
        }
      }
    });
  </script>
</dom-module>
<dom-module id="vaadin-combo-box-overlay" assetpath="../../../bower_components/vaadin-combo-box/">
  <template>
    <style>
      :host {
        position: absolute;
        @apply(--shadow-elevation-2dp);
        background: #fff;
        border-radius: 0 0 2px 2px;
        top: 0;
        left: 0;
        pointer-events: auto;

        /**
        * Keep the vaadin-combo-box-overlay above paper-dialogs.
        * iron-overlay-manager.html: Polymer.IronOverlayManagerClass.prototype._applyOverlayZ
        */
        z-index: 200;
        overflow: hidden;
      }

      #scroller {
        overflow: auto;
        max-height: var(--vaadin-combo-box-overlay-max-height, 65vh);

        /* Fixes item background from getting on top of scrollbars on Safari */
        transform: translate3d(0, 0, 0);

        /* Enable momentum scrolling on iOS (iron-list v1.2+ no longer does it for us) */
        -webkit-overflow-scrolling: touch;
      }

      #selector {
        --iron-list-items-container: {
          border-top: 8px solid transparent;
          border-bottom: 8px solid transparent;
        };
      }

      #selector vaadin-combo-box-item {
        cursor: pointer;
        padding: 13px 16px;
        color: var(--primary-text-color);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      :host([opened][loading]) {
        /* roughly the size of a list with one item */
        display: block !important;
        height: 58px;
      }

      #selector:not([touch-device]) vaadin-combo-box-item:hover,
      #selector vaadin-combo-box-item[focused] {
        background: #eee;
      }

      #selector vaadin-combo-box-item[selected] {
        color: var(--primary-color);
      }
    </style>

    <vaadin-spinner active="[[loading]]"></vaadin-spinner>
    <div id="scroller" scroller="[[_getScroller()]]" on-tap="_stopPropagation" on-touchstart="_onTouchStart" on-touchend="_preventDefault" on-scroll="_onScroll" hidden$="[[loading]]">
      <iron-list id="selector" touch-device$="[[touchDevice]]" role="listbox" items="[[_items]]" scroll-target="[[_getScroller()]]">
        <template>
          <vaadin-combo-box-item on-tap="_onTap" index="[[index]]" item="[[item]]" label="[[getItemLabel(item)]]" selected="[[_isItemSelected(item, _selectedItem)]]" role$="[[_getAriaRole(index)]]" aria-selected$="[[_getAriaSelected(_focusedIndex,index)]]" focused="[[_isItemFocused(_focusedIndex,index)]]">
          </vaadin-combo-box-item>
        </template>
      </iron-list>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'vaadin-combo-box-overlay',

    behaviors: [
      vaadin.elements.combobox.OverlayBehavior
    ],

    properties: {

      /**
       * True if the device supports touch events.
       */
      touchDevice: {
        type: Boolean,
        reflectToAttribute: true,
        value: function() {
          try {
            document.createEvent('TouchEvent');
            return true;
          } catch (e) {
            return false;
          }
        }
      },

      /*
       * `true` when new items are being loaded.
       */
      loading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: 'notifyResize'
      },

      _selectedItem: {
        type: Object
      },

      _items: {
        type: Object
      },

      _focusedIndex: {
        type: Number,
        notify: true,
        value: -1,
        observer: '_focusedIndexChanged'
      },

      _focusedItem: {
        type: String,
        computed: '_getFocusedItem(_focusedIndex)'
      },

      _itemLabelPath: {
        type: String,
        value: 'label'
      },

      _itemValuePath: {
        type: String,
        value: 'value'
      },

      _notTapping: Boolean,

      _ignoreTaps: Boolean,
    },

    ready: function() {
      this._patchWheelOverScrolling();

      // Fix for #182. Only relevant for iron-list 1.0.X and 1.1.X.
      // 1.2.X works fine without this.
      if (this.$.selector._scroller !== undefined) {
        this.$.selector._scroller = this._getScroller();
      }
    },

    _getFocusedItem: function(focusedIndex) {
      if (focusedIndex >= 0) {
        return this._items[focusedIndex];
      }
    },

    _isItemSelected: function(item, selectedItem) {
      return item === selectedItem;
    },

    _onTap: function(e) {
      if (!this._notTapping && !this._ignoreTaps) {
        this.fire('selection-changed', {item: e.model.item});
      }
    },

    _onTouchStart: function() {
      this._notTapping = false;
      this.async(function() {
        this._notTapping = true;
      }, 300);
    },

    _onScroll: function() {
      this._ignoreTaps = true;
      this.debounce('restore-taps', function() {
        this._ignoreTaps = false;
      }, 300);
    },

    /**
     * Gets the index of the item with the provided label.
     * @return {Number}
     */
    indexOfLabel: function(label) {
      if (this._items && label) {
        for (var i = 0; i < this._items.length; i++) {
          if (this.getItemLabel(this._items[i]).toString().toLowerCase() ===
              label.toString().toLowerCase()) {
            return i;
          }
        }
      }

      return -1;
    },

    /**
     * Gets the label string for the item based on the `_itemLabelPath`.
     * @return {String}
     */
    getItemLabel: function(item) {
      var label = item ? this.get(this._itemLabelPath, item) : undefined;
      if (label === undefined) {
        label = item ? item.toString() : '';
      }
      return label;
    },

    _isItemFocused: function(focusedIndex, itemIndex) {
      return focusedIndex == itemIndex;
    },

    _getAriaSelected: function(focusedIndex, itemIndex) {
      return this._isItemFocused(focusedIndex, itemIndex).toString();
    },

    _getAriaRole: function(itemIndex) {
      return itemIndex !== undefined ? 'option' : false;
    },

    _focusedIndexChanged: function(index) {
      if (index >= 0) {
        this._scrollIntoView(index);
      }
    },

    _scrollIntoView: function(index) {
      var visibleItemsCount = this._visibleItemsCount();
      if (visibleItemsCount === undefined) {
        // Scroller is not visible. Moving is unnecessary.
        return;
      }

      var targetIndex = index;

      if (index > this.$.selector.lastVisibleIndex - 1) {
        // Index is below the bottom, scrolling down. Make the item appear at the bottom.
        targetIndex = index - visibleItemsCount + 1;
      } else if (index > this.$.selector.firstVisibleIndex) {
        // The item is already visible, scrolling is unnecessary per se. But we need to trigger iron-list to set
        // the correct scrollTop on the scrollTarget. Scrolling to firstVisibleIndex.
        targetIndex = this.$.selector.firstVisibleIndex;
      }
      this.$.selector.scrollToIndex(Math.max(0, targetIndex));

      // Sometimes the item is partly below the bottom edge, detect and adjust.
      var item = this._items[index];
      if (item === undefined) return;
      var pidx = this.$.selector._getPhysicalIndex(item),
        physicalItem = this.$.selector._physicalItems[pidx];
      if (!physicalItem) return;
      var physicalItemRect = physicalItem.getBoundingClientRect(),
        scrollerRect = this.$.scroller.getBoundingClientRect(),
        scrollTopAdjust = physicalItemRect.bottom - scrollerRect.bottom + this._viewportTotalPaddingBottom;
      if (scrollTopAdjust > 0) {
        this.$.scroller.scrollTop += scrollTopAdjust;
      }
    },

    ensureItemsRendered: function() {
      this.$.selector.flushDebouncer('_debounceTemplate');
    },

    adjustScrollPosition: function() {
      if (this._items) {
        this._scrollIntoView(this._focusedIndex);
      }
    },

    // Note: this whole scroller thing is done to support iron lists scrollToIndex()
    // and features that use it like keyboard navigation in IE11 for iron-list 1.0.x.
    // Tested that iron-list 1.2.x works nicely even without the external scroller, but
    // left these here for now for backwards compatibility.
    _getScroller: function() {
      return this.$.scroller;
    },

    /**
     * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.
     * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow
     * scrolling the parent similarily to touch scrolling.
     */
    _patchWheelOverScrolling: function() {
      var selector = this.$.selector;
      selector.addEventListener('wheel', function(e) {
        var scroller = selector._scroller || selector.scrollTarget;
        var scrolledToTop = scroller.scrollTop === 0;
        var scrolledToBottom = (scroller.scrollHeight - scroller.scrollTop - scroller.clientHeight) <= 1;

        if (scrolledToTop && e.deltaY < 0) {
          e.preventDefault();
        } else if (scrolledToBottom && e.deltaY > 0) {
          e.preventDefault();
        }
      });
    },

    updateViewportBoundaries: function() {
      this._cachedViewportTotalPaddingBottom = undefined;
      this.$.selector.updateViewportBoundaries();
    },

    get _viewportTotalPaddingBottom() {
      if (this._cachedViewportTotalPaddingBottom === undefined) {
        var itemsStyle = window.getComputedStyle(this._unwrapIfNeeded(this.$.selector.$.items));
        this._cachedViewportTotalPaddingBottom = [
          itemsStyle.paddingBottom,
          itemsStyle.borderBottomWidth
        ].map(function(v) {
          return parseInt(v, 10);
        }).reduce(function(sum, v) {
          return sum + v;
        });
      }

      return this._cachedViewportTotalPaddingBottom;
    },

    _visibleItemsCount: function() {
      // Ensure items are rendered
      this.$.selector.flushDebouncer('_debounceTemplate');
      // Ensure items are positioned
      this.$.selector.scrollToIndex(this.$.selector.firstVisibleIndex);
      // Ensure viewport boundaries are up-to-date
      this.updateViewportBoundaries();
      return this.$.selector.lastVisibleIndex - this.$.selector.firstVisibleIndex + 1;
    },

    _selectItem: function(item) {
      item = (typeof item === 'number') ? this._items[item] : item;
      if (this.$.selector.selectedItem !== item) {
        this.$.selector.selectItem(item);
      }
    },

    _preventDefault: function(e) {
      if (e.cancelable) {
        e.preventDefault();
      }
    },

    _stopPropagation: function(e) {
      e.stopPropagation();
    }
  });
</script>
<dom-module id="vaadin-combo-box-shared-styles" assetpath="../../../bower_components/vaadin-combo-box/">
  <template>
    <style>
      .rotate-on-open,
      :host ::content .rotate-on-open {
        transition: all 0.2s !important;
      }

      :host([opened]) {
        pointer-events: auto;
      }

      :host([opened]) .rotate-on-open,
      :host([opened]) ::content .rotate-on-open {
        -webkit-transform: rotate(180deg);
        transform: rotate(180deg);
      }

      paper-icon-button.small,
      :host ::content paper-icon-button.small {
        box-sizing: content-box !important;
        bottom: -6px !important;
        width: 20px !important;
        height: 20px !important;
        padding: 4px 6px 8px !important;
      }

      :host(:not([has-value])) ::content .clear-button,
      :host(:not([has-value])) .clear-button {
        display: none;
      }

      :host([readonly]) ::content .toggle-button,
      :host([readonly]) .toggle-button,
      :host([disabled]) ::content .toggle-button,
      :host([disabled]) .toggle-button {
        display: none;
      }
    </style>
  </template>
  <script>
    Polymer({
      is: 'vaadin-combo-box-shared-styles'
    });
  </script>
</dom-module>
<!--
@license
Copyright (c) 2016 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
--><iron-iconset-svg size="24" name="vaadin-combo-box">
  <svg>
    <defs>
      <g id="arrow-drop-down"><path d="M7 10l5 5 5-5z"></path></g>
      <g id="clear"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></g>
    </defs>
  </svg>
</iron-iconset-svg>
<dom-module id="vaadin-combo-box" assetpath="../../../bower_components/vaadin-combo-box/">
  <template>
    <style include="vaadin-combo-box-shared-styles">
      :host {
        display: block;
        padding: 8px 0;
      }

      :host > #overlay {
        display: none;
      }

      paper-input-container {
        position: relative;
        padding: 0;
      }

      paper-icon-button.clear-button,
      paper-icon-button.toggle-button,
      :host ::content paper-icon-button.clear-button,
      :host ::content paper-icon-button.toggle-button {
        position: absolute;
        bottom: -4px;
        right: -4px;

        line-height: 18px !important;
        width: 32px;
        height: 32px;
        padding: 4px;
        text-align: center;

        color: rgba(0, 0, 0, .38);
        cursor: pointer;
        margin-top: -1px;
        --paper-icon-button-ink-color: rgba(0, 0, 0, .54);
      }

      paper-input-container paper-icon-button.clear-button,
      paper-input-container ::content paper-icon-button.clear-button {
        right: 28px;
      }

      paper-input-container paper-icon-button:hover,
      paper-input-container ::content paper-icon-button:hover,
      :host([opened]) paper-input-container paper-icon-button,
      :host([opened]) paper-input-container ::content paper-icon-button {
        color: rgba(0, 0, 0, .54);
      }

      :host([opened]) paper-input-container ::content paper-icon-button:hover,
      :host([opened]) paper-input-container paper-icon-button:hover {
        color: rgba(0, 0, 0, .86);
      }

      :host([opened]) paper-input-container {
        /* Keep the paper-input-container above the dropdown. */
        z-index: 20;
      }

      #input::-ms-clear {
        display: none;
      }

      #input {
        box-sizing: border-box;
        padding-right: 28px;
      }

      :host([opened][has-value]) #input {
        padding-right: 60px;
        margin-right: -32px;
      }

    </style>

    <paper-input-container id="inputContainer" disabled$="[[disabled]]" no-label-float="[[noLabelFloat]]" always-float-label="[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]" auto-validate$="[[autoValidate]]" invalid="[[invalid]]">
      <label on-down="_preventDefault" id="label" hidden$="[[!label]]" aria-hidden="true" on-tap="_openAsync">[[label]]</label>

      <content select="[prefix]"></content>

      <input is="iron-input" id="input" type="text" role="combobox" autocomplete="off" autocapitalize="none" bind-value="{{_inputElementValue}}" aria-label$="[[label]]" aria-expanded$="[[_getAriaExpanded(opened)]]" aria-autocomplete="list" disabled$="[[disabled]]" invalid="{{invalid}}" prevent-invalid-input="[[preventInvalidInput]]" allowed-pattern="[[allowedPattern]]" pattern$="[[pattern]]" required$="[[required]]" autofocus$="[[autofocus]]" inputmode$="[[inputmode]]" name$="[[name]]" placeholder$="[[placeholder]]" readonly$="[[readonly]]" size$="[[size]]" on-input="_inputValueChanged" on-blur="_onBlur" on-change="_stopPropagation" key-event-target="">

      <content select="[suffix]"></content>

      <content select=".clear-button">
        <paper-icon-button id="clearIcon" tabindex="-1" aria-label="Clear" icon="vaadin-combo-box:clear" class="clear-button small">
        </paper-icon-button>
      </content>

      <content select=".toggle-button">
        <paper-icon-button id="toggleIcon" tabindex="-1" icon="vaadin-combo-box:arrow-drop-down" aria-label="Toggle" aria-expanded$="[[_getAriaExpanded(opened)]]" class="toggle-button rotate-on-open">
        </paper-icon-button>
      </content>

      <template is="dom-if" if="[[errorMessage]]">
        <paper-input-error>[[errorMessage]]</paper-input-error>
      </template>
    </paper-input-container>

    <vaadin-combo-box-overlay id="overlay" opened$="[[opened]]" position-target="[[_getPositionTarget()]]" _focused-index="[[_focusedIndex]]" _item-label-path="[[itemLabelPath]]" on-down="_onOverlayDown" loading="[[loading]]" on-mousedown="_preventDefault" vertical-offset="2">
    </vaadin-combo-box-overlay>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'vaadin-combo-box',

    behaviors: [
      Polymer.IronValidatableBehavior,
      vaadin.elements.combobox.ComboBoxBehavior
    ],

    properties: {
      /**
       * The label for this element.
       */
      label: {
        type: String,
        reflectToAttribute: true
      },

      /**
       * Set to true to disable the floating label.
       */
      noLabelFloat: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to always float the label.
       */
      alwaysFloatLabel: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to auto-validate the input value.
       */
      autoValidate: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable this input.
       */
      disabled: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to prevent the user from entering invalid input.
       */
      preventInvalidInput: {
        type: Boolean
      },

      /**
       * Set this to specify the pattern allowed by `preventInvalidInput`.
       */
      allowedPattern: {
        type: String
      },

      /**
       * A pattern to validate the `input` with.
       */
      pattern: {
        type: String
      },

      /**
       * Set to true to mark the input as required.
       */
      required: {
        type: Boolean,
        value: false
      },

      /**
       * The error message to display when the input is invalid.
       */
      errorMessage: {
        type: String
      },

      autofocus: {
        type: Boolean
      },

      inputmode: {
        type: String
      },

      name: {
        type: String
      },

      /**
       * A placeholder string in addition to the label. If this is set, the label will always float.
       */
      placeholder: {
        type: String,
        // need to set a default so _computeAlwaysFloatLabel is run
        value: ''
      },

      readonly: {
        type: Boolean,
        value: false
      },

      size: {
        type: Number
      },

      /**
       * True when the input field has focus.
       */
      focused: {
        type: Boolean,
        value: false,
        readOnly: true,
        reflectToAttribute: true,
        notify: true
      }
    },

    listeners: {
      'inputContainer.focused-changed': '_onInputContainerFocusedChanged'
    },

    attached: function() {
      this._setInputElement(this.$.input);

      // Use the default toggle/clear or one replaced in light DOM.
      this._toggleElement = Polymer.dom(this).querySelector('.toggle-button') || this.$.toggleIcon;
      this._clearElement = Polymer.dom(this).querySelector('.clear-button') || this.$.clearIcon;
      this._preventInputBlur();
    },

    detached: function() {
      this._restoreInputBlur();
    },

    _computeAlwaysFloatLabel: function(alwaysFloatLabel, placeholder) {
      return placeholder || alwaysFloatLabel;
    },

    _getPositionTarget: function() {
      return this.$.inputContainer;
    },

    _getAriaExpanded: function(value) {
      return value.toString();
    },

    /**
     * Sets focus on the input field.
     */
    focus: function() {
      this.$.input.focus();
    },

    /**
     * Removes focus from the input field.
     */
    blur: function() {
      this.$.input.blur();
    },

    _onInputContainerFocusedChanged: function(e) {
      this._setFocused(e.detail.value);
    }
  });

</script>
<!--
@license
Copyright (c) 2016 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
`<iron-dropdown>` is a generalized element that is useful when you have
hidden content (`.dropdown-content`) that is revealed due to some change in
state that should cause it to do so.

Note that this is a low-level element intended to be used as part of other
composite elements that cause dropdowns to be revealed.

Examples of elements that might be implemented using an `iron-dropdown`
include comboboxes, menubuttons, selects. The list goes on.

The `<iron-dropdown>` element exposes attributes that allow the position
of the `.dropdown-content` relative to the `.dropdown-trigger` to be
configured.

    <iron-dropdown horizontal-align="right" vertical-align="top">
      <div class="dropdown-content">Hello!</div>
    </iron-dropdown>

In the above example, the `<div>` with class `.dropdown-content` will be
hidden until the dropdown element has `opened` set to true, or when the `open`
method is called on the element.

@demo demo/index.html
-->

<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>

  /**
   * `Polymer.NeonAnimatableBehavior` is implemented by elements containing animations for use with
   * elements implementing `Polymer.NeonAnimationRunnerBehavior`.
   * @polymerBehavior
   */
  Polymer.NeonAnimatableBehavior = {

    properties: {

      /**
       * Animation configuration. See README for more info.
       */
      animationConfig: {
        type: Object
      },

      /**
       * Convenience property for setting an 'entry' animation. Do not set `animationConfig.entry`
       * manually if using this. The animated node is set to `this` if using this property.
       */
      entryAnimation: {
        observer: '_entryAnimationChanged',
        type: String
      },

      /**
       * Convenience property for setting an 'exit' animation. Do not set `animationConfig.exit`
       * manually if using this. The animated node is set to `this` if using this property.
       */
      exitAnimation: {
        observer: '_exitAnimationChanged',
        type: String
      }

    },

    _entryAnimationChanged: function() {
      this.animationConfig = this.animationConfig || {};
      this.animationConfig['entry'] = [{
        name: this.entryAnimation,
        node: this
      }];
    },

    _exitAnimationChanged: function() {
      this.animationConfig = this.animationConfig || {};
      this.animationConfig['exit'] = [{
        name: this.exitAnimation,
        node: this
      }];
    },

    _copyProperties: function(config1, config2) {
      // shallowly copy properties from config2 to config1
      for (var property in config2) {
        config1[property] = config2[property];
      }
    },

    _cloneConfig: function(config) {
      var clone = {
        isClone: true
      };
      this._copyProperties(clone, config);
      return clone;
    },

    _getAnimationConfigRecursive: function(type, map, allConfigs) {
      if (!this.animationConfig) {
        return;
      }

      if(this.animationConfig.value && typeof this.animationConfig.value === 'function') {
      	this._warn(this._logf('playAnimation', "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
      	return;
      }

      // type is optional
      var thisConfig;
      if (type) {
        thisConfig = this.animationConfig[type];
      } else {
        thisConfig = this.animationConfig;
      }

      if (!Array.isArray(thisConfig)) {
        thisConfig = [thisConfig];
      }

      // iterate animations and recurse to process configurations from child nodes
      if (thisConfig) {
        for (var config, index = 0; config = thisConfig[index]; index++) {
          if (config.animatable) {
            config.animatable._getAnimationConfigRecursive(config.type || type, map, allConfigs);
          } else {
            if (config.id) {
              var cachedConfig = map[config.id];
              if (cachedConfig) {
                // merge configurations with the same id, making a clone lazily
                if (!cachedConfig.isClone) {
                  map[config.id] = this._cloneConfig(cachedConfig)
                  cachedConfig = map[config.id];
                }
                this._copyProperties(cachedConfig, config);
              } else {
                // put any configs with an id into a map
                map[config.id] = config;
              }
            } else {
              allConfigs.push(config);
            }
          }
        }
      }
    },

    /**
     * An element implementing `Polymer.NeonAnimationRunnerBehavior` calls this method to configure
     * an animation with an optional type. Elements implementing `Polymer.NeonAnimatableBehavior`
     * should define the property `animationConfig`, which is either a configuration object
     * or a map of animation type to array of configuration objects.
     */
    getAnimationConfig: function(type) {
      var map = {};
      var allConfigs = [];
      this._getAnimationConfigRecursive(type, map, allConfigs);
      // append the configurations saved in the map to the array
      for (var key in map) {
        allConfigs.push(map[key]);
      }
      return allConfigs;
    }

  };

</script><script>

  /**
   * `Polymer.NeonAnimationRunnerBehavior` adds a method to run animations.
   *
   * @polymerBehavior Polymer.NeonAnimationRunnerBehavior
   */
  Polymer.NeonAnimationRunnerBehaviorImpl = {

    _configureAnimations: function(configs) {
      var results = [];
      if (configs.length > 0) {
        for (var config, index = 0; config = configs[index]; index++) {
          var neonAnimation = document.createElement(config.name);
          // is this element actually a neon animation?
          if (neonAnimation.isNeonAnimation) {
            var result = null;
            // configuration or play could fail if polyfills aren't loaded
            try {
              result = neonAnimation.configure(config);
              // Check if we have an Effect rather than an Animation
              if (typeof result.cancel != 'function') { 
                result = document.timeline.play(result);
              }
            } catch (e) {
              result = null;
              console.warn('Couldnt play', '(', config.name, ').', e);
            }
            if (result) {
              results.push({
                neonAnimation: neonAnimation,
                config: config,
                animation: result,
              });
            }
          } else {
            console.warn(this.is + ':', config.name, 'not found!');
          }
        }
      }
      return results;
    },

    _shouldComplete: function(activeEntries) {
      var finished = true;
      for (var i = 0; i < activeEntries.length; i++) {
        if (activeEntries[i].animation.playState != 'finished') {
          finished = false;
          break;
        }
      }
      return finished;
    },

    _complete: function(activeEntries) {
      for (var i = 0; i < activeEntries.length; i++) {
        activeEntries[i].neonAnimation.complete(activeEntries[i].config);
      }
      for (var i = 0; i < activeEntries.length; i++) {
        activeEntries[i].animation.cancel();
      }
    },

    /**
     * Plays an animation with an optional `type`.
     * @param {string=} type
     * @param {!Object=} cookie
     */
    playAnimation: function(type, cookie) {
      var configs = this.getAnimationConfig(type);
      if (!configs) {
        return;
      }
      this._active = this._active || {};
      if (this._active[type]) {
        this._complete(this._active[type]);
        delete this._active[type];
      }

      var activeEntries = this._configureAnimations(configs);

      if (activeEntries.length == 0) {
        this.fire('neon-animation-finish', cookie, {bubbles: false});
        return;
      }

      this._active[type] = activeEntries;

      for (var i = 0; i < activeEntries.length; i++) {
        activeEntries[i].animation.onfinish = function() {
          if (this._shouldComplete(activeEntries)) {
            this._complete(activeEntries);
            delete this._active[type];
            this.fire('neon-animation-finish', cookie, {bubbles: false});
          }
        }.bind(this);
      }
    },

    /**
     * Cancels the currently running animations.
     */
    cancelAnimation: function() {
      for (var k in this._animations) {
        this._animations[k].cancel();
      }
      this._animations = {};
    }
  };

  /** @polymerBehavior Polymer.NeonAnimationRunnerBehavior */
  Polymer.NeonAnimationRunnerBehavior = [
    Polymer.NeonAnimatableBehavior,
    Polymer.NeonAnimationRunnerBehaviorImpl
  ];
</script><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
`<opaque-animation>` makes an element `opacity:1` for the duration of the animation. Used to prevent
webkit/safari from drawing a frame before an animation for elements that animate from display:none.
-->

<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>

  /**
   * Use `Polymer.NeonAnimationBehavior` to implement an animation.
   * @polymerBehavior
   */
  Polymer.NeonAnimationBehavior = {

    properties: {

      /**
       * Defines the animation timing.
       */
      animationTiming: {
        type: Object,
        value: function() {
          return {
            duration: 500,
            easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
            fill: 'both'
          }
        }
      }

    },

    /**
     * Can be used to determine that elements implement this behavior.
     */
    isNeonAnimation: true,

    /**
     * Do any animation configuration here.
     */
    // configure: function(config) {
    // },

    /**
     * Returns the animation timing by mixing in properties from `config` to the defaults defined
     * by the animation.
     */
    timingFromConfig: function(config) {
      if (config.timing) {
        for (var property in config.timing) {
          this.animationTiming[property] = config.timing[property];
        }
      }
      return this.animationTiming;
    },

    /**
     * Sets `transform` and `transformOrigin` properties along with the prefixed versions.
     */
    setPrefixedProperty: function(node, property, value) {
      var map = {
        'transform': ['webkitTransform'],
        'transformOrigin': ['mozTransformOrigin', 'webkitTransformOrigin']
      };
      var prefixes = map[property];
      for (var prefix, index = 0; prefix = prefixes[index]; index++) {
        node.style[prefix] = value;
      }
      node.style[property] = value;
    },

    /**
     * Called when the animation finishes.
     */
    complete: function() {}

  };

</script><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>!function(a,b){var c={},d={},e={},f=null;!function(t,e){function i(t){if("number"==typeof t)return t;var e={};for(var i in t)e[i]=t[i];return e}function n(){this._delay=0,this._endDelay=0,this._fill="none",this._iterationStart=0,this._iterations=1,this._duration=0,this._playbackRate=1,this._direction="normal",this._easing="linear",this._easingFunction=E}function r(){return t.isDeprecated("Invalid timing inputs","2016-03-02","TypeError exceptions will be thrown instead.",!0)}function o(e,i,r){var o=new n;return i&&(o.fill="both",o.duration="auto"),"number"!=typeof e||isNaN(e)?void 0!==e&&Object.getOwnPropertyNames(e).forEach(function(i){if("auto"!=e[i]){if(("number"==typeof o[i]||"duration"==i)&&("number"!=typeof e[i]||isNaN(e[i])))return;if("fill"==i&&w.indexOf(e[i])==-1)return;if("direction"==i&&T.indexOf(e[i])==-1)return;if("playbackRate"==i&&1!==e[i]&&t.isDeprecated("AnimationEffectTiming.playbackRate","2014-11-28","Use Animation.playbackRate instead."))return;o[i]=e[i]}}):o.duration=e,o}function a(t){return"number"==typeof t&&(t=isNaN(t)?{duration:0}:{duration:t}),t}function s(e,i){return e=t.numericTimingToObject(e),o(e,i)}function u(t,e,i,n){return t<0||t>1||i<0||i>1?E:function(r){function o(t,e,i){return 3*t*(1-i)*(1-i)*i+3*e*(1-i)*i*i+i*i*i}if(r<=0){var a=0;return t>0?a=e/t:!e&&i>0&&(a=n/i),a*r}if(r>=1){var s=0;return i<1?s=(n-1)/(i-1):1==i&&t<1&&(s=(e-1)/(t-1)),1+s*(r-1)}for(var u=0,c=1;u<c;){var f=(u+c)/2,l=o(t,i,f);if(Math.abs(r-l)<1e-5)return o(e,n,f);l<r?u=f:c=f}return o(e,n,f)}}function c(t,e){return function(i){if(i>=1)return 1;var n=1/t;return i+=e*n,i-i%n}}function f(t){R||(R=document.createElement("div").style),R.animationTimingFunction="",R.animationTimingFunction=t;var e=R.animationTimingFunction;if(""==e&&r())throw new TypeError(t+" is not a valid value for easing");return e}function l(t){if("linear"==t)return E;var e=O.exec(t);if(e)return u.apply(this,e.slice(1).map(Number));var i=k.exec(t);if(i)return c(Number(i[1]),{start:x,middle:A,end:P}[i[2]]);var n=j[t];return n?n:E}function h(t){return Math.abs(m(t)/t.playbackRate)}function m(t){return 0===t.duration||0===t.iterations?0:t.duration*t.iterations}function d(t,e,i){if(null==e)return S;var n=i.delay+t+i.endDelay;return e<Math.min(i.delay,n)?C:e>=Math.min(i.delay+t,n)?D:F}function p(t,e,i,n,r){switch(n){case C:return"backwards"==e||"both"==e?0:null;case F:return i-r;case D:return"forwards"==e||"both"==e?t:null;case S:return null}}function _(t,e,i,n,r){var o=r;return 0===t?e!==C&&(o+=i):o+=n/t,o}function g(t,e,i,n,r,o){var a=t===1/0?e%1:t%1;return 0!==a||i!==D||0===n||0===r&&0!==o||(a=1),a}function b(t,e,i,n){return t===D&&e===1/0?1/0:1===i?Math.floor(n)-1:Math.floor(n)}function v(t,e,i){var n=t;if("normal"!==t&&"reverse"!==t){var r=e;"alternate-reverse"===t&&(r+=1),n="normal",r!==1/0&&r%2!==0&&(n="reverse")}return"normal"===n?i:1-i}function y(t,e,i){var n=d(t,e,i),r=p(t,i.fill,e,n,i.delay);if(null===r)return null;var o=_(i.duration,n,i.iterations,r,i.iterationStart),a=g(o,i.iterationStart,n,i.iterations,r,i.duration),s=b(n,i.iterations,a,o),u=v(i.direction,s,a);return i._easingFunction(u)}var w="backwards|forwards|both|none".split("|"),T="reverse|alternate|alternate-reverse".split("|"),E=function(t){return t};n.prototype={_setMember:function(e,i){this["_"+e]=i,this._effect&&(this._effect._timingInput[e]=i,this._effect._timing=t.normalizeTimingInput(this._effect._timingInput),this._effect.activeDuration=t.calculateActiveDuration(this._effect._timing),this._effect._animation&&this._effect._animation._rebuildUnderlyingAnimation())},get playbackRate(){return this._playbackRate},set delay(t){this._setMember("delay",t)},get delay(){return this._delay},set endDelay(t){this._setMember("endDelay",t)},get endDelay(){return this._endDelay},set fill(t){this._setMember("fill",t)},get fill(){return this._fill},set iterationStart(t){if((isNaN(t)||t<0)&&r())throw new TypeError("iterationStart must be a non-negative number, received: "+timing.iterationStart);this._setMember("iterationStart",t)},get iterationStart(){return this._iterationStart},set duration(t){if("auto"!=t&&(isNaN(t)||t<0)&&r())throw new TypeError("duration must be non-negative or auto, received: "+t);this._setMember("duration",t)},get duration(){return this._duration},set direction(t){this._setMember("direction",t)},get direction(){return this._direction},set easing(t){this._easingFunction=l(f(t)),this._setMember("easing",t)},get easing(){return this._easing},set iterations(t){if((isNaN(t)||t<0)&&r())throw new TypeError("iterations must be non-negative, received: "+t);this._setMember("iterations",t)},get iterations(){return this._iterations}};var x=1,A=.5,P=0,j={ease:u(.25,.1,.25,1),"ease-in":u(.42,0,1,1),"ease-out":u(0,0,.58,1),"ease-in-out":u(.42,0,.58,1),"step-start":c(1,x),"step-middle":c(1,A),"step-end":c(1,P)},R=null,N="\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*",O=new RegExp("cubic-bezier\\("+N+","+N+","+N+","+N+"\\)"),k=/steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,S=0,C=1,D=2,F=3;t.cloneTimingInput=i,t.makeTiming=o,t.numericTimingToObject=a,t.normalizeTimingInput=s,t.calculateActiveDuration=h,t.calculateIterationProgress=y,t.calculatePhase=d,t.normalizeEasing=f,t.parseEasingFunction=l}(c,f),function(t,e){function i(t,e){return t in f?f[t][e]||e:e}function n(t){return"display"===t||0===t.lastIndexOf("animation",0)||0===t.lastIndexOf("transition",0)}function r(t,e,r){if(!n(t)){var o=s[t];if(o){u.style[t]=e;for(var a in o){var c=o[a],f=u.style[c];r[c]=i(c,f)}}else r[t]=i(t,e)}}function o(t){var e=[];for(var i in t)if(!(i in["easing","offset","composite"])){var n=t[i];Array.isArray(n)||(n=[n]);for(var r,o=n.length,a=0;a<o;a++)r={},"offset"in t?r.offset=t.offset:1==o?r.offset=1:r.offset=a/(o-1),"easing"in t&&(r.easing=t.easing),"composite"in t&&(r.composite=t.composite),r[i]=n[a],e.push(r)}return e.sort(function(t,e){return t.offset-e.offset}),e}function a(e){function i(){var t=n.length;null==n[t-1].offset&&(n[t-1].offset=1),t>1&&null==n[0].offset&&(n[0].offset=0);for(var e=0,i=n[0].offset,r=1;r<t;r++){var o=n[r].offset;if(null!=o){for(var a=1;a<r-e;a++)n[e+a].offset=i+(o-i)*a/(r-e);e=r,i=o}}}if(null==e)return[];window.Symbol&&Symbol.iterator&&Array.prototype.from&&e[Symbol.iterator]&&(e=Array.from(e)),Array.isArray(e)||(e=o(e));for(var n=e.map(function(e){var i={};for(var n in e){var o=e[n];if("offset"==n){if(null!=o){if(o=Number(o),!isFinite(o))throw new TypeError("Keyframe offsets must be numbers.");if(o<0||o>1)throw new TypeError("Keyframe offsets must be between 0 and 1.")}}else if("composite"==n){if("add"==o||"accumulate"==o)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"add compositing is not supported"};if("replace"!=o)throw new TypeError("Invalid composite mode "+o+".")}else o="easing"==n?t.normalizeEasing(o):""+o;r(n,o,i)}return void 0==i.offset&&(i.offset=null),void 0==i.easing&&(i.easing="linear"),i}),a=!0,s=-(1/0),u=0;u<n.length;u++){var c=n[u].offset;if(null!=c){if(c<s)throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");s=c}else a=!1}return n=n.filter(function(t){return t.offset>=0&&t.offset<=1}),a||i(),n}var s={background:["backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","backgroundAttachment","backgroundOrigin","backgroundClip","backgroundColor"],border:["borderTopColor","borderTopStyle","borderTopWidth","borderRightColor","borderRightStyle","borderRightWidth","borderBottomColor","borderBottomStyle","borderBottomWidth","borderLeftColor","borderLeftStyle","borderLeftWidth"],borderBottom:["borderBottomWidth","borderBottomStyle","borderBottomColor"],borderColor:["borderTopColor","borderRightColor","borderBottomColor","borderLeftColor"],borderLeft:["borderLeftWidth","borderLeftStyle","borderLeftColor"],borderRadius:["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],borderRight:["borderRightWidth","borderRightStyle","borderRightColor"],borderTop:["borderTopWidth","borderTopStyle","borderTopColor"],borderWidth:["borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth"],flex:["flexGrow","flexShrink","flexBasis"],font:["fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineHeight"],margin:["marginTop","marginRight","marginBottom","marginLeft"],outline:["outlineColor","outlineStyle","outlineWidth"],padding:["paddingTop","paddingRight","paddingBottom","paddingLeft"]},u=document.createElementNS("http://www.w3.org/1999/xhtml","div"),c={thin:"1px",medium:"3px",thick:"5px"},f={borderBottomWidth:c,borderLeftWidth:c,borderRightWidth:c,borderTopWidth:c,fontSize:{"xx-small":"60%","x-small":"75%",small:"89%",medium:"100%",large:"120%","x-large":"150%","xx-large":"200%"},fontWeight:{normal:"400",bold:"700"},outlineWidth:c,textShadow:{none:"0px 0px 0px transparent"},boxShadow:{none:"0px 0px 0px 0px transparent"}};t.convertToArrayForm=o,t.normalizeKeyframes=a}(c,f),function(t){var e={};t.isDeprecated=function(t,i,n,r){var o=r?"are":"is",a=new Date,s=new Date(i);return s.setMonth(s.getMonth()+3),!(a<s&&(t in e||console.warn("Web Animations: "+t+" "+o+" deprecated and will stop working on "+s.toDateString()+". "+n),e[t]=!0,1))},t.deprecated=function(e,i,n,r){var o=r?"are":"is";if(t.isDeprecated(e,i,n,r))throw new Error(e+" "+o+" no longer supported. "+n)}}(c),function(){if(document.documentElement.animate){var a=document.documentElement.animate([],0),b=!0;if(a&&(b=!1,"play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function(t){void 0===a[t]&&(b=!0)})),!b)return}!function(t,e,i){function n(t){for(var e={},i=0;i<t.length;i++)for(var n in t[i])if("offset"!=n&&"easing"!=n&&"composite"!=n){var r={offset:t[i].offset,easing:t[i].easing,value:t[i][n]};e[n]=e[n]||[],e[n].push(r)}for(var o in e){var a=e[o];if(0!=a[0].offset||1!=a[a.length-1].offset)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"Partial keyframes are not supported"}}return e}function r(i){var n=[];for(var r in i)for(var o=i[r],a=0;a<o.length-1;a++){var s=a,u=a+1,c=o[s].offset,f=o[u].offset,l=c,h=f;0==a&&(l=-(1/0),0==f&&(u=s)),a==o.length-2&&(h=1/0,1==c&&(s=u)),n.push({applyFrom:l,applyTo:h,startOffset:o[s].offset,endOffset:o[u].offset,easingFunction:t.parseEasingFunction(o[s].easing),property:r,interpolation:e.propertyInterpolation(r,o[s].value,o[u].value)})}return n.sort(function(t,e){return t.startOffset-e.startOffset}),n}e.convertEffectInput=function(i){var o=t.normalizeKeyframes(i),a=n(o),s=r(a);return function(t,i){if(null!=i)s.filter(function(t){return i>=t.applyFrom&&i<t.applyTo}).forEach(function(n){var r=i-n.startOffset,o=n.endOffset-n.startOffset,a=0==o?0:n.easingFunction(r/o);e.apply(t,n.property,n.interpolation(a))});else for(var n in a)"offset"!=n&&"easing"!=n&&"composite"!=n&&e.clear(t,n)}}}(c,d,f),function(t,e,i){function n(t){return t.replace(/-(.)/g,function(t,e){return e.toUpperCase()})}function r(t,e,i){s[i]=s[i]||[],s[i].push([t,e])}function o(t,e,i){for(var o=0;o<i.length;o++){var a=i[o];r(t,e,n(a))}}function a(i,r,o){var a=i;/-/.test(i)&&!t.isDeprecated("Hyphenated property names","2016-03-22","Use camelCase instead.",!0)&&(a=n(i)),"initial"!=r&&"initial"!=o||("initial"==r&&(r=u[a]),"initial"==o&&(o=u[a]));for(var c=r==o?[]:s[a],f=0;c&&f<c.length;f++){var l=c[f][0](r),h=c[f][0](o);if(void 0!==l&&void 0!==h){var m=c[f][1](l,h);if(m){var d=e.Interpolation.apply(null,m);return function(t){return 0==t?r:1==t?o:d(t)}}}}return e.Interpolation(!1,!0,function(t){return t?o:r})}var s={};e.addPropertiesHandler=o;var u={backgroundColor:"transparent",backgroundPosition:"0% 0%",borderBottomColor:"currentColor",borderBottomLeftRadius:"0px",borderBottomRightRadius:"0px",borderBottomWidth:"3px",borderLeftColor:"currentColor",borderLeftWidth:"3px",borderRightColor:"currentColor",borderRightWidth:"3px",borderSpacing:"2px",borderTopColor:"currentColor",borderTopLeftRadius:"0px",borderTopRightRadius:"0px",borderTopWidth:"3px",bottom:"auto",clip:"rect(0px, 0px, 0px, 0px)",color:"black",fontSize:"100%",fontWeight:"400",height:"auto",left:"auto",letterSpacing:"normal",lineHeight:"120%",marginBottom:"0px",marginLeft:"0px",marginRight:"0px",marginTop:"0px",maxHeight:"none",maxWidth:"none",minHeight:"0px",minWidth:"0px",opacity:"1.0",outlineColor:"invert",outlineOffset:"0px",outlineWidth:"3px",paddingBottom:"0px",paddingLeft:"0px",paddingRight:"0px",paddingTop:"0px",right:"auto",textIndent:"0px",textShadow:"0px 0px 0px transparent",top:"auto",transform:"",verticalAlign:"0px",visibility:"visible",width:"auto",wordSpacing:"normal",zIndex:"auto"};e.propertyInterpolation=a}(c,d,f),function(t,e,i){function n(e){var i=t.calculateActiveDuration(e),n=function(n){return t.calculateIterationProgress(i,n,e)};return n._totalDuration=e.delay+i+e.endDelay,n}e.KeyframeEffect=function(i,r,o,a){var s,u=n(t.normalizeTimingInput(o)),c=e.convertEffectInput(r),f=function(){c(i,s)};return f._update=function(t){return s=u(t),null!==s},f._clear=function(){c(i,null)},f._hasSameTarget=function(t){return i===t},f._target=i,f._totalDuration=u._totalDuration,f._id=a,f},e.NullEffect=function(t){var e=function(){t&&(t(),t=null)};return e._update=function(){return null},e._totalDuration=0,e._hasSameTarget=function(){return!1},e}}(c,d,f),function(t,e){t.apply=function(e,i,n){e.style[t.propertyName(i)]=n},t.clear=function(e,i){e.style[t.propertyName(i)]=""}}(d,f),function(t){window.Element.prototype.animate=function(e,i){var n="";return i&&i.id&&(n=i.id),t.timeline._play(t.KeyframeEffect(this,e,i,n))}}(d),function(t,e){function i(t,e,n){if("number"==typeof t&&"number"==typeof e)return t*(1-n)+e*n;if("boolean"==typeof t&&"boolean"==typeof e)return n<.5?t:e;if(t.length==e.length){for(var r=[],o=0;o<t.length;o++)r.push(i(t[o],e[o],n));return r}throw"Mismatched interpolation arguments "+t+":"+e}t.Interpolation=function(t,e,n){return function(r){return n(i(t,e,r))}}}(d,f),function(t,e,i){t.sequenceNumber=0;var n=function(t,e,i){this.target=t,this.currentTime=e,this.timelineTime=i,this.type="finish",this.bubbles=!1,this.cancelable=!1,this.currentTarget=t,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()};e.Animation=function(e){this.id="",e&&e._id&&(this.id=e._id),this._sequenceNumber=t.sequenceNumber++,this._currentTime=0,this._startTime=null,this._paused=!1,this._playbackRate=1,this._inTimeline=!0,this._finishedFlag=!0,this.onfinish=null,this._finishHandlers=[],this._effect=e,this._inEffect=this._effect._update(0),this._idle=!0,this._currentTimePending=!1},e.Animation.prototype={_ensureAlive:function(){this.playbackRate<0&&0===this.currentTime?this._inEffect=this._effect._update(-1):this._inEffect=this._effect._update(this.currentTime),this._inTimeline||!this._inEffect&&this._finishedFlag||(this._inTimeline=!0,e.timeline._animations.push(this))},_tickCurrentTime:function(t,e){t!=this._currentTime&&(this._currentTime=t,this._isFinished&&!e&&(this._currentTime=this._playbackRate>0?this._totalDuration:0),this._ensureAlive())},get currentTime(){return this._idle||this._currentTimePending?null:this._currentTime},set currentTime(t){t=+t,isNaN(t)||(e.restart(),this._paused||null==this._startTime||(this._startTime=this._timeline.currentTime-t/this._playbackRate),this._currentTimePending=!1,this._currentTime!=t&&(this._idle&&(this._idle=!1,this._paused=!0),this._tickCurrentTime(t,!0),e.applyDirtiedAnimation(this)))},get startTime(){return this._startTime},set startTime(t){t=+t,isNaN(t)||this._paused||this._idle||(this._startTime=t,this._tickCurrentTime((this._timeline.currentTime-this._startTime)*this.playbackRate),e.applyDirtiedAnimation(this))},get playbackRate(){return this._playbackRate},set playbackRate(t){if(t!=this._playbackRate){var i=this.currentTime;this._playbackRate=t,this._startTime=null,"paused"!=this.playState&&"idle"!=this.playState&&(this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),e.applyDirtiedAnimation(this)),null!=i&&(this.currentTime=i)}},get _isFinished(){return!this._idle&&(this._playbackRate>0&&this._currentTime>=this._totalDuration||this._playbackRate<0&&this._currentTime<=0)},get _totalDuration(){return this._effect._totalDuration},get playState(){return this._idle?"idle":null==this._startTime&&!this._paused&&0!=this.playbackRate||this._currentTimePending?"pending":this._paused?"paused":this._isFinished?"finished":"running"},_rewind:function(){if(this._playbackRate>=0)this._currentTime=0;else{if(!(this._totalDuration<1/0))throw new DOMException("Unable to rewind negative playback rate animation with infinite duration","InvalidStateError");this._currentTime=this._totalDuration}},play:function(){this._paused=!1,(this._isFinished||this._idle)&&(this._rewind(),this._startTime=null),this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),e.applyDirtiedAnimation(this)},pause:function(){this._isFinished||this._paused||this._idle?this._idle&&(this._rewind(),this._idle=!1):this._currentTimePending=!0,this._startTime=null,this._paused=!0},finish:function(){this._idle||(this.currentTime=this._playbackRate>0?this._totalDuration:0,this._startTime=this._totalDuration-this.currentTime,this._currentTimePending=!1,e.applyDirtiedAnimation(this))},cancel:function(){this._inEffect&&(this._inEffect=!1,this._idle=!0,this._paused=!1,this._isFinished=!0,this._finishedFlag=!0,this._currentTime=0,this._startTime=null,this._effect._update(null),e.applyDirtiedAnimation(this))},reverse:function(){this.playbackRate*=-1,this.play()},addEventListener:function(t,e){"function"==typeof e&&"finish"==t&&this._finishHandlers.push(e)},removeEventListener:function(t,e){if("finish"==t){var i=this._finishHandlers.indexOf(e);i>=0&&this._finishHandlers.splice(i,1)}},_fireEvents:function(t){if(this._isFinished){if(!this._finishedFlag){var e=new n(this,this._currentTime,t),i=this._finishHandlers.concat(this.onfinish?[this.onfinish]:[]);setTimeout(function(){i.forEach(function(t){t.call(e.target,e)})},0),this._finishedFlag=!0}}else this._finishedFlag=!1},_tick:function(t,e){this._idle||this._paused||(null==this._startTime?e&&(this.startTime=t-this._currentTime/this.playbackRate):this._isFinished||this._tickCurrentTime((t-this._startTime)*this.playbackRate)),e&&(this._currentTimePending=!1,this._fireEvents(t))},get _needsTick(){return this.playState in{pending:1,running:1}||!this._finishedFlag},_targetAnimations:function(){var t=this._effect._target;return t._activeAnimations||(t._activeAnimations=[]),t._activeAnimations},_markTarget:function(){var t=this._targetAnimations();t.indexOf(this)===-1&&t.push(this)},_unmarkTarget:function(){var t=this._targetAnimations(),e=t.indexOf(this);e!==-1&&t.splice(e,1)}}}(c,d,f),function(t,e,i){function n(t){var e=c;c=[],t<_.currentTime&&(t=_.currentTime),_._animations.sort(r),_._animations=s(t,!0,_._animations)[0],e.forEach(function(e){e[1](t)}),a(),l=void 0}function r(t,e){return t._sequenceNumber-e._sequenceNumber}function o(){this._animations=[],this.currentTime=window.performance&&performance.now?performance.now():0}function a(){d.forEach(function(t){t()}),d.length=0}function s(t,i,n){p=!0,m=!1;var r=e.timeline;r.currentTime=t,h=!1;var o=[],a=[],s=[],u=[];return n.forEach(function(e){e._tick(t,i),e._inEffect?(a.push(e._effect),e._markTarget()):(o.push(e._effect),e._unmarkTarget()),e._needsTick&&(h=!0);var n=e._inEffect||e._needsTick;e._inTimeline=n,n?s.push(e):u.push(e)}),d.push.apply(d,o),d.push.apply(d,a),h&&requestAnimationFrame(function(){}),p=!1,[s,u]}var u=window.requestAnimationFrame,c=[],f=0;window.requestAnimationFrame=function(t){var e=f++;return 0==c.length&&u(n),c.push([e,t]),e},window.cancelAnimationFrame=function(t){c.forEach(function(e){e[0]==t&&(e[1]=function(){})})},o.prototype={_play:function(i){i._timing=t.normalizeTimingInput(i.timing);var n=new e.Animation(i);return n._idle=!1,n._timeline=this,this._animations.push(n),e.restart(),e.applyDirtiedAnimation(n),n}};var l=void 0,h=!1,m=!1;e.restart=function(){return h||(h=!0,requestAnimationFrame(function(){}),m=!0),m},e.applyDirtiedAnimation=function(t){if(!p){t._markTarget();var i=t._targetAnimations();i.sort(r);var n=s(e.timeline.currentTime,!1,i.slice())[1];n.forEach(function(t){var e=_._animations.indexOf(t);e!==-1&&_._animations.splice(e,1)}),a()}};var d=[],p=!1,_=new o;e.timeline=_}(c,d,f),function(t){function e(t,e){var i=t.exec(e);if(i)return i=t.ignoreCase?i[0].toLowerCase():i[0],[i,e.substr(i.length)]}function i(t,e){e=e.replace(/^\s*/,"");var i=t(e);if(i)return[i[0],i[1].replace(/^\s*/,"")]}function n(t,n,r){t=i.bind(null,t);for(var o=[];;){var a=t(r);if(!a)return[o,r];if(o.push(a[0]),r=a[1],a=e(n,r),!a||""==a[1])return[o,r];r=a[1]}}function r(t,e){for(var i=0,n=0;n<e.length&&(!/\s|,/.test(e[n])||0!=i);n++)if("("==e[n])i++;else if(")"==e[n]&&(i--,0==i&&n++,i<=0))break;var r=t(e.substr(0,n));return void 0==r?void 0:[r,e.substr(n)]}function o(t,e){for(var i=t,n=e;i&&n;)i>n?i%=n:n%=i;return i=t*e/(i+n)}function a(t){return function(e){var i=t(e);return i&&(i[0]=void 0),i}}function s(t,e){return function(i){var n=t(i);return n?n:[e,i]}}function u(e,i){for(var n=[],r=0;r<e.length;r++){var o=t.consumeTrimmed(e[r],i);if(!o||""==o[0])return;void 0!==o[0]&&n.push(o[0]),i=o[1]}if(""==i)return n}function c(t,e,i,n,r){for(var a=[],s=[],u=[],c=o(n.length,r.length),f=0;f<c;f++){var l=e(n[f%n.length],r[f%r.length]);if(!l)return;a.push(l[0]),s.push(l[1]),u.push(l[2])}return[a,s,function(e){var n=e.map(function(t,e){return u[e](t)}).join(i);return t?t(n):n}]}function f(t,e,i){for(var n=[],r=[],o=[],a=0,s=0;s<i.length;s++)if("function"==typeof i[s]){var u=i[s](t[a],e[a++]);n.push(u[0]),r.push(u[1]),o.push(u[2])}else!function(t){n.push(!1),r.push(!1),o.push(function(){return i[t]})}(s);return[n,r,function(t){for(var e="",i=0;i<t.length;i++)e+=o[i](t[i]);return e}]}t.consumeToken=e,t.consumeTrimmed=i,t.consumeRepeated=n,t.consumeParenthesised=r,t.ignore=a,t.optional=s,t.consumeList=u,t.mergeNestedRepeated=c.bind(null,null),t.mergeWrappedNestedRepeated=c,t.mergeList=f}(d),function(t){function e(e){function i(e){var i=t.consumeToken(/^inset/i,e);if(i)return n.inset=!0,i;var i=t.consumeLengthOrPercent(e);if(i)return n.lengths.push(i[0]),i;var i=t.consumeColor(e);return i?(n.color=i[0],i):void 0}var n={inset:!1,lengths:[],color:null},r=t.consumeRepeated(i,/^/,e);if(r&&r[0].length)return[n,r[1]]}function i(i){var n=t.consumeRepeated(e,/^,/,i);if(n&&""==n[1])return n[0]}function n(e,i){for(;e.lengths.length<Math.max(e.lengths.length,i.lengths.length);)e.lengths.push({px:0});for(;i.lengths.length<Math.max(e.lengths.length,i.lengths.length);)i.lengths.push({px:0});if(e.inset==i.inset&&!!e.color==!!i.color){for(var n,r=[],o=[[],0],a=[[],0],s=0;s<e.lengths.length;s++){var u=t.mergeDimensions(e.lengths[s],i.lengths[s],2==s);o[0].push(u[0]),a[0].push(u[1]),r.push(u[2])}if(e.color&&i.color){var c=t.mergeColors(e.color,i.color);o[1]=c[0],a[1]=c[1],n=c[2]}return[o,a,function(t){for(var i=e.inset?"inset ":" ",o=0;o<r.length;o++)i+=r[o](t[0][o])+" ";return n&&(i+=n(t[1])),i}]}}function r(e,i,n,r){function o(t){return{inset:t,color:[0,0,0,0],lengths:[{px:0},{px:0},{px:0},{px:0}]}}for(var a=[],s=[],u=0;u<n.length||u<r.length;u++){var c=n[u]||o(r[u].inset),f=r[u]||o(n[u].inset);a.push(c),s.push(f)}return t.mergeNestedRepeated(e,i,a,s)}var o=r.bind(null,n,", ");t.addPropertiesHandler(i,o,["box-shadow","text-shadow"])}(d),function(t,e){function i(t){return t.toFixed(3).replace(".000","")}function n(t,e,i){return Math.min(e,Math.max(t,i))}function r(t){if(/^\s*[-+]?(\d*\.)?\d+\s*$/.test(t))return Number(t)}function o(t,e){return[t,e,i]}function a(t,e){if(0!=t)return u(0,1/0)(t,e)}function s(t,e){return[t,e,function(t){return Math.round(n(1,1/0,t))}]}function u(t,e){return function(r,o){return[r,o,function(r){return i(n(t,e,r))}]}}function c(t,e){return[t,e,Math.round]}t.clamp=n,t.addPropertiesHandler(r,u(0,1/0),["border-image-width","line-height"]),t.addPropertiesHandler(r,u(0,1),["opacity","shape-image-threshold"]),t.addPropertiesHandler(r,a,["flex-grow","flex-shrink"]),t.addPropertiesHandler(r,s,["orphans","widows"]),t.addPropertiesHandler(r,c,["z-index"]),t.parseNumber=r,t.mergeNumbers=o,t.numberToString=i}(d,f),function(t,e){function i(t,e){if("visible"==t||"visible"==e)return[0,1,function(i){return i<=0?t:i>=1?e:"visible"}]}t.addPropertiesHandler(String,i,["visibility"])}(d),function(t,e){function i(t){t=t.trim(),o.fillStyle="#000",o.fillStyle=t;var e=o.fillStyle;if(o.fillStyle="#fff",o.fillStyle=t,e==o.fillStyle){o.fillRect(0,0,1,1);var i=o.getImageData(0,0,1,1).data;o.clearRect(0,0,1,1);var n=i[3]/255;return[i[0]*n,i[1]*n,i[2]*n,n]}}function n(e,i){return[e,i,function(e){function i(t){return Math.max(0,Math.min(255,t))}if(e[3])for(var n=0;n<3;n++)e[n]=Math.round(i(e[n]/e[3]));return e[3]=t.numberToString(t.clamp(0,1,e[3])),"rgba("+e.join(",")+")"}]}var r=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");r.width=r.height=1;var o=r.getContext("2d");t.addPropertiesHandler(i,n,["background-color","border-bottom-color","border-left-color","border-right-color","border-top-color","color","outline-color","text-decoration-color"]),t.consumeColor=t.consumeParenthesised.bind(null,i),t.mergeColors=n}(d,f),function(a,b){function c(a,b){if(b=b.trim().toLowerCase(),"0"==b&&"px".search(a)>=0)return{px:0};if(/^[^(]*$|^calc/.test(b)){b=b.replace(/calc\(/g,"(");var c={};b=b.replace(a,function(t){return c[t]=null,"U"+t});for(var d="U("+a.source+")",e=b.replace(/[-+]?(\d*\.)?\d+/g,"N").replace(new RegExp("N"+d,"g"),"D").replace(/\s[+-]\s/g,"O").replace(/\s/g,""),f=[/N\*(D)/g,/(N|D)[*\/]N/g,/(N|D)O\1/g,/\((N|D)\)/g],g=0;g<f.length;)f[g].test(e)?(e=e.replace(f[g],"$1"),g=0):g++;if("D"==e){for(var h in c){var i=eval(b.replace(new RegExp("U"+h,"g"),"").replace(new RegExp(d,"g"),"*0"));if(!isFinite(i))return;c[h]=i}return c}}}function d(t,i){return e(t,i,!0)}function e(t,e,i){var n,r=[];for(n in t)r.push(n);for(n in e)r.indexOf(n)<0&&r.push(n);return t=r.map(function(e){return t[e]||0}),e=r.map(function(t){return e[t]||0}),[t,e,function(t){var e=t.map(function(e,n){return 1==t.length&&i&&(e=Math.max(e,0)),a.numberToString(e)+r[n]}).join(" + ");return t.length>1?"calc("+e+")":e}]}var f="px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc",g=c.bind(null,new RegExp(f,"g")),h=c.bind(null,new RegExp(f+"|%","g")),i=c.bind(null,/deg|rad|grad|turn/g);a.parseLength=g,a.parseLengthOrPercent=h,a.consumeLengthOrPercent=a.consumeParenthesised.bind(null,h),a.parseAngle=i,a.mergeDimensions=e;var j=a.consumeParenthesised.bind(null,g),k=a.consumeRepeated.bind(void 0,j,/^/),l=a.consumeRepeated.bind(void 0,k,/^,/);a.consumeSizePairList=l;var m=function(t){var e=l(t);if(e&&""==e[1])return e[0]},n=a.mergeNestedRepeated.bind(void 0,d," "),o=a.mergeNestedRepeated.bind(void 0,n,",");a.mergeNonNegativeSizePair=n,a.addPropertiesHandler(m,o,["background-size"]),a.addPropertiesHandler(h,d,["border-bottom-width","border-image-width","border-left-width","border-right-width","border-top-width","flex-basis","font-size","height","line-height","max-height","max-width","outline-width","width"]),a.addPropertiesHandler(h,e,["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius","bottom","left","letter-spacing","margin-bottom","margin-left","margin-right","margin-top","min-height","min-width","outline-offset","padding-bottom","padding-left","padding-right","padding-top","perspective","right","shape-margin","text-indent","top","vertical-align","word-spacing"])}(d,f),function(t,e){function i(e){return t.consumeLengthOrPercent(e)||t.consumeToken(/^auto/,e)}function n(e){var n=t.consumeList([t.ignore(t.consumeToken.bind(null,/^rect/)),t.ignore(t.consumeToken.bind(null,/^\(/)),t.consumeRepeated.bind(null,i,/^,/),t.ignore(t.consumeToken.bind(null,/^\)/))],e);if(n&&4==n[0].length)return n[0]}function r(e,i){return"auto"==e||"auto"==i?[!0,!1,function(n){var r=n?e:i;if("auto"==r)return"auto";var o=t.mergeDimensions(r,r);return o[2](o[0])}]:t.mergeDimensions(e,i)}function o(t){return"rect("+t+")"}var a=t.mergeWrappedNestedRepeated.bind(null,o,r,", ");t.parseBox=n,t.mergeBoxes=a,t.addPropertiesHandler(n,a,["clip"])}(d,f),function(t,e){function i(t){return function(e){var i=0;return t.map(function(t){return t===f?e[i++]:t})}}function n(t){return t}function r(e){if(e=e.toLowerCase().trim(),"none"==e)return[];for(var i,n=/\s*(\w+)\(([^)]*)\)/g,r=[],o=0;i=n.exec(e);){if(i.index!=o)return;o=i.index+i[0].length;var a=i[1],s=m[a];if(!s)return;var u=i[2].split(","),c=s[0];if(c.length<u.length)return;for(var f=[],d=0;d<c.length;d++){var p,_=u[d],g=c[d];if(p=_?{A:function(e){return"0"==e.trim()?h:t.parseAngle(e)},N:t.parseNumber,T:t.parseLengthOrPercent,L:t.parseLength}[g.toUpperCase()](_):{a:h,n:f[0],t:l}[g],void 0===p)return;f.push(p)}if(r.push({t:a,d:f}),n.lastIndex==e.length)return r}}function o(t){return t.toFixed(6).replace(".000000","")}function a(e,i){if(e.decompositionPair!==i){e.decompositionPair=i;var n=t.makeMatrixDecomposition(e)}if(i.decompositionPair!==e){i.decompositionPair=e;var r=t.makeMatrixDecomposition(i)}return null==n[0]||null==r[0]?[[!1],[!0],function(t){return t?i[0].d:e[0].d}]:(n[0].push(0),r[0].push(1),[n,r,function(e){var i=t.quat(n[0][3],r[0][3],e[5]),a=t.composeMatrix(e[0],e[1],e[2],i,e[4]),s=a.map(o).join(",");return s}])}function s(t){return t.replace(/[xy]/,"")}function u(t){return t.replace(/(x|y|z|3d)?$/,"3d")}function c(e,i){var n=t.makeMatrixDecomposition&&!0,r=!1;if(!e.length||!i.length){e.length||(r=!0,e=i,i=[]);for(var o=0;o<e.length;o++){var c=e[o].t,f=e[o].d,l="scale"==c.substr(0,5)?1:0;i.push({t:c,d:f.map(function(t){if("number"==typeof t)return l;var e={};for(var i in t)e[i]=l;return e})})}}var h=function(t,e){return"perspective"==t&&"perspective"==e||("matrix"==t||"matrix3d"==t)&&("matrix"==e||"matrix3d"==e)},d=[],p=[],_=[];if(e.length!=i.length){if(!n)return;var g=a(e,i);d=[g[0]],p=[g[1]],_=[["matrix",[g[2]]]]}else for(var o=0;o<e.length;o++){var c,b=e[o].t,v=i[o].t,y=e[o].d,w=i[o].d,T=m[b],E=m[v];if(h(b,v)){if(!n)return;var g=a([e[o]],[i[o]]);d.push(g[0]),p.push(g[1]),_.push(["matrix",[g[2]]])}else{if(b==v)c=b;else if(T[2]&&E[2]&&s(b)==s(v))c=s(b),y=T[2](y),w=E[2](w);else{if(!T[1]||!E[1]||u(b)!=u(v)){if(!n)return;var g=a(e,i);d=[g[0]],p=[g[1]],_=[["matrix",[g[2]]]];break}c=u(b),y=T[1](y),w=E[1](w)}for(var x=[],A=[],P=[],j=0;j<y.length;j++){var R="number"==typeof y[j]?t.mergeNumbers:t.mergeDimensions,g=R(y[j],w[j]);x[j]=g[0],A[j]=g[1],P.push(g[2])}d.push(x),p.push(A),_.push([c,P])}}if(r){var N=d;d=p,p=N}return[d,p,function(t){return t.map(function(t,e){var i=t.map(function(t,i){return _[e][1][i](t)}).join(",");return"matrix"==_[e][0]&&16==i.split(",").length&&(_[e][0]="matrix3d"),_[e][0]+"("+i+")"}).join(" ")}]}var f=null,l={px:0},h={deg:0},m={matrix:["NNNNNN",[f,f,0,0,f,f,0,0,0,0,1,0,f,f,0,1],n],matrix3d:["NNNNNNNNNNNNNNNN",n],rotate:["A"],rotatex:["A"],rotatey:["A"],rotatez:["A"],rotate3d:["NNNA"],perspective:["L"],scale:["Nn",i([f,f,1]),n],scalex:["N",i([f,1,1]),i([f,1])],scaley:["N",i([1,f,1]),i([1,f])],scalez:["N",i([1,1,f])],scale3d:["NNN",n],skew:["Aa",null,n],skewx:["A",null,i([f,h])],skewy:["A",null,i([h,f])],translate:["Tt",i([f,f,l]),n],translatex:["T",i([f,l,l]),i([f,l])],translatey:["T",i([l,f,l]),i([l,f])],translatez:["L",i([l,l,f])],translate3d:["TTL",n]};t.addPropertiesHandler(r,c,["transform"])}(d,f),function(t,e){function i(t,e){e.concat([t]).forEach(function(e){e in document.documentElement.style&&(n[t]=e)})}var n={};i("transform",["webkitTransform","msTransform"]),i("transformOrigin",["webkitTransformOrigin"]),i("perspective",["webkitPerspective"]),i("perspectiveOrigin",["webkitPerspectiveOrigin"]),t.propertyName=function(t){return n[t]||t}}(d,f)}(),!function(){if(void 0===document.createElement("div").animate([]).oncancel){var t;if(window.performance&&performance.now)var t=function(){return performance.now()};else var t=function(){return Date.now()};var e=function(t,e,i){this.target=t,this.currentTime=e,this.timelineTime=i,this.type="cancel",this.bubbles=!1,this.cancelable=!1,
this.currentTarget=t,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()},i=window.Element.prototype.animate;window.Element.prototype.animate=function(n,r){var o=i.call(this,n,r);o._cancelHandlers=[],o.oncancel=null;var a=o.cancel;o.cancel=function(){a.call(this);var i=new e(this,null,t()),n=this._cancelHandlers.concat(this.oncancel?[this.oncancel]:[]);setTimeout(function(){n.forEach(function(t){t.call(i.target,i)})},0)};var s=o.addEventListener;o.addEventListener=function(t,e){"function"==typeof e&&"cancel"==t?this._cancelHandlers.push(e):s.call(this,t,e)};var u=o.removeEventListener;return o.removeEventListener=function(t,e){if("cancel"==t){var i=this._cancelHandlers.indexOf(e);i>=0&&this._cancelHandlers.splice(i,1)}else u.call(this,t,e)},o}}}(),function(t){var e=document.documentElement,i=null,n=!1;try{var r=getComputedStyle(e).getPropertyValue("opacity"),o="0"==r?"1":"0";i=e.animate({opacity:[o,o]},{duration:1}),i.currentTime=0,n=getComputedStyle(e).getPropertyValue("opacity")==o}catch(t){}finally{i&&i.cancel()}if(!n){var a=window.Element.prototype.animate;window.Element.prototype.animate=function(e,i){return window.Symbol&&Symbol.iterator&&Array.prototype.from&&e[Symbol.iterator]&&(e=Array.from(e)),Array.isArray(e)||null===e||(e=t.convertToArrayForm(e)),a.call(this,e,i)}}}(c),!function(t,e,i){function n(t){var i=e.timeline;i.currentTime=t,i._discardAnimations(),0==i._animations.length?o=!1:requestAnimationFrame(n)}var r=window.requestAnimationFrame;window.requestAnimationFrame=function(t){return r(function(i){e.timeline._updateAnimationsPromises(),t(i),e.timeline._updateAnimationsPromises()})},e.AnimationTimeline=function(){this._animations=[],this.currentTime=void 0},e.AnimationTimeline.prototype={getAnimations:function(){return this._discardAnimations(),this._animations.slice()},_updateAnimationsPromises:function(){e.animationsWithPromises=e.animationsWithPromises.filter(function(t){return t._updatePromises()})},_discardAnimations:function(){this._updateAnimationsPromises(),this._animations=this._animations.filter(function(t){return"finished"!=t.playState&&"idle"!=t.playState})},_play:function(t){var i=new e.Animation(t,this);return this._animations.push(i),e.restartWebAnimationsNextTick(),i._updatePromises(),i._animation.play(),i._updatePromises(),i},play:function(t){return t&&t.remove(),this._play(t)}};var o=!1;e.restartWebAnimationsNextTick=function(){o||(o=!0,requestAnimationFrame(n))};var a=new e.AnimationTimeline;e.timeline=a;try{Object.defineProperty(window.document,"timeline",{configurable:!0,get:function(){return a}})}catch(t){}try{window.document.timeline=a}catch(t){}}(c,e,f),function(t,e,i){e.animationsWithPromises=[],e.Animation=function(e,i){if(this.id="",e&&e._id&&(this.id=e._id),this.effect=e,e&&(e._animation=this),!i)throw new Error("Animation with null timeline is not supported");this._timeline=i,this._sequenceNumber=t.sequenceNumber++,this._holdTime=0,this._paused=!1,this._isGroup=!1,this._animation=null,this._childAnimations=[],this._callback=null,this._oldPlayState="idle",this._rebuildUnderlyingAnimation(),this._animation.cancel(),this._updatePromises()},e.Animation.prototype={_updatePromises:function(){var t=this._oldPlayState,e=this.playState;return this._readyPromise&&e!==t&&("idle"==e?(this._rejectReadyPromise(),this._readyPromise=void 0):"pending"==t?this._resolveReadyPromise():"pending"==e&&(this._readyPromise=void 0)),this._finishedPromise&&e!==t&&("idle"==e?(this._rejectFinishedPromise(),this._finishedPromise=void 0):"finished"==e?this._resolveFinishedPromise():"finished"==t&&(this._finishedPromise=void 0)),this._oldPlayState=this.playState,this._readyPromise||this._finishedPromise},_rebuildUnderlyingAnimation:function(){this._updatePromises();var t,i,n,r,o=!!this._animation;o&&(t=this.playbackRate,i=this._paused,n=this.startTime,r=this.currentTime,this._animation.cancel(),this._animation._wrapper=null,this._animation=null),(!this.effect||this.effect instanceof window.KeyframeEffect)&&(this._animation=e.newUnderlyingAnimationForKeyframeEffect(this.effect),e.bindAnimationForKeyframeEffect(this)),(this.effect instanceof window.SequenceEffect||this.effect instanceof window.GroupEffect)&&(this._animation=e.newUnderlyingAnimationForGroup(this.effect),e.bindAnimationForGroup(this)),this.effect&&this.effect._onsample&&e.bindAnimationForCustomEffect(this),o&&(1!=t&&(this.playbackRate=t),null!==n?this.startTime=n:null!==r?this.currentTime=r:null!==this._holdTime&&(this.currentTime=this._holdTime),i&&this.pause()),this._updatePromises()},_updateChildren:function(){if(this.effect&&"idle"!=this.playState){var t=this.effect._timing.delay;this._childAnimations.forEach(function(i){this._arrangeChildren(i,t),this.effect instanceof window.SequenceEffect&&(t+=e.groupChildDuration(i.effect))}.bind(this))}},_setExternalAnimation:function(t){if(this.effect&&this._isGroup)for(var e=0;e<this.effect.children.length;e++)this.effect.children[e]._animation=t,this._childAnimations[e]._setExternalAnimation(t)},_constructChildAnimations:function(){if(this.effect&&this._isGroup){var t=this.effect._timing.delay;this._removeChildAnimations(),this.effect.children.forEach(function(i){var n=e.timeline._play(i);this._childAnimations.push(n),n.playbackRate=this.playbackRate,this._paused&&n.pause(),i._animation=this.effect._animation,this._arrangeChildren(n,t),this.effect instanceof window.SequenceEffect&&(t+=e.groupChildDuration(i))}.bind(this))}},_arrangeChildren:function(t,e){null===this.startTime?t.currentTime=this.currentTime-e/this.playbackRate:t.startTime!==this.startTime+e/this.playbackRate&&(t.startTime=this.startTime+e/this.playbackRate)},get timeline(){return this._timeline},get playState(){return this._animation?this._animation.playState:"idle"},get finished(){return window.Promise?(this._finishedPromise||(e.animationsWithPromises.indexOf(this)==-1&&e.animationsWithPromises.push(this),this._finishedPromise=new Promise(function(t,e){this._resolveFinishedPromise=function(){t(this)},this._rejectFinishedPromise=function(){e({type:DOMException.ABORT_ERR,name:"AbortError"})}}.bind(this)),"finished"==this.playState&&this._resolveFinishedPromise()),this._finishedPromise):(console.warn("Animation Promises require JavaScript Promise constructor"),null)},get ready(){return window.Promise?(this._readyPromise||(e.animationsWithPromises.indexOf(this)==-1&&e.animationsWithPromises.push(this),this._readyPromise=new Promise(function(t,e){this._resolveReadyPromise=function(){t(this)},this._rejectReadyPromise=function(){e({type:DOMException.ABORT_ERR,name:"AbortError"})}}.bind(this)),"pending"!==this.playState&&this._resolveReadyPromise()),this._readyPromise):(console.warn("Animation Promises require JavaScript Promise constructor"),null)},get onfinish(){return this._animation.onfinish},set onfinish(t){"function"==typeof t?this._animation.onfinish=function(e){e.target=this,t.call(this,e)}.bind(this):this._animation.onfinish=t},get oncancel(){return this._animation.oncancel},set oncancel(t){"function"==typeof t?this._animation.oncancel=function(e){e.target=this,t.call(this,e)}.bind(this):this._animation.oncancel=t},get currentTime(){this._updatePromises();var t=this._animation.currentTime;return this._updatePromises(),t},set currentTime(t){this._updatePromises(),this._animation.currentTime=isFinite(t)?t:Math.sign(t)*Number.MAX_VALUE,this._register(),this._forEachChild(function(e,i){e.currentTime=t-i}),this._updatePromises()},get startTime(){return this._animation.startTime},set startTime(t){this._updatePromises(),this._animation.startTime=isFinite(t)?t:Math.sign(t)*Number.MAX_VALUE,this._register(),this._forEachChild(function(e,i){e.startTime=t+i}),this._updatePromises()},get playbackRate(){return this._animation.playbackRate},set playbackRate(t){this._updatePromises();var e=this.currentTime;this._animation.playbackRate=t,this._forEachChild(function(e){e.playbackRate=t}),null!==e&&(this.currentTime=e),this._updatePromises()},play:function(){this._updatePromises(),this._paused=!1,this._animation.play(),this._timeline._animations.indexOf(this)==-1&&this._timeline._animations.push(this),this._register(),e.awaitStartTime(this),this._forEachChild(function(t){var e=t.currentTime;t.play(),t.currentTime=e}),this._updatePromises()},pause:function(){this._updatePromises(),this.currentTime&&(this._holdTime=this.currentTime),this._animation.pause(),this._register(),this._forEachChild(function(t){t.pause()}),this._paused=!0,this._updatePromises()},finish:function(){this._updatePromises(),this._animation.finish(),this._register(),this._updatePromises()},cancel:function(){this._updatePromises(),this._animation.cancel(),this._register(),this._removeChildAnimations(),this._updatePromises()},reverse:function(){this._updatePromises();var t=this.currentTime;this._animation.reverse(),this._forEachChild(function(t){t.reverse()}),null!==t&&(this.currentTime=t),this._updatePromises()},addEventListener:function(t,e){var i=e;"function"==typeof e&&(i=function(t){t.target=this,e.call(this,t)}.bind(this),e._wrapper=i),this._animation.addEventListener(t,i)},removeEventListener:function(t,e){this._animation.removeEventListener(t,e&&e._wrapper||e)},_removeChildAnimations:function(){for(;this._childAnimations.length;)this._childAnimations.pop().cancel()},_forEachChild:function(e){var i=0;if(this.effect.children&&this._childAnimations.length<this.effect.children.length&&this._constructChildAnimations(),this._childAnimations.forEach(function(t){e.call(this,t,i),this.effect instanceof window.SequenceEffect&&(i+=t.effect.activeDuration)}.bind(this)),"pending"!=this.playState){var n=this.effect._timing,r=this.currentTime;null!==r&&(r=t.calculateIterationProgress(t.calculateActiveDuration(n),r,n)),(null==r||isNaN(r))&&this._removeChildAnimations()}}},window.Animation=e.Animation}(c,e,f),function(t,e,i){function n(e){this._frames=t.normalizeKeyframes(e)}function r(){for(var t=!1;u.length;){var e=u.shift();e._updateChildren(),t=!0}return t}var o=function(t){if(t._animation=void 0,t instanceof window.SequenceEffect||t instanceof window.GroupEffect)for(var e=0;e<t.children.length;e++)o(t.children[e])};e.removeMulti=function(t){for(var e=[],i=0;i<t.length;i++){var n=t[i];n._parent?(e.indexOf(n._parent)==-1&&e.push(n._parent),n._parent.children.splice(n._parent.children.indexOf(n),1),n._parent=null,o(n)):n._animation&&n._animation.effect==n&&(n._animation.cancel(),n._animation.effect=new KeyframeEffect(null,[]),n._animation._callback&&(n._animation._callback._animation=null),n._animation._rebuildUnderlyingAnimation(),o(n))}for(i=0;i<e.length;i++)e[i]._rebuild()},e.KeyframeEffect=function(e,i,r,o){return this.target=e,this._parent=null,r=t.numericTimingToObject(r),this._timingInput=t.cloneTimingInput(r),this._timing=t.normalizeTimingInput(r),this.timing=t.makeTiming(r,!1,this),this.timing._effect=this,"function"==typeof i?(t.deprecated("Custom KeyframeEffect","2015-06-22","Use KeyframeEffect.onsample instead."),this._normalizedKeyframes=i):this._normalizedKeyframes=new n(i),this._keyframes=i,this.activeDuration=t.calculateActiveDuration(this._timing),this._id=o,this},e.KeyframeEffect.prototype={getFrames:function(){return"function"==typeof this._normalizedKeyframes?this._normalizedKeyframes:this._normalizedKeyframes._frames},set onsample(t){if("function"==typeof this.getFrames())throw new Error("Setting onsample on custom effect KeyframeEffect is not supported.");this._onsample=t,this._animation&&this._animation._rebuildUnderlyingAnimation()},get parent(){return this._parent},clone:function(){if("function"==typeof this.getFrames())throw new Error("Cloning custom effects is not supported.");var e=new KeyframeEffect(this.target,[],t.cloneTimingInput(this._timingInput),this._id);return e._normalizedKeyframes=this._normalizedKeyframes,e._keyframes=this._keyframes,e},remove:function(){e.removeMulti([this])}};var a=Element.prototype.animate;Element.prototype.animate=function(t,i){var n="";return i&&i.id&&(n=i.id),e.timeline._play(new e.KeyframeEffect(this,t,i,n))};var s=document.createElementNS("http://www.w3.org/1999/xhtml","div");e.newUnderlyingAnimationForKeyframeEffect=function(t){if(t){var e=t.target||s,i=t._keyframes;"function"==typeof i&&(i=[]);var n=t._timingInput;n.id=t._id}else var e=s,i=[],n=0;return a.apply(e,[i,n])},e.bindAnimationForKeyframeEffect=function(t){t.effect&&"function"==typeof t.effect._normalizedKeyframes&&e.bindAnimationForCustomEffect(t)};var u=[];e.awaitStartTime=function(t){null===t.startTime&&t._isGroup&&(0==u.length&&requestAnimationFrame(r),u.push(t))};var c=window.getComputedStyle;Object.defineProperty(window,"getComputedStyle",{configurable:!0,enumerable:!0,value:function(){e.timeline._updateAnimationsPromises();var t=c.apply(this,arguments);return r()&&(t=c.apply(this,arguments)),e.timeline._updateAnimationsPromises(),t}}),window.KeyframeEffect=e.KeyframeEffect,window.Element.prototype.getAnimations=function(){return document.timeline.getAnimations().filter(function(t){return null!==t.effect&&t.effect.target==this}.bind(this))}}(c,e,f),function(t,e,i){function n(t){t._registered||(t._registered=!0,a.push(t),s||(s=!0,requestAnimationFrame(r)))}function r(t){var e=a;a=[],e.sort(function(t,e){return t._sequenceNumber-e._sequenceNumber}),e=e.filter(function(t){t();var e=t._animation?t._animation.playState:"idle";return"running"!=e&&"pending"!=e&&(t._registered=!1),t._registered}),a.push.apply(a,e),a.length?(s=!0,requestAnimationFrame(r)):s=!1}var o=(document.createElementNS("http://www.w3.org/1999/xhtml","div"),0);e.bindAnimationForCustomEffect=function(e){var i,r=e.effect.target,a="function"==typeof e.effect.getFrames();i=a?e.effect.getFrames():e.effect._onsample;var s=e.effect.timing,u=null;s=t.normalizeTimingInput(s);var c=function(){var n=c._animation?c._animation.currentTime:null;null!==n&&(n=t.calculateIterationProgress(t.calculateActiveDuration(s),n,s),isNaN(n)&&(n=null)),n!==u&&(a?i(n,r,e.effect):i(n,e.effect,e.effect._animation)),u=n};c._animation=e,c._registered=!1,c._sequenceNumber=o++,e._callback=c,n(c)};var a=[],s=!1;e.Animation.prototype._register=function(){this._callback&&n(this._callback)}}(c,e,f),function(t,e,i){function n(t){return t._timing.delay+t.activeDuration+t._timing.endDelay}function r(e,i,n){this._id=n,this._parent=null,this.children=e||[],this._reparent(this.children),i=t.numericTimingToObject(i),this._timingInput=t.cloneTimingInput(i),this._timing=t.normalizeTimingInput(i,!0),this.timing=t.makeTiming(i,!0,this),this.timing._effect=this,"auto"===this._timing.duration&&(this._timing.duration=this.activeDuration)}window.SequenceEffect=function(){r.apply(this,arguments)},window.GroupEffect=function(){r.apply(this,arguments)},r.prototype={_isAncestor:function(t){for(var e=this;null!==e;){if(e==t)return!0;e=e._parent}return!1},_rebuild:function(){for(var t=this;t;)"auto"===t.timing.duration&&(t._timing.duration=t.activeDuration),t=t._parent;this._animation&&this._animation._rebuildUnderlyingAnimation()},_reparent:function(t){e.removeMulti(t);for(var i=0;i<t.length;i++)t[i]._parent=this},_putChild:function(t,e){for(var i=e?"Cannot append an ancestor or self":"Cannot prepend an ancestor or self",n=0;n<t.length;n++)if(this._isAncestor(t[n]))throw{type:DOMException.HIERARCHY_REQUEST_ERR,name:"HierarchyRequestError",message:i};for(var n=0;n<t.length;n++)e?this.children.push(t[n]):this.children.unshift(t[n]);this._reparent(t),this._rebuild()},append:function(){this._putChild(arguments,!0)},prepend:function(){this._putChild(arguments,!1)},get parent(){return this._parent},get firstChild(){return this.children.length?this.children[0]:null},get lastChild(){return this.children.length?this.children[this.children.length-1]:null},clone:function(){for(var e=t.cloneTimingInput(this._timingInput),i=[],n=0;n<this.children.length;n++)i.push(this.children[n].clone());return this instanceof GroupEffect?new GroupEffect(i,e):new SequenceEffect(i,e)},remove:function(){e.removeMulti([this])}},window.SequenceEffect.prototype=Object.create(r.prototype),Object.defineProperty(window.SequenceEffect.prototype,"activeDuration",{get:function(){var t=0;return this.children.forEach(function(e){t+=n(e)}),Math.max(t,0)}}),window.GroupEffect.prototype=Object.create(r.prototype),Object.defineProperty(window.GroupEffect.prototype,"activeDuration",{get:function(){var t=0;return this.children.forEach(function(e){t=Math.max(t,n(e))}),t}}),e.newUnderlyingAnimationForGroup=function(i){var n,r=null,o=function(e){var i=n._wrapper;if(i&&"pending"!=i.playState&&i.effect)return null==e?void i._removeChildAnimations():0==e&&i.playbackRate<0&&(r||(r=t.normalizeTimingInput(i.effect.timing)),e=t.calculateIterationProgress(t.calculateActiveDuration(r),-1,r),isNaN(e)||null==e)?(i._forEachChild(function(t){t.currentTime=-1}),void i._removeChildAnimations()):void 0},a=new KeyframeEffect(null,[],i._timing,i._id);return a.onsample=o,n=e.timeline._play(a)},e.bindAnimationForGroup=function(t){t._animation._wrapper=t,t._isGroup=!0,e.awaitStartTime(t),t._constructChildAnimations(),t._setExternalAnimation(t)},e.groupChildDuration=n}(c,e,f),b.true=a}({},function(){return this}());</script>
<script>

  Polymer({

    is: 'opaque-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;
      this._effect = new KeyframeEffect(node, [
        {'opacity': '1'},
        {'opacity': '1'}
      ], this.timingFromConfig(config));
      node.style.opacity = '0';
      return this._effect;
    },

    complete: function(config) {
      config.node.style.opacity = '';
    }

  });

</script><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>
  (function() {
    'use strict';
    /**
     * Used to calculate the scroll direction during touch events.
     * @type {!Object}
     */
    var lastTouchPosition = {
      pageX: 0,
      pageY: 0
    };
    /**
     * Used to avoid computing event.path and filter scrollable nodes (better perf).
     * @type {?EventTarget}
     */
    var lastRootTarget = null;
    /**
     * @type {!Array<Node>}
     */
    var lastScrollableNodes = [];

    /**
     * The IronDropdownScrollManager is intended to provide a central source
     * of authority and control over which elements in a document are currently
     * allowed to scroll.
     */

    Polymer.IronDropdownScrollManager = {

      /**
       * The current element that defines the DOM boundaries of the
       * scroll lock. This is always the most recently locking element.
       */
      get currentLockingElement() {
        return this._lockingElements[this._lockingElements.length - 1];
      },

      /**
       * Returns true if the provided element is "scroll locked", which is to
       * say that it cannot be scrolled via pointer or keyboard interactions.
       *
       * @param {HTMLElement} element An HTML element instance which may or may
       * not be scroll locked.
       */
      elementIsScrollLocked: function(element) {
        var currentLockingElement = this.currentLockingElement;

        if (currentLockingElement === undefined)
          return false;

        var scrollLocked;

        if (this._hasCachedLockedElement(element)) {
          return true;
        }

        if (this._hasCachedUnlockedElement(element)) {
          return false;
        }

        scrollLocked = !!currentLockingElement &&
          currentLockingElement !== element &&
          !this._composedTreeContains(currentLockingElement, element);

        if (scrollLocked) {
          this._lockedElementCache.push(element);
        } else {
          this._unlockedElementCache.push(element);
        }

        return scrollLocked;
      },

      /**
       * Push an element onto the current scroll lock stack. The most recently
       * pushed element and its children will be considered scrollable. All
       * other elements will not be scrollable.
       *
       * Scroll locking is implemented as a stack so that cases such as
       * dropdowns within dropdowns are handled well.
       *
       * @param {HTMLElement} element The element that should lock scroll.
       */
      pushScrollLock: function(element) {
        // Prevent pushing the same element twice
        if (this._lockingElements.indexOf(element) >= 0) {
          return;
        }

        if (this._lockingElements.length === 0) {
          this._lockScrollInteractions();
        }

        this._lockingElements.push(element);

        this._lockedElementCache = [];
        this._unlockedElementCache = [];
      },

      /**
       * Remove an element from the scroll lock stack. The element being
       * removed does not need to be the most recently pushed element. However,
       * the scroll lock constraints only change when the most recently pushed
       * element is removed.
       *
       * @param {HTMLElement} element The element to remove from the scroll
       * lock stack.
       */
      removeScrollLock: function(element) {
        var index = this._lockingElements.indexOf(element);

        if (index === -1) {
          return;
        }

        this._lockingElements.splice(index, 1);

        this._lockedElementCache = [];
        this._unlockedElementCache = [];

        if (this._lockingElements.length === 0) {
          this._unlockScrollInteractions();
        }
      },

      _lockingElements: [],

      _lockedElementCache: null,

      _unlockedElementCache: null,

      _hasCachedLockedElement: function(element) {
        return this._lockedElementCache.indexOf(element) > -1;
      },

      _hasCachedUnlockedElement: function(element) {
        return this._unlockedElementCache.indexOf(element) > -1;
      },

      _composedTreeContains: function(element, child) {
        // NOTE(cdata): This method iterates over content elements and their
        // corresponding distributed nodes to implement a contains-like method
        // that pierces through the composed tree of the ShadowDOM. Results of
        // this operation are cached (elsewhere) on a per-scroll-lock basis, to
        // guard against potentially expensive lookups happening repeatedly as
        // a user scrolls / touchmoves.
        var contentElements;
        var distributedNodes;
        var contentIndex;
        var nodeIndex;

        if (element.contains(child)) {
          return true;
        }

        contentElements = Polymer.dom(element).querySelectorAll('content');

        for (contentIndex = 0; contentIndex < contentElements.length; ++contentIndex) {

          distributedNodes = Polymer.dom(contentElements[contentIndex]).getDistributedNodes();

          for (nodeIndex = 0; nodeIndex < distributedNodes.length; ++nodeIndex) {

            if (this._composedTreeContains(distributedNodes[nodeIndex], child)) {
              return true;
            }
          }
        }

        return false;
      },

      _scrollInteractionHandler: function(event) {
        // Avoid canceling an event with cancelable=false, e.g. scrolling is in
        // progress and cannot be interrupted.
        if (event.cancelable && this._shouldPreventScrolling(event)) {
          event.preventDefault();
        }
        // If event has targetTouches (touch event), update last touch position.
        if (event.targetTouches) {
          var touch = event.targetTouches[0];
          lastTouchPosition.pageX = touch.pageX;
          lastTouchPosition.pageY = touch.pageY;
        }
      },

      _lockScrollInteractions: function() {
        this._boundScrollHandler = this._boundScrollHandler ||
          this._scrollInteractionHandler.bind(this);
        // Modern `wheel` event for mouse wheel scrolling:
        document.addEventListener('wheel', this._boundScrollHandler, true);
        // Older, non-standard `mousewheel` event for some FF:
        document.addEventListener('mousewheel', this._boundScrollHandler, true);
        // IE:
        document.addEventListener('DOMMouseScroll', this._boundScrollHandler, true);
        // Save the lastScrollableNodes on touchstart, to be used on touchmove.
        document.addEventListener('touchstart', this._boundScrollHandler, true);
        // Mobile devices can scroll on touch move:
        document.addEventListener('touchmove', this._boundScrollHandler, true);
      },

      _unlockScrollInteractions: function() {
        document.removeEventListener('wheel', this._boundScrollHandler, true);
        document.removeEventListener('mousewheel', this._boundScrollHandler, true);
        document.removeEventListener('DOMMouseScroll', this._boundScrollHandler, true);
        document.removeEventListener('touchstart', this._boundScrollHandler, true);
        document.removeEventListener('touchmove', this._boundScrollHandler, true);
      },

      /**
       * Returns true if the event causes scroll outside the current locking
       * element, e.g. pointer/keyboard interactions, or scroll "leaking"
       * outside the locking element when it is already at its scroll boundaries.
       * @param {!Event} event
       * @return {boolean}
       * @private
       */
      _shouldPreventScrolling: function(event) {

        // Update if root target changed. For touch events, ensure we don't
        // update during touchmove.
        var target = Polymer.dom(event).rootTarget;
        if (event.type !== 'touchmove' && lastRootTarget !== target) {
          lastRootTarget = target;
          lastScrollableNodes = this._getScrollableNodes(Polymer.dom(event).path);
        }

        // Prevent event if no scrollable nodes.
        if (!lastScrollableNodes.length) {
          return true;
        }
        // Don't prevent touchstart event inside the locking element when it has
        // scrollable nodes.
        if (event.type === 'touchstart') {
          return false;
        }
        // Get deltaX/Y.
        var info = this._getScrollInfo(event);
        // Prevent if there is no child that can scroll.
        return !this._getScrollingNode(lastScrollableNodes, info.deltaX, info.deltaY);
      },

      /**
       * Returns an array of scrollable nodes up to the current locking element,
       * which is included too if scrollable.
       * @param {!Array<Node>} nodes
       * @return {Array<Node>} scrollables
       * @private
       */
      _getScrollableNodes: function(nodes) {
        var scrollables = [];
        var lockingIndex = nodes.indexOf(this.currentLockingElement);
        // Loop from root target to locking element (included).
        for (var i = 0; i <= lockingIndex; i++) {
          // Skip non-Element nodes.
          if (nodes[i].nodeType !== Node.ELEMENT_NODE) {
            continue;
          }
          var node = /** @type {!Element} */ (nodes[i]);
          // Check inline style before checking computed style.
          var style = node.style;
          if (style.overflow !== 'scroll' && style.overflow !== 'auto') {
            style = window.getComputedStyle(node);
          }
          if (style.overflow === 'scroll' || style.overflow === 'auto') {
            scrollables.push(node);
          }
        }
        return scrollables;
      },

      /**
       * Returns the node that is scrolling. If there is no scrolling,
       * returns undefined.
       * @param {!Array<Node>} nodes
       * @param {number} deltaX Scroll delta on the x-axis
       * @param {number} deltaY Scroll delta on the y-axis
       * @return {Node|undefined}
       * @private
       */
      _getScrollingNode: function(nodes, deltaX, deltaY) {
        // No scroll.
        if (!deltaX && !deltaY) {
          return;
        }
        // Check only one axis according to where there is more scroll.
        // Prefer vertical to horizontal.
        var verticalScroll = Math.abs(deltaY) >= Math.abs(deltaX);
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          var canScroll = false;
          if (verticalScroll) {
            // delta < 0 is scroll up, delta > 0 is scroll down.
            canScroll = deltaY < 0 ? node.scrollTop > 0 :
              node.scrollTop < node.scrollHeight - node.clientHeight;
          } else {
            // delta < 0 is scroll left, delta > 0 is scroll right.
            canScroll = deltaX < 0 ? node.scrollLeft > 0 :
              node.scrollLeft < node.scrollWidth - node.clientWidth;
          }
          if (canScroll) {
            return node;
          }
        }
      },

      /**
       * Returns scroll `deltaX` and `deltaY`.
       * @param {!Event} event The scroll event
       * @return {{deltaX: number, deltaY: number}} Object containing the
       * x-axis scroll delta (positive: scroll right, negative: scroll left,
       * 0: no scroll), and the y-axis scroll delta (positive: scroll down,
       * negative: scroll up, 0: no scroll).
       * @private
       */
      _getScrollInfo: function(event) {
        var info = {
          deltaX: event.deltaX,
          deltaY: event.deltaY
        };
        // Already available.
        if ('deltaX' in event) {
          // do nothing, values are already good.
        }
        // Safari has scroll info in `wheelDeltaX/Y`.
        else if ('wheelDeltaX' in event) {
          info.deltaX = -event.wheelDeltaX;
          info.deltaY = -event.wheelDeltaY;
        }
        // Firefox has scroll info in `detail` and `axis`.
        else if ('axis' in event) {
          info.deltaX = event.axis === 1 ? event.detail : 0;
          info.deltaY = event.axis === 2 ? event.detail : 0;
        }
        // On mobile devices, calculate scroll direction.
        else if (event.targetTouches) {
          var touch = event.targetTouches[0];
          // Touch moves from right to left => scrolling goes right.
          info.deltaX = lastTouchPosition.pageX - touch.pageX;
          // Touch moves from down to up => scrolling goes down.
          info.deltaY = lastTouchPosition.pageY - touch.pageY;
        }
        return info;
      }
    };
  })();
</script><dom-module id="iron-dropdown" assetpath="../../../bower_components/iron-dropdown/">
  <template>
    <style>
      :host {
        position: fixed;
      }

      #contentWrapper ::content > * {
        overflow: auto;
      }

      #contentWrapper.animating ::content > * {
        overflow: hidden;
      }
    </style>

    <div id="contentWrapper">
      <content id="content" select=".dropdown-content"></content>
    </div>
  </template>

  <script>
    (function() {
      'use strict';

      Polymer({
        is: 'iron-dropdown',

        behaviors: [
          Polymer.IronControlState,
          Polymer.IronA11yKeysBehavior,
          Polymer.IronOverlayBehavior,
          Polymer.NeonAnimationRunnerBehavior
        ],

        properties: {
          /**
           * The orientation against which to align the dropdown content
           * horizontally relative to the dropdown trigger.
           * Overridden from `Polymer.IronFitBehavior`.
           */
          horizontalAlign: {
            type: String,
            value: 'left',
            reflectToAttribute: true
          },

          /**
           * The orientation against which to align the dropdown content
           * vertically relative to the dropdown trigger.
           * Overridden from `Polymer.IronFitBehavior`.
           */
          verticalAlign: {
            type: String,
            value: 'top',
            reflectToAttribute: true
          },

          /**
           * An animation config. If provided, this will be used to animate the
           * opening of the dropdown. Pass an Array for multiple animations.
           * See `neon-animation` documentation for more animation configuration
           * details.
           */
          openAnimationConfig: {
            type: Object
          },

          /**
           * An animation config. If provided, this will be used to animate the
           * closing of the dropdown. Pass an Array for multiple animations.
           * See `neon-animation` documentation for more animation configuration
           * details.
           */
          closeAnimationConfig: {
            type: Object
          },

          /**
           * If provided, this will be the element that will be focused when
           * the dropdown opens.
           */
          focusTarget: {
            type: Object
          },

          /**
           * Set to true to disable animations when opening and closing the
           * dropdown.
           */
          noAnimations: {
            type: Boolean,
            value: false
          },

          /**
           * By default, the dropdown will constrain scrolling on the page
           * to itself when opened.
           * Set to true in order to prevent scroll from being constrained
           * to the dropdown when it opens.
           */
          allowOutsideScroll: {
            type: Boolean,
            value: false
          },

          /**
           * Callback for scroll events.
           * @type {Function}
           * @private
           */
          _boundOnCaptureScroll: {
            type: Function,
            value: function() {
              return this._onCaptureScroll.bind(this);
            }
          }
        },

        listeners: {
          'neon-animation-finish': '_onNeonAnimationFinish'
        },

        observers: [
          '_updateOverlayPosition(positionTarget, verticalAlign, horizontalAlign, verticalOffset, horizontalOffset)'
        ],

        /**
         * The element that is contained by the dropdown, if any.
         */
        get containedElement() {
          return Polymer.dom(this.$.content).getDistributedNodes()[0];
        },

        /**
         * The element that should be focused when the dropdown opens.
         * @deprecated
         */
        get _focusTarget() {
          return this.focusTarget || this.containedElement;
        },

        ready: function() {
          // Memoized scrolling position, used to block scrolling outside.
          this._scrollTop = 0;
          this._scrollLeft = 0;
          // Used to perform a non-blocking refit on scroll.
          this._refitOnScrollRAF = null;
        },

        attached: function () {
          if (!this.sizingTarget || this.sizingTarget === this) {
            this.sizingTarget = this.containedElement || this;
          }
        },

        detached: function() {
          this.cancelAnimation();
          document.removeEventListener('scroll', this._boundOnCaptureScroll);
          Polymer.IronDropdownScrollManager.removeScrollLock(this);
        },

        /**
         * Called when the value of `opened` changes.
         * Overridden from `IronOverlayBehavior`
         */
        _openedChanged: function() {
          if (this.opened && this.disabled) {
            this.cancel();
          } else {
            this.cancelAnimation();
            this._updateAnimationConfig();
            this._saveScrollPosition();
            if (this.opened) {
              document.addEventListener('scroll', this._boundOnCaptureScroll);
              !this.allowOutsideScroll && Polymer.IronDropdownScrollManager.pushScrollLock(this);
            } else {
              document.removeEventListener('scroll', this._boundOnCaptureScroll);
              Polymer.IronDropdownScrollManager.removeScrollLock(this);
            }
            Polymer.IronOverlayBehaviorImpl._openedChanged.apply(this, arguments);
          }
        },

        /**
         * Overridden from `IronOverlayBehavior`.
         */
        _renderOpened: function() {
          if (!this.noAnimations && this.animationConfig.open) {
            this.$.contentWrapper.classList.add('animating');
            this.playAnimation('open');
          } else {
            Polymer.IronOverlayBehaviorImpl._renderOpened.apply(this, arguments);
          }
        },

        /**
         * Overridden from `IronOverlayBehavior`.
         */
        _renderClosed: function() {

          if (!this.noAnimations && this.animationConfig.close) {
            this.$.contentWrapper.classList.add('animating');
            this.playAnimation('close');
          } else {
            Polymer.IronOverlayBehaviorImpl._renderClosed.apply(this, arguments);
          }
        },

        /**
         * Called when animation finishes on the dropdown (when opening or
         * closing). Responsible for "completing" the process of opening or
         * closing the dropdown by positioning it or setting its display to
         * none.
         */
        _onNeonAnimationFinish: function() {
          this.$.contentWrapper.classList.remove('animating');
          if (this.opened) {
            this._finishRenderOpened();
          } else {
            this._finishRenderClosed();
          }
        },

        _onCaptureScroll: function() {
          if (!this.allowOutsideScroll) {
            this._restoreScrollPosition();
          } else {
            this._refitOnScrollRAF && window.cancelAnimationFrame(this._refitOnScrollRAF);
            this._refitOnScrollRAF = window.requestAnimationFrame(this.refit.bind(this));
          }
        },

        /**
         * Memoizes the scroll position of the outside scrolling element.
         * @private
         */
        _saveScrollPosition: function() {
          if (document.scrollingElement) {
            this._scrollTop = document.scrollingElement.scrollTop;
            this._scrollLeft = document.scrollingElement.scrollLeft;
          } else {
            // Since we don't know if is the body or html, get max.
            this._scrollTop = Math.max(document.documentElement.scrollTop, document.body.scrollTop);
            this._scrollLeft = Math.max(document.documentElement.scrollLeft, document.body.scrollLeft);
          }
        },

        /**
         * Resets the scroll position of the outside scrolling element.
         * @private
         */
        _restoreScrollPosition: function() {
          if (document.scrollingElement) {
            document.scrollingElement.scrollTop = this._scrollTop;
            document.scrollingElement.scrollLeft = this._scrollLeft;
          } else {
            // Since we don't know if is the body or html, set both.
            document.documentElement.scrollTop = this._scrollTop;
            document.documentElement.scrollLeft = this._scrollLeft;
            document.body.scrollTop = this._scrollTop;
            document.body.scrollLeft = this._scrollLeft;
          }
        },

        /**
         * Constructs the final animation config from different properties used
         * to configure specific parts of the opening and closing animations.
         */
        _updateAnimationConfig: function() {
          // Update the animation node to be the containedElement.
          var animationNode = this.containedElement;
          var animations = [].concat(this.openAnimationConfig || []).concat(this.closeAnimationConfig || []);
          for (var i = 0; i < animations.length; i++) {
            animations[i].node = animationNode;
          }
          this.animationConfig = {
            open: this.openAnimationConfig,
            close: this.closeAnimationConfig
          };
        },

        /**
         * Updates the overlay position based on configured horizontal
         * and vertical alignment.
         */
        _updateOverlayPosition: function() {
          if (this.isAttached) {
            // This triggers iron-resize, and iron-overlay-behavior will call refit if needed.
            this.notifyResize();
          }
        },

        /**
         * Apply focus to focusTarget or containedElement
         */
        _applyFocus: function () {
          var focusTarget = this.focusTarget || this.containedElement;
          if (focusTarget && this.opened && !this.noAutoFocus) {
            focusTarget.focus();
          } else {
            Polymer.IronOverlayBehaviorImpl._applyFocus.apply(this, arguments);
          }
        }
      });
    })();
  </script>
</dom-module>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
Material design: [Buttons](https://www.google.com/design/spec/components/buttons.html)

`paper-button` is a button. When the user touches the button, a ripple effect emanates
from the point of contact. It may be flat or raised. A raised button is styled with a
shadow.

Example:

    <paper-button>Flat button</paper-button>
    <paper-button raised>Raised button</paper-button>
    <paper-button noink>No ripple effect</paper-button>
    <paper-button toggles>Toggle-able button</paper-button>

A button that has `toggles` true will remain `active` after being clicked (and
will have an `active` attribute set). For more information, see the `Polymer.IronButtonState`
behavior.

You may use custom DOM in the button body to create a variety of buttons. For example, to
create a button with an icon and some text:

    <paper-button>
      <iron-icon icon="favorite"></iron-icon>
      custom button content
    </paper-button>

To use `paper-button` as a link, wrap it in an anchor tag. Since `paper-button` will already
receive focus, you may want to prevent the anchor tag from receiving focus as well by setting
its tabindex to -1.

    <a href="https://www.polymer-project.org/" tabindex="-1">
      <paper-button raised>Polymer Project</paper-button>
    </a>

### Styling

Style the button with CSS as you would a normal DOM element.

    paper-button.fancy {
      background: green;
      color: yellow;
    }

    paper-button.fancy:hover {
      background: lime;
    }

    paper-button[disabled],
    paper-button[toggles][active] {
      background: red;
    }

By default, the ripple is the same color as the foreground at 25% opacity. You may
customize the color using the `--paper-button-ink-color` custom property.

The following custom properties and mixins are also available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-button-ink-color` | Background color of the ripple | `Based on the button's color`
`--paper-button` | Mixin applied to the button | `{}`
`--paper-button-disabled` | Mixin applied to the disabled button. Note that you can also use the `paper-button[disabled]` selector | `{}`
`--paper-button-flat-keyboard-focus` | Mixin applied to a flat button after it's been focused using the keyboard | `{}`
`--paper-button-raised-keyboard-focus` | Mixin applied to a raised button after it's been focused using the keyboard | `{}`

@demo demo/index.html
-->

<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>
  /** @polymerBehavior Polymer.PaperButtonBehavior */
  Polymer.PaperButtonBehaviorImpl = {
    properties: {
      /**
       * The z-depth of this element, from 0-5. Setting to 0 will remove the
       * shadow, and each increasing number greater than 0 will be "deeper"
       * than the last.
       *
       * @attribute elevation
       * @type number
       * @default 1
       */
      elevation: {
        type: Number,
        reflectToAttribute: true,
        readOnly: true
      }
    },

    observers: [
      '_calculateElevation(focused, disabled, active, pressed, receivedFocusFromKeyboard)',
      '_computeKeyboardClass(receivedFocusFromKeyboard)'
    ],

    hostAttributes: {
      role: 'button',
      tabindex: '0',
      animated: true
    },

    _calculateElevation: function() {
      var e = 1;
      if (this.disabled) {
        e = 0;
      } else if (this.active || this.pressed) {
        e = 4;
      } else if (this.receivedFocusFromKeyboard) {
        e = 3;
      }
      this._setElevation(e);
    },

    _computeKeyboardClass: function(receivedFocusFromKeyboard) {
      this.toggleClass('keyboard-focus', receivedFocusFromKeyboard);
    },

    /**
     * In addition to `IronButtonState` behavior, when space key goes down,
     * create a ripple down effect.
     *
     * @param {!KeyboardEvent} event .
     */
    _spaceKeyDownHandler: function(event) {
      Polymer.IronButtonStateImpl._spaceKeyDownHandler.call(this, event);
      // Ensure that there is at most one ripple when the space key is held down.
      if (this.hasRipple() && this.getRipple().ripples.length < 1) {
        this._ripple.uiDownAction();
      }
    },

    /**
     * In addition to `IronButtonState` behavior, when space key goes up,
     * create a ripple up effect.
     *
     * @param {!KeyboardEvent} event .
     */
    _spaceKeyUpHandler: function(event) {
      Polymer.IronButtonStateImpl._spaceKeyUpHandler.call(this, event);
      if (this.hasRipple()) {
        this._ripple.uiUpAction();
      }
    }
  };

  /** @polymerBehavior */
  Polymer.PaperButtonBehavior = [
    Polymer.IronButtonState,
    Polymer.IronControlState,
    Polymer.PaperRippleBehavior,
    Polymer.PaperButtonBehaviorImpl
  ];
</script><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><dom-module id="paper-material-shared-styles" assetpath="../../../bower_components/paper-material/">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      :host([elevation="1"]) {
        @apply(--shadow-elevation-2dp);
      }

      :host([elevation="2"]) {
        @apply(--shadow-elevation-4dp);
      }

      :host([elevation="3"]) {
        @apply(--shadow-elevation-6dp);
      }

      :host([elevation="4"]) {
        @apply(--shadow-elevation-8dp);
      }

      :host([elevation="5"]) {
        @apply(--shadow-elevation-16dp);
      }
    </style>
  </template>
</dom-module>
<dom-module id="paper-button" assetpath="../../../bower_components/paper-button/">
  <template strip-whitespace="">
    <style include="paper-material-shared-styles">
      :host {
        @apply(--layout-inline);
        @apply(--layout-center-center);
        position: relative;
        box-sizing: border-box;
        min-width: 5.14em;
        margin: 0 0.29em;
        background: transparent;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        -webkit-tap-highlight-color: transparent;
        font: inherit;
        text-transform: uppercase;
        outline-width: 0;
        border-radius: 3px;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-select: none;
        user-select: none;
        cursor: pointer;
        z-index: 0;
        padding: 0.7em 0.57em;

        @apply(--paper-font-common-base);
        @apply(--paper-button);
      }

      :host([hidden]) {
        display: none !important;
      }

      :host([raised].keyboard-focus) {
        font-weight: bold;
        @apply(--paper-button-raised-keyboard-focus);
      }

      :host(:not([raised]).keyboard-focus) {
        font-weight: bold;
        @apply(--paper-button-flat-keyboard-focus);
      }

      :host([disabled]) {
        background: #eaeaea;
        color: #a8a8a8;
        cursor: auto;
        pointer-events: none;

        @apply(--paper-button-disabled);
      }

      :host([animated]) {
        @apply(--shadow-transition);
      }

      paper-ripple {
        color: var(--paper-button-ink-color);
      }
    </style>

    <content></content>
  </template>

  <script>
    Polymer({
      is: 'paper-button',

      behaviors: [
        Polymer.PaperButtonBehavior
      ],

      properties: {
        /**
         * If true, the button should be styled with a shadow.
         */
        raised: {
          type: Boolean,
          reflectToAttribute: true,
          value: false,
          observer: '_calculateElevation'
        }
      },

      _calculateElevation: function() {
        if (!this.raised) {
          this._setElevation(0);
        } else {
          Polymer.PaperButtonBehaviorImpl._calculateElevation.apply(this);
        }
      }

      /**
      Fired when the animation finishes.
      This is useful if you want to wait until
      the ripple animation finishes to perform some action.

      @event transitionend
      Event param: {{node: Object}} detail Contains the animated node.
      */
    });
  </script>
</dom-module>
<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.datepicker = vaadin.elements.datepicker || {};

  vaadin.elements.datepicker.DatePickerHelper = {
    /**
     * Get ISO 8601 week number for the given date.
     *
     * @param {Date} Date object
     * @return {Number} Week number
     */
    _getISOWeekNumber: function(date) {
      // Ported from Vaadin Framework method com.vaadin.client.DateTimeService.getISOWeekNumber(date)
      var dayOfWeek = date.getDay(); // 0 == sunday

      // ISO 8601 use weeks that start on monday so we use
      // mon=1,tue=2,...sun=7;
      if (dayOfWeek === 0) {
        dayOfWeek = 7;
      }
      // Find nearest thursday (defines the week in ISO 8601). The week number
      // for the nearest thursday is the same as for the target date.
      var nearestThursdayDiff = 4 - dayOfWeek; // 4 is thursday
      var nearestThursday = new Date(date.getTime() + nearestThursdayDiff * 24 * 3600 * 1000);

      var firstOfJanuary = new Date(0, 0);
      firstOfJanuary.setFullYear(nearestThursday.getFullYear());

      var timeDiff = nearestThursday.getTime() - firstOfJanuary.getTime();

      // Rounding the result, as the division doesn't result in an integer
      // when the given date is inside daylight saving time period.
      var daysSinceFirstOfJanuary = Math.round(timeDiff / (24 * 3600 * 1000));

      return Math.floor((daysSinceFirstOfJanuary) / 7 + 1);
    },

    /**
     * Check if two dates are equal.
     *
     * @param {Date} date1
     * @param {Date} date2
     * @return {Boolean} True if the given date objects refer to the same date
     */
    _dateEquals: function(date1, date2) {
      if (date1 && date2) {
        return date1.getFullYear() === date2.getFullYear() &&
          date1.getMonth() === date2.getMonth() &&
          date1.getDate() === date2.getDate();
      } else {
        return false;
      }
    },

    /**
     * Check if the given date is in the range of allowed dates.
     *
     * @param {Date} date The date to check
     * @param {Date} min Range start
     * @param {Date} max Range end
     * @return {Boolean} True if the date is in the range
     */
    _dateAllowed: function(date, min, max) {
      return (!min || date >= min) && (!max || date <= max);
    },

    /**
     * Get closest date from array of dates.
     *
     * @param {Date} date The date to compare dates with
     * @param {Array} dates Array of date objects
     * @return {Date} Closest date
     */
    _getClosestDate: function(date, dates) {
      return dates.filter(function(date) {
        return date !== undefined;
      })
       .reduce(function(closestDate, candidate) {
         if (!candidate) {
           return closestDate;
         }

         if (!closestDate) {
           return candidate;
         }

         var candidateDiff = Math.abs(date.getTime() - candidate.getTime());
         var closestDateDiff = Math.abs(closestDate.getTime() - date.getTime());
         return candidateDiff < closestDateDiff ? candidate : closestDate;
       });
    }
  };
</script>
<dom-module id="vaadin-month-calendar" assetpath="/">
  <template>
    <style>
      :host {
        display: block;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        font: inherit;
        @apply(--paper-font-common-base);
        @apply(--vaadin-date-picker-calendar);
      }

      #title {
        color: var(--primary-text-color);
        text-align: center;
        padding: 6px 0;
        @apply(--paper-font-subhead);
        @apply(--vaadin-date-picker-calendar-title);
      }

      #monthGrid {
        display: flex;
        flex-wrap: wrap;
      }

      #monthGrid div {
        text-align: center;
        width: calc(14.285714286% - 2px);
        margin: 0 1px;
        box-sizing: border-box;
        padding: 6px 0;
        @apply(--paper-font-body1);
        @apply(--vaadin-date-picker-calendar-cell);
      }

      :host([week-numbers]) #monthGrid div {
        width: calc(12.5% - 2px);
      }

      #monthGrid div:not(:empty) {
        cursor: pointer;
        color: var(--primary-text-color);
        @apply(--vaadin-date-picker-calendar-date-cell);
      }

      #monthGrid div:not(:empty):not([disabled]):not(.weekday):not(.weeknumber):active {
        background: var(--light-primary-color);
        border-radius: 2px;
      }

      #monthGrid div.weekday {
        text-transform: uppercase;
        color: var(--secondary-text-color);
        cursor: default;
        padding: 8px 0;
        @apply(--paper-font-caption);
        @apply(--vaadin-date-picker-calendar-weekday-cell);
      }

      #monthGrid div.weekday:empty,
      #monthGrid div.weeknumber {
        width: calc(10% - 2px);
        padding-right: 1.25%;
      }

      #monthGrid div[today] {
        position: relative;
        color: var(--primary-color);
        @apply(--vaadin-date-picker-calendar-cell-today);
      }

      #monthGrid div[today][selected] {
        @apply(--vaadin-date-picker-calendar-cell-today-selected);
      }

      #monthGrid div[focused] {
        background: var(--light-primary-color);
        box-sizing: border-box;
        border-radius: 2px;
        @apply(--vaadin-date-picker-calendar-cell-focused);
      }

      :host([focused]) #monthGrid div[focused] {
        background: var(--primary-color);
        color: var(--primary-background-color);
        @apply(--vaadin-date-picker-calendar-focused-cell-focused);
      }

      #monthGrid div[selected] {
        font-weight: 600;
        @apply(--vaadin-date-picker-calendar-cell-selected);
      }

      #monthGrid div[today][selected] {
        @apply(--vaadin-date-picker-calendar-cell-today-selected);
      }

      #monthGrid div[disabled] {
        opacity: 0.3;
        cursor: default;
        @apply(--vaadin-date-picker-calendar-cell-disabled);
      }

      #monthGrid div.weeknumber {
        cursor: default;
        color: rgba(0, 0, 0, 0.4);
        @apply(--paper-font-caption);
        @apply(--vaadin-date-picker-calendar-weeknumber-cell);
      }
    </style>

    <div id="title" role="heading">[[_getTitle(month, i18n.monthNames)]]</div>
    <div id="monthGrid" on-tap="_handleTap" on-touchend="_preventDefault" on-touchstart="_onMonthGridTouchStart">
      <template is="dom-repeat" items="[[_getWeekDayNames(i18n.weekdays, i18n.weekdaysShort, showWeekNumbers, i18n.firstDayOfWeek)]]">
        <div class="weekday" role="heading" aria-label$="[[item.weekDay]]">[[item.weekDayShort]]</div>
      </template>
      <template is="dom-repeat" items="[[_days]]">
        <template is="dom-if" if="[[_showWeekSeparator(showWeekNumbers, i18n.firstDayOfWeek, index)]]">
          <div class="weeknumber" role="heading" aria-label$="[[i18n.week]] [[_getWeekNumber(item, _days)]]">[[_getWeekNumber(item, _days)]]</div>
        </template>
        <div today$="[[_isToday(item)]]" selected$="[[_dateEquals(item, selectedDate)]]" focused$="[[_dateEquals(item, focusedDate)]]" date="[[item]]" disabled$="[[!_dateAllowed(item, minDate, maxDate)]]" role$="[[_getRole(item)]]" aria-label$="[[_getAriaLabel(item)]]" aria-disabled$="[[_getAriaDisabled(item, minDate, maxDate)]]">[[_getDate(item)]]</div>
      </template>
    </div>
  </template>
  <script>
    Polymer({
      is: 'vaadin-month-calendar',

      properties: {
        /**
         * A `Date` object defining the month to be displayed. Only year and
         * month properties are actually used.
         */
        month: {
          type: Date,
          value: new Date()
        },

        /**
         * A `Date` object for the currently selected date.
         */
        selectedDate: {
          type: Date,
          notify: true
        },

        /**
         * A `Date` object for the currently focused date.
         */
        focusedDate: Date,

        showWeekNumbers: {
          type: Boolean,
          value: false
        },

        i18n: {
          type: Object
        },

        /**
         * Flag stating whether taps on the component should be ignored.
         */
        ignoreTaps: Boolean,

        _notTapping: Boolean,

        /**
         * The earliest date that can be selected. All earlier dates will be disabled.
         */
        minDate: {
          type: Date,
          value: null
        },

        /**
         * The latest date that can be selected. All later dates will be disabled.
         */
        maxDate: {
          type: Date,
          value: null
        },

        _days: {
          type: Array,
          computed: '_getDays(month, i18n.firstDayOfWeek, minDate, maxDate)'
        }
      },

      observers: [
        '_showWeekNumbersChanged(showWeekNumbers, i18n.firstDayOfWeek)'
      ],

      _getTitle: function(month, monthNames) {
        return this.i18n.formatTitle(monthNames[month.getMonth()], month.getFullYear());
      },

      _dateEquals: vaadin.elements.datepicker.DatePickerHelper._dateEquals,

      _onMonthGridTouchStart: function() {
        this._notTapping = false;
        this.async(function() {
          this._notTapping = true;
        }, 300);
      },

      _dateAdd: function(date, delta) {
        date.setDate(date.getDate() + delta);
      },

      _applyFirstDayOfWeek: function(weekDayNames, firstDayOfWeek) {
        return weekDayNames.slice(firstDayOfWeek).concat(weekDayNames.slice(0, firstDayOfWeek));
      },

      _getWeekDayNames: function(weekDayNames, weekDayNamesShort, showWeekNumbers, firstDayOfWeek) {
        weekDayNames = this._applyFirstDayOfWeek(weekDayNames, firstDayOfWeek);
        weekDayNamesShort = this._applyFirstDayOfWeek(weekDayNamesShort, firstDayOfWeek);
        weekDayNames = weekDayNames.map(function(day, index) {
          return {
            weekDay: day,
            weekDayShort: weekDayNamesShort[index]
          };
        });

        // Add extra space in the beginning of weekday names
        if (showWeekNumbers && firstDayOfWeek === 1) {
          weekDayNames.unshift({
            weekDay: '',
            weekDayShort: ''
          });
        }

        return weekDayNames;
      },

      _getDate: function(date) {
        return date ? date.getDate() : '';
      },

      _showWeekNumbersChanged: function(showWeekNumbers, firstDayOfWeek) {
        this.toggleAttribute('week-numbers', showWeekNumbers && firstDayOfWeek === 1);
      },

      _showWeekSeparator: function(showWeekNumbers, firstDayOfWeek, index) {
        // Currently only supported for locales that start the week on Monday.
        return showWeekNumbers && firstDayOfWeek === 1 && (index % 7 === 0);
      },

      _isToday: function(date) {
        return this._dateEquals(new Date(), date);
      },

      _getDays: function(month, firstDayOfWeek) {
        // First day of the month (at midnight).
        var date = new Date(0, 0);
        date.setFullYear(month.getFullYear());
        date.setMonth(month.getMonth());
        date.setDate(1);

        // Rewind to first day of the week.
        while (date.getDay() !== firstDayOfWeek) {
          this._dateAdd(date, -1);
        }

        var days = [];
        var startMonth = date.getMonth();
        var targetMonth = month.getMonth();
        while (date.getMonth() === targetMonth || date.getMonth() === startMonth) {
          days.push(date.getMonth() === targetMonth ? new Date(date.getTime()) : null);

          // Advance to next day.
          this._dateAdd(date, 1);
        }
        return days;
      },

      _getWeekNumber: function(date, days) {
        if (!date) {
          // Get the first non-null date from the days array.
          date = days.reduce(function(acc, d) {
            return (!acc && d ? d : acc);
          });
        }

        return vaadin.elements.datepicker.DatePickerHelper._getISOWeekNumber(date);
      },

      _handleTap: function(e) {
        if (!this.ignoreTaps && !this._notTapping && e.target.date && !e.target.hasAttribute('disabled')) {
          this.selectedDate = e.target.date;
          this.fire('date-tap');
        }
      },

      _preventDefault: function(e) {
        e.preventDefault();
      },

      _dateAllowed: vaadin.elements.datepicker.DatePickerHelper._dateAllowed,

      _getRole: function(date) {
        return date ? 'button' : 'presentational';
      },

      _getAriaLabel: function(date) {
        if (!date) {
          return '';
        }

        var ariaLabel = this._getDate(date) + ' ' +
          this.i18n.monthNames[date.getMonth()] + ' ' +
          date.getFullYear() + ', ' +
          this.i18n.weekdays[date.getDay()];

        if (this._isToday(date)) {
          ariaLabel += ', ' + this.i18n.today;
        }

        return ariaLabel;
      },

      _getAriaDisabled: function(date, min, max) {
        return this._dateAllowed(date, min, max) ? 'false' : 'true';
      }
    });
  </script>
</dom-module>
<!--
@license
Copyright (c) 2016 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
--><dom-module id="vaadin-infinite-scroller" assetpath="/">
  <template>
    <style>
      :host {
        display: block;
        overflow: hidden;
        height: 500px;
      }

      #scroller {
        position: relative;
        height: 100%;
        overflow: auto;
        outline: none;
        margin-right: -40px;
        -webkit-overflow-scrolling: touch;
        -ms-overflow-style: none;
        overflow-x: hidden;
      }

      #scroller.notouchscroll {
        -webkit-overflow-scrolling: auto;
      }

      #scroller::-webkit-scrollbar {
        display: none;
      }

      .buffer {
        position: absolute;
        width: 100%;
        box-sizing: border-box;
        padding-right: 40px;
        @apply(--vaadin-infinite-scroller-buffer);
      }

      :host(:not([init-animation-done])) .buffer > * {
        animation: fadein 0.2s;
      }

      @keyframes fadein {
        from { opacity: 0; }
        to { opacity: 1; }
      }
    </style>

    <div id="scroller">
      <div class="buffer"></div>
      <div class="buffer"></div>
      <div id="fullHeight"></div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'vaadin-infinite-scroller',

    behaviors: [
      Polymer.Templatizer
    ],

    properties: {

      /**
       * Height of individual items (in pixels).
       * Changing after initialization not supported.
       */
      itemHeight: {
        type: Number,
        value: 50
      },

      /**
       * Count of individual items in each buffer.
       * The scroller has 2 buffers altogether so bufferSize of 20
       * will result in 40 buffered DOM items in total.
       * Changing after initialization not supported.
       */
      bufferSize: {
        type: Number,
        value: 20
      },

      /**
       * The amount of initial scroll top. Needed in order for the
       * user to be able to scroll backwards.
       */
      _initialScroll: {
        value: 500000
      },

      /**
       * The index/position mapped at _initialScroll point.
       */
      _initialIndex: {
        value: 0
      },

      _buffers: Array,

      _preventScrollEvent: Boolean,

      _bufferHeight: Number,

      _mayHaveMomentum: Boolean,

      _initialized: Boolean,

      active: Boolean
    },

    observers: [
      '_activated(active)'
    ],

    _activated: function(active) {
      if (active && !this._initialized) {
        this._createPool();
        this._initialized = true;
      }
    },

    listeners: {
      'animationend': '_animationEnd'
    },

    _animationEnd: function() {
      this.toggleAttribute('init-animation-done', true);
    },

    _finishInit: function() {
      if (!this._initDone) {
        // Once the first set of items start fading in, stamp the rest
        this._buffers.forEach(function(buffer) {
          [].forEach.call(buffer.children, function(itemWrapper) {
            this._ensureStampedInstance(itemWrapper);
          }.bind(this));
        }, this);

        if (!this._buffers[0].translateY) {
          this._reset();
        }

        this._initDone = true;
      }
    },

    ready: function() {
      this._bufferHeight = this.itemHeight * this.bufferSize;
      this._buffers = Polymer.dom(this.root).querySelectorAll('.buffer');

      this.$.fullHeight.style.height = this._initialScroll * 2 + 'px';

      var template = Polymer.dom(this).querySelector('template');
      this.templatize(template);

      // Firefox interprets elements with overflow:auto as focusable
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1069739
      var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
      if (isFirefox) {
        this.$.scroller.tabIndex = -1;
      }
    },

    _translateBuffer: function(up) {
      var index = up ? 1 : 0;
      this._buffers[index].translateY = this._buffers[(index ? 0 : 1)].translateY + this._bufferHeight * (index ? -1 : 1);
      this.transform('translate3d(0, ' + this._buffers[index].translateY + 'px, 0)', this._buffers[index]);
      this._buffers[index].updated = false;
      this._buffers.reverse();
    },

    _scroll: function() {
      var scrollTop = this.$.scroller.scrollTop;
      if (scrollTop < this._bufferHeight || scrollTop > this._initialScroll * 2 - this._bufferHeight) {
        // Scrolled near the end/beginning of the scrollable area -> reset.
        this._initialIndex = ~~this.position;
        this._reset();
      }

      // Check if we scrolled enough to translate the buffer positions.
      var bufferOffset = this.$$('.buffer').offsetTop;
      var upperThresholdReached = scrollTop > this._buffers[1].translateY + this.itemHeight + bufferOffset;
      var lowerThresholdReached = scrollTop < this._buffers[0].translateY + this.itemHeight + bufferOffset;

      if (upperThresholdReached || lowerThresholdReached) {
        this._translateBuffer(lowerThresholdReached);
        this._updateClones();
      }

      if (!this._preventScrollEvent) {
        this.fire('scroll');
        this._mayHaveMomentum = true;
      }
      this._preventScrollEvent = false;

      this.debounce('scrollFinish', function() {
        var scrollerRect = this.$.scroller.getBoundingClientRect();
        if (!this._isVisible(this._buffers[0], scrollerRect) && !this._isVisible(this._buffers[1], scrollerRect)) {
          this.position = this.position;
        }
      }, 200);
    },

    /**
     * Current scroller position as index. Can be a fractional number.
     *
     * @type {Number}
     */
    set position(index) {
      this._preventScrollEvent = true;
      if (index > this._firstIndex && index < this._firstIndex + this.bufferSize * 2) {
        this.$.scroller.scrollTop = this.itemHeight * (index - this._firstIndex) + this._buffers[0].translateY;
      } else {
        this._initialIndex = ~~index;
        this._reset();
        this.unlisten(this.$.scroller, 'scroll', '_scroll');
        this.$.scroller.scrollTop += index % 1 * this.itemHeight;
        this.listen(this.$.scroller, 'scroll', '_scroll');
      }

      if (this._mayHaveMomentum) {
        // Stop the possible iOS Safari momentum with -webkit-overflow-scrolling: auto;
        this.$.scroller.classList.add('notouchscroll');
        this._mayHaveMomentum = false;

        this.async(function() {
          // Restore -webkit-overflow-scrolling: touch; after a small delay.
          this.$.scroller.classList.remove('notouchscroll');
        }, 10);
      }

    },

    /**
     * @private
     */
    get position() {
      return (this.$.scroller.scrollTop - this._buffers[0].translateY) / this.itemHeight + this._firstIndex;
    },

    _reset: function() {
      this.unlisten(this.$.scroller, 'scroll', '_scroll');
      this.$.scroller.scrollTop = this._initialScroll;
      this._buffers[0].translateY = this._initialScroll - this._bufferHeight;
      this._buffers[1].translateY = this._initialScroll;
      this._buffers.forEach(function(buffer) {
        Polymer.Base.transform('translate3d(0, ' + buffer.translateY + 'px, 0)', buffer);
      });
      this._buffers[0].updated = this._buffers[1].updated = false;
      this._updateClones(true);

      this.debounce('updateAllClones', function() {
        this._buffers[0].updated = this._buffers[1].updated = false;
        this._updateClones();
      }, 200);

      this.listen(this.$.scroller, 'scroll', '_scroll');
    },

    _createPool: function() {
      var container = this.getBoundingClientRect();
      this._buffers.forEach(function(buffer) {
        for (var i = 0; i < this.bufferSize; i++) {
          var itemWrapper = document.createElement('div');
          itemWrapper.style.height = this.itemHeight + 'px';
          itemWrapper.instance = {};

          Polymer.dom(buffer).appendChild(itemWrapper);

          this.async(function(itemWrapper, container) {
            // Only stamp the visible instances first
            if (this._isVisible(itemWrapper, container)) {
              this._ensureStampedInstance(itemWrapper);
            }
          }.bind(this, itemWrapper, container), 1); // Wait for first reset

          Polymer.RenderStatus.afterNextRender(itemWrapper, this._finishInit.bind(this));

        }
      }, this);
    },

    _ensureStampedInstance: function(itemWrapper) {
      if (itemWrapper.firstElementChild) {
        return;
      }

      var tmpInstance = itemWrapper.instance;
      itemWrapper.instance = this.stamp({});
      Polymer.dom(itemWrapper).appendChild(itemWrapper.instance.root);

      Object.keys(tmpInstance).forEach(function(prop) {
        itemWrapper.instance[prop] = tmpInstance[prop];
      });
    },

    _updateClones: function(viewPortOnly) {
      this._firstIndex = ~~((this._buffers[0].translateY - this._initialScroll) / this.itemHeight) + this._initialIndex;

      var scrollerRect = viewPortOnly ? this.$.scroller.getBoundingClientRect() : undefined;
      this._buffers.forEach(function(buffer, bufferIndex) {
        if (!buffer.updated) {
          var firstIndex = this._firstIndex + this.bufferSize * bufferIndex;

          [].forEach.call(buffer.children, function(itemWrapper, index) {
            if (!viewPortOnly || this._isVisible(itemWrapper, scrollerRect)) {
              itemWrapper.instance.index = firstIndex + index;
            }
          }.bind(this));
          buffer.updated = true;
        }
      }, this);
    },

    _isVisible: function(element, container) {
      var rect = element.getBoundingClientRect();
      return rect.bottom > container.top && rect.top < container.bottom;
    },

    /**
     * Implements extension point from Templatizer mixin
     * Called as side-effect of a host property change, responsible for
     * notifying parent path change on each row.
     */
    _forwardParentProp: function(prop, value) {
      if (prop !== 'index') {
        this._buffers.forEach(function(buffer) {
          [].forEach.call(buffer.children, function(itemWrapper) {
            itemWrapper.instance[prop] = value;
          });
        });
      }
    },

    /**
     * Implements extension point from Templatizer
     * Called as side-effect of a host path change, responsible for
     * notifying parent.<path> path change on each row.
     */
    _forwardParentPath: function(prop, value) {
      if (prop !== 'index') {
        this._buffers.forEach(function(buffer) {
          [].forEach.call(buffer.children, function(itemWrapper) {
            itemWrapper.instance.notifyPath(prop, value, true);
          });
        });
      }
    }

  });
</script>
<!--
@license
Copyright (c) 2016 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
--><iron-iconset-svg size="24" name="vaadin-date-picker">
<svg><defs>
<g id="chevron-right"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g>
<g id="clear"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></g>
<g id="event"><path d="M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"></path></g>
</defs></svg>
</iron-iconset-svg>
<dom-module id="vaadin-date-picker-overlay" assetpath="../../../bower_components/vaadin-date-picker/">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
        background: var(--primary-background-color);
        font: inherit;
        outline: none;
        @apply(--paper-font-common-base);
        @apply(--shadow-elevation-2dp);
        @apply(--vaadin-date-picker-overlay);
      }

      #toolbar {
        display: flex;
        justify-content: space-between;
        padding: 14px;
        background: var(--primary-background-color);
        z-index: 2;
        @apply(--paper-font-button);
        @apply(--shadow-elevation-2dp);
        flex-shrink: 0;
        transform: translateZ(0);
        color: var(--primary-color);
        @apply(--vaadin-date-picker-toolbar);
      }

      #toolbar:not([desktop]) {
        cursor: pointer;
      }

      #toolbar iron-icon {
        fill: var(--primary-color);
        padding: 0;
        transition: transform 200ms;
        will-change: transform;
        --iron-icon-width: 20px;
        --iron-icon-height: 20px;
        @apply(--vaadin-date-picker-toolbar-icon);
      }

      #toolbar iron-icon[rotate] {
        transform: rotate(180deg);
      }

      #toolbar iron-icon[hidden] {
        display: none;
      }

      #scrollers {
        display: flex;
        flex-direction: row;
        height: 100%;
        width: 100%;
        position: relative;
        overflow: hidden;
      }

      #scrollers #fade {
        pointer-events: none;
        display: block;
        background: linear-gradient(90deg, var(--primary-background-color), rgba(255, 255, 255, 0));
        width: 50px;
        position: absolute;
        height: 100%;
        z-index: 1;
        transform: translateX(-100%);
        @apply(--vaadin-date-picker-scrollers-fade);
      }

      #scrollers[desktop] #fade {
        display: none;
      }

      #scroller,
      #yearScroller {
        height: 100%;
      }

      #scroller {
        padding: 0 8px;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }

      #scrollers[desktop] #scroller {
        right: 50px;
        transform: none !important;
      }

      #yearScroller {
        text-align: center;
        width: 50px;
        background: var(--dark-theme-background-color);
        color: var(--dark-theme-secondary-color);
        cursor: pointer;
        position: absolute;
        right: 0;
        transform: translateX(100%);
        -webkit-tap-highlight-color: transparent;
        @apply(--paper-font-menu);
        @apply(--vaadin-date-picker-yearscroller);
      }

      #yearScroller div {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      #scrollers[desktop] #yearScroller {
        position: absolute;
        transform: none !important;
      }

      #yearScroller {
        /* Center the year scroller position. */
        --vaadin-infinite-scroller-buffer: {
          top: 50%;
          margin-top: -12px;
          width: 90px;
        }
      }

      #yearScroller::before {
        content: '';
        display: block;
        background: transparent;
        width: 0;
        height: 0;
        position: absolute;
        left: 0;
        top: 50%;
        margin-top: -6px;
        border-width: 6px;
        border-style: solid;
        border-color: transparent;
        border-left-color: var(--primary-background-color);
        @apply(--vaadin-date-picker-yearscroller-indicator);
      }

      :host(.animate) vaadin-infinite-scroller {
        transition: all 200ms;
      }

      :host(:not([fullscreen])) #header {
        display: none;
      }

      #toolbar[desktop] {
        display: none;
      }

      #header {
        background: var(--primary-color);
        padding: 0 14px 14px;
        display: flex;
        flex-shrink: 0;
        height: 64px; /* height set to 64px to match app-toolbar height */
        box-sizing: border-box;

        @apply(--paper-font-subhead);
        @apply(--shadow-elevation-2dp);
        @apply(--vaadin-date-picker-header);
      }

      #header label,
      #header input {
        color: var(--dark-theme-text-color);
      }

      #header iron-icon {
        color: var(--dark-theme-text-color);
        cursor: pointer;
      }

      #toggle {
        align-self: flex-end;
      }

      #header paper-input-container {
        flex: 1;
        margin-right: 24px;
        padding-bottom: 0;
        --paper-input-container-underline: {
          display: none;
        };
        --paper-input-container-underline-focus: {
          display: block;
          background: var(--dark-theme-text-color);
          -webkit-transform: none;
          transform: none;
        };
      }

      #clear {
        display: none;
      }

      #clear[showclear] {
        display: flex;
      }

      #footer {
        display: flex;
        justify-content: space-between;
        padding: 4px;
        @apply(--paper-font-body2);
        background: var(--primary-background-color);
        z-index: 2;
        box-shadow: 0 -1px 4px 0 rgba(0, 0, 0, 0.5);
        color: var(--primary-color);
        flex-shrink: 0;
        @apply(--vaadin-date-picker-footer);
      }

      paper-button.keyboard-focus {
        color: var(--primary-background-color);
        background: var(--primary-color);
        outline: none;
      }

      #announcer {
        display: inline-block;
        position: fixed;
        clip: rect(0, 0, 0, 0);
        clip-path: inset(100%);
      }
    </style>

    <div id="announcer" role="alert" aria-live="polite">
      [[i18n.calendar]]
    </div>

    <div id="header" on-touchend="_preventDefault" aria-hidden="true">
      <paper-input-container>
        <label>[[label]]</label>
        <input id="input" readonly="" is="iron-input" autocomplete="off" bind-value="[[_formatDisplayed(selectedDate, i18n.formatDate)]]">
        <iron-icon id="clear" suffix="" on-tap="_clear" icon="vaadin-date-picker:clear" showclear$="[[_showClear(selectedDate)]]"></iron-icon>
      </paper-input-container>
      <iron-icon id="toggle" icon="vaadin-date-picker:event" on-tap="_cancel"></iron-icon>
    </div>

    <div id="toolbar" desktop$="[[_desktopMode]]" on-tap="_toggleYearScroller" aria-hidden="true">
      [[_yearAfterXMonths(_visibleMonthIndex)]]
      <iron-icon rotate$="[[_isYearScrollerVisible(_translateX)]]" icon="vaadin-date-picker:chevron-right"></iron-icon>
    </div>

    <div id="scrollers" desktop$="[[_desktopMode]]" on-track="_track">
      <div id="fade"></div>
      <vaadin-infinite-scroller id="scroller" on-scroll="_onMonthScroll" on-touchstart="_onMonthScrollTouchStart" item-height="250" buffer-size="6" active="[[initialPosition]]">
        <template>
          <vaadin-month-calendar i18n="[[i18n]]" month="[[_dateAfterXMonths(index)]]" selected-date="{{selectedDate}}" focused-date="[[focusedDate]]" ignore-taps="[[_ignoreTaps]]" show-week-numbers="[[showWeekNumbers]]" min-date="[[minDate]]" max-date="[[maxDate]]" focused$="[[_focused]]">
          </vaadin-month-calendar>
        </template>
      </vaadin-infinite-scroller>
      <vaadin-infinite-scroller id="yearScroller" on-tap="_onYearTap" on-scroll="_onYearScroll" on-touchstart="_onYearScrollTouchStart" item-height="80" buffer-size="25" active="[[initialPosition]]">
        <template>
          <div role="button">[[_yearAfterXYears(index)]]</div>
          <div style="font-size: 18px; line-height: 56px; opacity: 0.3;" aria-hidden="true">•</div>
        </template>
      </vaadin-infinite-scroller>
    </div>

    <div id="footer" on-touchend="_preventDefault" role="toolbar">
      <paper-button id="todayButton" disabled="[[!_isTodayAllowed(minDate, maxDate)]]" on-tap="_onTodayTap">
        [[i18n.today]]
      </paper-button>
      <paper-button id="cancelButton" on-tap="_cancel">
        [[i18n.cancel]]
      </paper-button>
    </div>

    <iron-media-query query="(min-width: 375px)" query-matches="{{_desktopMode}}"></iron-media-query>
  </template>
  <script>
    Polymer({
      is: 'vaadin-date-picker-overlay',

      listeners: {
        'keydown': '_onKeydown',
        'scroll': '_stopPropagation',
        'tap': '_stopPropagation',
        'focus': '_onOverlayFocus',
        'blur': '_onOverlayBlur'
      },

      hostAttributes: {
        'tabIndex': '0'
      },

      properties: {
        /**
         * The value for this element.
         */
        selectedDate: {
          type: Date,
          notify: true
        },

        /**
         * Date value which is focused using keyboard.
         */
        focusedDate: {
          type: Date,
          notify: true,
          observer: '_focusedDateChanged'
        },

        _focusedMonthDate: Number,

        /**
         * Date which should be visible when there is no value selected.
         */
        initialPosition: {
          type: Date,
          observer: '_initialPositionChanged'
        },

        _originDate: {
          value: new Date()
        },

        _visibleMonthIndex: Number,

        _desktopMode: Boolean,

        _translateX: {
          observer: '_translateXChanged'
        },

        _yearScrollerWidth: {
          value: 50
        },

        i18n: {
          type: Object
        },

        showWeekNumbers: {
          type: Boolean
        },

        _ignoreTaps: Boolean,

        _notTapping: Boolean,

        /**
         * The earliest date that can be selected. All earlier dates will be disabled.
         */
        minDate: Date,

        /**
         * The latest date that can be selected. All later dates will be disabled.
         */
        maxDate: Date,

        _focused: Boolean
      },

      /**
       * Fired when the scroller reaches the target scrolling position.
       * @event scroll-animation-finished
       * @param {Number} detail.position new position
       * @param {Number} detail.oldPosition old position
       */

      attached: function() {
        this._translateX = this._yearScrollerWidth;
        this.toggleClass('animate', true);
        this.setScrollDirection('y', this.$.scrollers);
        Polymer.IronA11yAnnouncer.requestAvailability();
      },

      announceFocusedDate: function() {
        var focusedDate = this._currentlyFocusedDate();
        var announce = [];
        if (vaadin.elements.datepicker.DatePickerHelper._dateEquals(focusedDate, new Date())) {
          announce.push(this.i18n.today);
        }
        announce = announce.concat([
          this.i18n.weekdays[focusedDate.getDay()],
          focusedDate.getDate(),
          this.i18n.monthNames[focusedDate.getMonth()],
          focusedDate.getFullYear()
        ]);
        if (this.showWeekNumbers && this.i18n.firstDayOfWeek === 1) {
          announce.push(this.i18n.week);
          announce.push(vaadin.elements.datepicker.DatePickerHelper._getISOWeekNumber(focusedDate));
        }
        this.fire('iron-announce', {text: announce.join(' ')});
        return;
      },

      /**
       * Focuses the cancel button
       */
      focusCancel: function() {
        this.$.cancelButton.focus();
      },

      /**
       * Scrolls the list to the given Date.
       */
      scrollToDate: function(date, animate) {
        this._scrollToPosition(this._differenceInMonths(date, this._originDate), animate);
      },

      _focusedDateChanged: function(focusedDate) {
        this.revealDate(focusedDate);
      },

      /**
       * Scrolls the month and year scrollers enough to reveal the given date.
       */
      revealDate: function(date) {
        if (date) {
          var diff = this._differenceInMonths(date, this._originDate);
          var scrolledAboveViewport = this.$.scroller.position > diff;

          var visibleItems = this.$.scroller.clientHeight / this.$.scroller.itemHeight;
          var scrolledBelowViewport = this.$.scroller.position + visibleItems - 1 < diff;

          if (scrolledAboveViewport) {
            this._scrollToPosition(diff, true);
          } else if (scrolledBelowViewport) {
            this._scrollToPosition(diff - visibleItems + 1, true);
          }
        }
      },

      _onOverlayFocus: function() {
        this._focused = true;
      },

      _onOverlayBlur: function() {
        this._focused = false;
      },

      _initialPositionChanged: function(initialPosition) {
        this.scrollToDate(initialPosition);
      },

      _repositionYearScroller: function() {
        this._visibleMonthIndex = Math.floor(this.$.scroller.position);
        this.$.yearScroller.position = (this.$.scroller.position + this._originDate.getMonth()) / 12;
      },

      _repositionMonthScroller: function() {
        this.$.scroller.position = this.$.yearScroller.position * 12 - this._originDate.getMonth();
        this._visibleMonthIndex = Math.floor(this.$.scroller.position);
      },

      _onMonthScroll: function() {
        this._repositionYearScroller();
        this._doIgnoreTaps();
      },

      _onYearScroll: function() {
        this._repositionMonthScroller();
        this._doIgnoreTaps();
      },

      _onYearScrollTouchStart: function() {
        this._notTapping = false;
        this.async(function() {
          this._notTapping = true;
        }, 300);

        this._repositionMonthScroller();
      },

      _onMonthScrollTouchStart: function() {
        this._repositionYearScroller();
      },

      _doIgnoreTaps: function() {
        this._ignoreTaps = true;
        this.debounce('restore-taps', function() {
          this._ignoreTaps = false;
        }, 300);
      },

      _formatDisplayed: function(date, formatDate) {
        if (date) {
          return formatDate(date);
        }
      },

      _onTodayTap: function() {
        var today = new Date();
        if (this.$.scroller.position === this._differenceInMonths(today, this._originDate)) {
          // Select today only if the month scroller is positioned exactly
          // at the beginning of the current month
          this.selectedDate = today;
          this._close();
        } else {
          this._scrollToCurrentMonth();
        }
      },

      _scrollToCurrentMonth: function() {
        if (this.focusedDate) {
          this.focusedDate = new Date();
        }

        this.scrollToDate(new Date(), true);
      },

      _showClear: function(selectedDate) {
        return selectedDate !== null;
      },

      _onYearTap: function(e) {
        if (!this._ignoreTaps && !this._notTapping) {
          var scrollDelta = e.detail.y - (this.$.yearScroller.getBoundingClientRect().top + this.$.yearScroller.clientHeight / 2);
          var yearDelta = scrollDelta / this.$.yearScroller.itemHeight;
          this._scrollToPosition(this.$.scroller.position + yearDelta * 12, true);
        }
      },

      _scrollToPosition: function(targetPosition, animate) {
        if (this._targetPosition !== undefined) {
          this._targetPosition = targetPosition;
          return;
        }

        if (!animate) {
          this.$.scroller.position = targetPosition;
          this._targetPosition = undefined;
          this._repositionYearScroller();
          return;
        }

        this._targetPosition = targetPosition;

        // http://gizma.com/easing/
        var easingFunction = function(t, b, c, d) {
          t /= d / 2;
          if (t < 1) {
            return c / 2 * t * t + b;
          }
          t--;
          return -c / 2 * (t * (t - 2) - 1) + b;
        };

        var duration = animate ? 300 : 0;
        var start = 0;
        var initialPosition = this.$.scroller.position;

        var smoothScroll = function(timestamp) {
          start = start || timestamp;
          var currentTime = timestamp - start;

          if (currentTime < duration) {
            var currentPos = easingFunction(currentTime, initialPosition, this._targetPosition - initialPosition, duration);
            this.$.scroller.position = currentPos;
            window.requestAnimationFrame(smoothScroll);
          } else {
            this.fire('scroll-animation-finished', {
              position: this._targetPosition,
              oldPosition: initialPosition
            });
            this.$.scroller.position = this._targetPosition;
            this._targetPosition = undefined;
          }

          this.async(this._repositionYearScroller, 1);
        }.bind(this);

        // Start the animation.
        window.requestAnimationFrame(smoothScroll);
      },

      _limit: function(value, range) {
        return Math.min(range.max, Math.max(range.min, value));
      },

      _handleTrack: function(e) {
        // Check if horizontal movement threshold (dx) not exceeded or
        // scrolling fast vertically (ddy).
        if (Math.abs(e.detail.dx) < 10 || Math.abs(e.detail.ddy) > 10) {
          return;
        }

        // If we're flinging quickly -> start animating already.
        if (Math.abs(e.detail.ddx) > this._yearScrollerWidth / 3) {
          this.toggleClass('animate', true);
        }

        var newTranslateX = this._translateX + e.detail.ddx;
        this._translateX = this._limit(newTranslateX, {
          min: 0,
          max: this._yearScrollerWidth
        });
      },

      _track: function(e) {
        if (this._desktopMode) {
          // No need to track for swipe gestures on desktop.
          return;
        }

        switch (e.detail.state) {
          case 'start':
            this.toggleClass('animate', false);
            break;

          case 'track':
            this._handleTrack(e);
            break;

          case 'end':
            this.toggleClass('animate', true);
            if (this._translateX >= this._yearScrollerWidth / 2) {
              this._closeYearScroller();
            } else {
              this._openYearScroller();
            }
            break;
        }
      },

      _toggleYearScroller: function() {
        this._isYearScrollerVisible() ? this._closeYearScroller() : this._openYearScroller();
      },

      _openYearScroller: function() {
        this._translateX = 0;
      },

      _closeYearScroller: function() {
        this._translateX = this._yearScrollerWidth;
      },

      _isYearScrollerVisible: function() {
        return this._translateX < this._yearScrollerWidth / 2;
      },

      _translateXChanged: function(x) {
        if (!this._desktopMode) {
          this.transform('translateX(' + (x - this._yearScrollerWidth) + 'px)', this.$.scroller);
          this.transform('translateX(' + x + 'px)', this.$.yearScroller);
          this.transform('translateX(' + -x + 'px)', this.$.fade);
        }
      },

      _yearAfterXYears: function(index) {
        var result = new Date(this._originDate);
        result.setFullYear(parseInt(index) + this._originDate.getFullYear());
        return result.getFullYear();
      },

      _yearAfterXMonths: function(months) {
        return this._dateAfterXMonths(months).getFullYear();
      },

      _dateAfterXMonths: function(months) {
        var result = new Date(this._originDate);
        result.setDate(1);
        result.setMonth(parseInt(months) + this._originDate.getMonth());
        return result;
      },

      _differenceInMonths: function(date1, date2) {
        var months = (date1.getFullYear() - date2.getFullYear()) * 12;
        return months - date2.getMonth() + date1.getMonth();
      },

      _differenceInYears: function(date1, date2) {
        return this._differenceInMonths(date1, date2) / 12;
      },

      _clear: function() {
        this.selectedDate = '';
        this._close();
      },

      _close: function() {
        this.fire('close');
      },

      _cancel: function() {
        this.focusedDate = this.selectedDate;
        this._close();
      },

      _preventDefault: function(e) {
        e.preventDefault();
      },

      /**
       * Keyboard Navigation
       */
      _eventKey: function(e) {
        var keys = ['down', 'up', 'right', 'left', 'enter', 'space', 'home', 'end', 'pageup', 'pagedown', 'tab'];

        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(e, k)) {
            return k;
          }
        }
      },

      _onKeydown: function(e) {
        var focus = this._currentlyFocusedDate();

        var eventKey = this._eventKey(e);
        if (eventKey === 'tab') {
          e.stopPropagation();
          if (this.hasAttribute('fullscreen')) {
            e.preventDefault();
          } else if ((this.$.cancelButton.focused && !e.shiftKey) || (this._focused && e.shiftKey)) {
            // Return focus back to the input field
            e.preventDefault();
            this.fire('focus-input');
          } else {
            this.async(function() {
              if (this._focused) {
                this.revealDate(this.focusedDate);
              }
            }, 1);
          }
        } else if (eventKey) {
          e.preventDefault();
          e.stopPropagation();

          switch (eventKey) {
            case 'down':
              this._moveFocusByDays(7);
              this.focus();
              break;
            case 'up':
              this._moveFocusByDays(-7);
              this.focus();
              break;
            case 'right':
              if (!this._buttonFocused()) {
                this._moveFocusByDays(1);
              }
              break;
            case 'left':
              if (!this._buttonFocused()) {
                this._moveFocusByDays(-1);
              }
              break;
            case 'enter':
              if (!this._buttonFocused()) {
                this._close();
              }
              break;
            case 'space':
              var focusedDate = this.focusedDate;
              if (vaadin.elements.datepicker.DatePickerHelper._dateEquals(focusedDate, this.selectedDate)) {
                this.selectedDate = '';
                this.focusedDate = focusedDate;
              } else {
                this.selectedDate = focusedDate;
              }
              break;
            case 'home':
              this._moveFocusInsideMonth(focus, 'minDate');
              break;
            case 'end':
              this._moveFocusInsideMonth(focus, 'maxDate');
              break;
            case 'pagedown':
              this._moveFocusByMonths(e.shiftKey ? 12 : 1);
              break;
            case 'pageup':
              this._moveFocusByMonths(e.shiftKey ? -12 : -1);
              break;
          }
        }
      },

      _buttonFocused: function() {
        return this.$.todayButton.focused || this.$.cancelButton.focused;
      },

      _currentlyFocusedDate: function() {
        return this.focusedDate || this.selectedDate || this.initialPosition || new Date();
      },

      _moveFocusByDays: function(days) {
        var focus = this._currentlyFocusedDate();
        var dateToFocus = new Date(0, 0);
        dateToFocus.setFullYear(focus.getFullYear());
        dateToFocus.setMonth(focus.getMonth());
        dateToFocus.setDate(focus.getDate() + days);

        if (this._dateAllowed(dateToFocus, this.minDate, this.maxDate)) {
          this.focusedDate = dateToFocus;
          this._focusedMonthDate = this.focusedDate.getDate();
        } else {
          if (this._dateAllowed(focus, this.minDate, this.maxDate)) {
            // Move to min or max date
            if (days > 0) { // down or right
              this.focusedDate = this.maxDate;
              this._focusedMonthDate = this.maxDate.getDate();
            } else { // up or left
              this.focusedDate = this.minDate;
              this._focusedMonthDate = this.minDate.getDate();
            }
          } else {
            // Move to closest allowed date
            this.focusedDate = vaadin.elements.datepicker.DatePickerHelper._getClosestDate(focus, [this.minDate, this.maxDate]);
            this._focusedMonthDate = this.focusedDate.getDate();
          }
        }
      },

      _moveFocusByMonths: function(months) {
        var focus = this._currentlyFocusedDate();
        var dateToFocus = new Date(0, 0);
        dateToFocus.setFullYear(focus.getFullYear());
        dateToFocus.setMonth(focus.getMonth() + months);

        var targetMonth = dateToFocus.getMonth();

        dateToFocus.setDate(this._focusedMonthDate || (this._focusedMonthDate = focus.getDate()));
        if (dateToFocus.getMonth() !== targetMonth) {
          dateToFocus.setDate(0);
        }

        if (this._dateAllowed(dateToFocus, this.minDate, this.maxDate)) {
          this.focusedDate = dateToFocus;
        } else {
          if (this._dateAllowed(focus, this.minDate, this.maxDate)) {
            // Move to min or max date
            if (months > 0) { // pagedown
              this.focusedDate = this.maxDate;
              this._focusedMonthDate = this.maxDate.getDate();
            } else { // pageup
              this.focusedDate = this.minDate;
              this._focusedMonthDate = this.minDate.getDate();
            }
          } else {
            // Move to closest allowed date
            this.focusedDate = vaadin.elements.datepicker.DatePickerHelper._getClosestDate(focus, [this.minDate, this.maxDate]);
            this._focusedMonthDate = this.focusedDate.getDate();
          }
        }
      },

      _moveFocusInsideMonth: function(focusedDate, property) {
        var dateToFocus = new Date(0, 0);
        dateToFocus.setFullYear(focusedDate.getFullYear());

        if (property === 'minDate') {
          dateToFocus.setMonth(focusedDate.getMonth());
          dateToFocus.setDate(1);
        } else {
          dateToFocus.setMonth(focusedDate.getMonth() + 1);
          dateToFocus.setDate(0);
        }

        if (this._dateAllowed(dateToFocus, this.minDate, this.maxDate)) {
          this.focusedDate = dateToFocus;
          this._focusedMonthDate = this.focusedDate.getDate();
        } else {
          if (this._dateAllowed(focusedDate, this.minDate, this.maxDate)) {
            // Move to minDate or maxDate
            this.focusedDate = this[property];
            this._focusedMonthDate = this[property].getDate();
          } else {
            // Move to closest allowed date
            this.focusedDate = vaadin.elements.datepicker.DatePickerHelper._getClosestDate(focusedDate, [this.minDate, this.maxDate]);
            this._focusedMonthDate = this.focusedDate.getDate();
          }
        }
      },

      _dateAllowed: function(date, min, max) {
        return (!min || date >= min) && (!max || date <= max);
      },

      _isTodayAllowed: function(min, max) {
        var today = new Date();
        var todayMidnight = new Date(0, 0);
        todayMidnight.setFullYear(today.getFullYear());
        todayMidnight.setMonth(today.getMonth());
        todayMidnight.setDate(today.getDate());
        return this._dateAllowed(todayMidnight, min, max);
      },

      _stopPropagation: function(e) {
        e.stopPropagation();
      }
    });
  </script>
</dom-module>
<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.datepicker = vaadin.elements.datepicker || {};

  /** @polymerBehavior vaadin.elements.datepicker.DatePickerBehavior */
  vaadin.elements.datepicker.DatePickerBehaviorImpl = {
    observers: [
      '_selectedDateChanged(_selectedDate, i18n.formatDate)',
      '_validateInput(_selectedDate, _minDate, _maxDate)',
      '_focusedDateChanged(_focusedDate, i18n.formatDate)',
      '_announceFocusedDate(_focusedDate, opened, _ignoreAnnounce)'
    ],

    properties: {
      /**
       * The current selected date.
       */
      _selectedDate: {
        type: Date
      },

      _focusedDate: Date,

      /**
       * The value for this element.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {String}
       */
      value: {
        type: String,
        observer: '_valueChanged'
      },

      /**
       * Indicates whether this date picker has a value.
       */
      hasValue: {
        type: Boolean,
        computed: '_hasValue(value)',
        reflectToAttribute: true
      },

      /**
       * Date which should be visible when there is no value selected.
       *
       * The same date formats as for the `value` property are supported.
       */
      initialPosition: String,

      /**
       * The label for this element.
       */
      label: String,

      /**
       * Set true to open the date selector overlay.
       */
      opened: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true
      },

      /**
       * Set true to display ISO-8601 week numbers in the calendar. Notice that
       * displaying week numbers is only supported when `i18n.firstDayOfWeek`
       * is 1 (Monday).
       */
      showWeekNumbers: {
        type: Boolean
      },

      _fullscreen: {
        value: false,
        observer: '_fullscreenChanged'
      },

      _fullscreenMediaQuery: {
        value: '(max-width: 420px), (max-height: 420px)'
      },

      // An array of ancestor elements whose -webkit-overflow-scrolling is forced from value
      // 'touch' to value 'auto' in order to prevent them from clipping the dropdown. iOS only.
      _touchPrevented: Array,

      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure and default values:

    {
      // An array with the full names of months starting
      // with January.
      monthNames: [
        'January', 'February', 'March', 'April', 'May',
        'June', 'July', 'August', 'September',
        'October', 'November', 'December'
      ],

      // An array of weekday names starting with Sunday. Used
      // in screen reader announcements.
      weekdays: [
        'Sunday', 'Monday', 'Tuesday', 'Wednesday',
        'Thursday', 'Friday', 'Saturday'
      ],

      // An array of short weekday names starting with Sunday.
      // Displayed in the calendar.
      weekdaysShort: [
        'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
      ],

      // An integer indicating the first day of the week
      // (0 = Sunday, 1 = Monday, etc.).
      firstDayOfWeek: 0,

      // Used in screen reader announcements along with week
      // numbers, if they are displayed.
      week: 'Week',

      // Translation of the Calendar icon button title.
      calendar: 'Calendar',

      // Translation of the Clear icon button title.
      clear: 'Clear',

      // Translation of the Today shortcut button text.
      today: 'Today',

      // Translation of the Cancel button text.
      cancel: 'Cancel',

      // A function to format given `Date` object as
      // date string.
      formatDate: function(d) {
        // returns a string representation of the given
        // Date object in 'MM/DD/YYYY' -format
      },

      // A function to parse the given text to a `Date`
      // object. Must properly parse (at least) text
      // formatted by `formatDate`.
      // Setting the property to null will disable
      // keyboard input feature.
      parseDate: function(text) {
        // Parses a string in 'MM/DD/YY', 'MM/DD' or 'DD' -format to
        // a Date object
      }

      // A function to format given `monthName` and
      // `fullYear` integer as calendar title string.
      formatTitle: function(monthName, fullYear) {
        return monthName + ' ' + fullYear;
      }

    }

       *
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: function() {
          return {
            monthNames: [
              'January', 'February', 'March', 'April', 'May',
              'June', 'July', 'August', 'September', 'October', 'November', 'December'
            ],
            weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            firstDayOfWeek: 0,
            week: 'Week',
            calendar: 'Calendar',
            clear: 'Clear',
            today: 'Today',
            cancel: 'Cancel',
            formatDate: function(d) {
              var year = d.getFullYear();
              var yearString = year.toString();
              if (yearString.length < 3 && year >= 0) {
                yearString = (year < 10 ? '000' : '00') + year;
              }
              return (d.getMonth() + 1) + '/' + d.getDate() + '/' + yearString;
            },
            parseDate: function(text) {
              var parts = text.split('/');
              var today = new Date();
              var date, month = today.getMonth(), year = today.getFullYear();

              if (parts.length === 3) {
                year = parseInt(parts[2]);
                if (parts[2].length < 3 && year >= 0) {
                  year += year < 50 ? 2000 : 1900;
                }
                month = parseInt(parts[0]) - 1;
                date = parseInt(parts[1]);
              } else if (parts.length === 2) {
                month = parseInt(parts[0]) - 1;
                date = parseInt(parts[1]);
              } else if (parts.length === 1) {
                date = parseInt(parts[0]);
              }

              if (date !== undefined) {
                var result = new Date(0, 0); // Wrong date (1900-01-01), but with midnight in local time
                result.setFullYear(year);
                result.setMonth(month);
                result.setDate(date);
                return result;
              }
            },
            formatTitle: function(monthName, fullYear) {
              return monthName + ' ' + fullYear;
            }
          };
        }
      },

      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {String}
       */
      min: {
        type: String,
        observer: '_minChanged'
      },

      /**
       * The latest date that can be selected. All later dates will be disabled.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {String}
       */
      max: {
        type: String,
        observer: '_maxChanged'
      },

      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       */
      _minDate: {
        type: Date,
        value: null
      },

      /**
       * The latest date that can be selected. All later dates will be disabled.
       */
      _maxDate: {
        type: Date,
        value: null
      },

      _noInput: {
        type: Boolean,
        computed: '_isNoInput(_fullscreen, i18n, i18n.*, _ios)'
      },

      _ios: {
        type: Boolean,
        value: navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/)
      },

      _ignoreAnnounce: {
        value: true
      },

      _focusOverlayOnOpen: Boolean,

      /**
       * When datepicker is opened, we're setting body pointer-events to none
       * to make the datepicker behave in "modal" way. This variable keeps the
       * previous state of body pointer-events to restore it when datepicker is
       * closed.
       */
      _documentPointerEvents: String
    },

    created: function() {
      this._boundOnScroll = this._onScroll.bind(this);
    },

    listeners: {
      'tap': 'open',
      'touchend': '_preventDefault',
      'keydown': '_onKeydown',
      'close': '_close',
      'date-tap': '_close',
      'focus-input': '_focusAndSelect'
    },

    ready: function() {
      // The value property is also defined in IronFormElementBehavior, which
      // will mix up the default value if set in the property.
      if (this.value === undefined) {
        this.value = '';
      }
    },

    /**
     * Opens the dropdown.
     */
    open: function() {
      this._updateAlignmentAndPosition();
      if (!this.disabled && !this.readonly) {
        this.$.dropdown.open();
      }
    },

    _close: function(e) {
      if (e) {
        e.stopPropagation();
      }
      this.inputElement.focus();
      this.close();
    },

    /**
     * Closes the dropdown.
     */
    close: function() {
      this.$.dropdown.close();
    },

   /**
    * @property inputElement
    * @type HTMLElement
    */
    get inputElement() {
      return this._input();
    },

    _parseDate: function(str) {
      // Parsing with RegExp to ensure correct format
      var parts = /^(\d{4}|[-+]\d{6})-(\d{2})-(\d{2})$/.exec(str);
      if (!parts) {
        return;
      }

      var date = new Date(0, 0); // Wrong date (1900-01-01), but with midnight in local time
      date.setFullYear(parseInt(parts[1], 10));
      date.setMonth(parseInt(parts[2], 10) - 1);
      date.setDate(parseInt(parts[3], 10));
      return date;
    },

    _isNoInput: function() {
      return this._fullscreen || !this.i18n.parseDate || this._ios;
    },

    _formatISO: function(date) {
      return date instanceof Date ?
        (new Date(date.getTime() - date.getTimezoneOffset() * 60000)).toISOString().split('T')[0] :
        '';
    },

    _selectedDateChanged: function(selectedDate, formatDate) {
      this.value = this._formatISO(selectedDate);
      this._focusedDate = selectedDate;
      this._inputValue = selectedDate ? formatDate(selectedDate) : '';
    },

    _focusedDateChanged: function(focusedDate, formatDate) {
      if (!this._ignoreFocusedDateChange && !this._noInput) {
        this._inputValue = focusedDate ? formatDate(focusedDate) : '';
      }
    },

    _hasValue: function(value) {
      return !!value;
    },

    _handleDateChange: function(property, value, oldValue) {
      if (!value) {
        this[property] = null;
        return;
      }

      var date = this._parseDate(value);
      if (!date) {
        this.value = oldValue;
        return;
      }
      if (!(this[property] instanceof Date) ||
        date.getFullYear() !== this[property].getFullYear() ||
        date.getMonth() !== this[property].getMonth() ||
        date.getDate() !== this[property].getDate()) {
        this[property] = date;
      }
    },

    _valueChanged: function(value, oldValue) {
      this._handleDateChange('_selectedDate', value, oldValue);
    },

    _minChanged: function(value, oldValue) {
      this._handleDateChange('_minDate', value, oldValue);
    },

    _maxChanged: function(value, oldValue) {
      this._handleDateChange('_maxDate', value, oldValue);
    },

    _updateAlignmentAndPosition: function() {
      var viewportWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      this.$.dropdown.positionTarget = this._fullscreen ? document.documentElement : this;

      var viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      var bottomAlign = this.getBoundingClientRect().top > viewportHeight / 2;
      var rightAlign = this.getBoundingClientRect().left + this.clientWidth / 2 > viewportWidth / 2;

      this.$.dropdown.verticalAlign = bottomAlign ? 'bottom' : 'top';
      this.$.dropdown.horizontalAlign = this._fullscreen ? null : rightAlign ? 'right' : 'left';

      // Previously used verticalOffset property has been recently deprecated
      // in favor of using top and bottom margins.
      if (this._fullscreen) {
        this.$.dropdown.style.marginTop = 0;
        this.$.dropdown.style.marginBottom = 0;
      } else {
        this.$.dropdown.style.marginTop = (bottomAlign ? 10 : this.clientHeight + 2) + 'px';
        this.$.dropdown.style.marginBottom = (bottomAlign ? this.clientHeight : 10) + 'px';
      }

      this.$.dropdown.refit();
    },

    _fullscreenChanged: function() {
      if (this.$.dropdown.opened) {
        this._updateAlignmentAndPosition();
      }
    },

    _onOverlayOpened: function() {
      var parsedInitialPosition = this._parseDate(this.initialPosition);

      var initialPosition = this._selectedDate || this.$.overlay.initialPosition ||
        parsedInitialPosition || new Date();

      if (parsedInitialPosition ||
        vaadin.elements.datepicker.DatePickerHelper._dateAllowed(initialPosition, this._minDate, this._maxDate)) {
        this.$.overlay.initialPosition = initialPosition;
      } else {
        this.$.overlay.initialPosition =
          vaadin.elements.datepicker.DatePickerHelper._getClosestDate(initialPosition, [this._minDate, this._maxDate]);
      }

      this.$.overlay.scrollToDate(this.$.overlay.focusedDate || this.$.overlay.initialPosition);
      // Have a default focused date
      this._ignoreFocusedDateChange = true;
      this.$.overlay.focusedDate = this.$.overlay.focusedDate || this.$.overlay.initialPosition;
      this._ignoreFocusedDateChange = false;

      window.addEventListener('scroll', this._boundOnScroll, true);
      // We cannot use iron-resize event because 1- we fire it, 2- it's fired
      // many times, 3- causes heigth and scroll issues in safari.
      window.addEventListener('resize', this._boundOnScroll, true);

      // Checking if the browser supports webkitOverflowScrolling
      if (document.createElement('div').style.webkitOverflowScrolling === '') {
        this._touchPrevented = this._preventWebkitOverflowScrollingTouch(this.parentElement);
      }

      if (this._focusOverlayOnOpen) {
        this.$.overlay.focus();
        this._focusOverlayOnOpen = false;
      } else {
        this._focus();
      }

      this.updateStyles();

      // Set body pointer-events to 'none' to disable mouse interactions with
      // other document nodes (datepicker is "modal")
      this._documentPointerEvents = document.body.style.pointerEvents;
      document.body.style.pointerEvents = 'none';

      this._ignoreAnnounce = false;
    },

    // A hack needed for iOS to prevent dropdown from being clipped in an
    // ancestor container with -webkit-overflow-scrolling: touch;
    _preventWebkitOverflowScrollingTouch: function(element) {
      var result = [];
      while (element) {
        if (window.getComputedStyle(element).webkitOverflowScrolling === 'touch') {
          var oldInlineValue = element.style.webkitOverflowScrolling;
          element.style.webkitOverflowScrolling = 'auto';
          result.push({
            element: element,
            oldInlineValue: oldInlineValue
          });
        }
        element = element.parentElement;
      }
      return result;
    },

    _onOverlayClosed: function() {
      this._ignoreAnnounce = true;

      window.removeEventListener('scroll', this._boundOnScroll, true);
      window.removeEventListener('resize', this._boundOnScroll, true);

      if (this._touchPrevented) {
        this._touchPrevented.forEach(function(prevented) {
          prevented.element.style.webkitOverflowScrolling = prevented.oldInlineValue;
        });
        this._touchPrevented = [];
      }

      this.updateStyles();

      // Restore the initial body pointer-events
      document.body.style.pointerEvents = this._documentPointerEvents;

      // Select the parsed input or focused date
      this._ignoreFocusedDateChange = true;
      if (this.i18n.parseDate) {
        var inputValue = this._inputValue;
        var parsedDate = this.i18n.parseDate(inputValue);
        if (this._isValidDate(parsedDate)) {
          this._selectedDate = parsedDate;
        } else {
          this._selectedDate = null;
          this._inputValue = inputValue;
        }
      } else if (this._focusedDate) {
        this._selectedDate = this._focusedDate;
      }
      this._ignoreFocusedDateChange = false;

      var input = window.unwrap ? window.unwrap(this.inputElement) : this.inputElement;
      if ((this.shadowRoot && this.shadowRoot.activeElement === input) || document.activeElement === input) {
        input.selectionStart = input.selectionEnd;
      }

      this.validate();
    },

    detached: function() {
      this._onOverlayClosed();
    },

    _onScroll: function(e) {
      if (e.target === window || !this.$.overlay.contains(e.target)) {
        this.$.dropdown.style.bottom = 'auto';
        this.$.dropdown.resetFit();
        this._updateAlignmentAndPosition();
        this.$.dropdown.fire('iron-resize');
      }
    },

    _preventCancelOnComponentAccess: function(e) {
      var event = Polymer.dom(e.detail);
      if (/tap|mousedown|touchstart/.test(e.detail.type) && event.path.indexOf(this) > -1) {
        e.preventDefault();
      }
    },

    _focus: function() {
      if (this._noInput) {
        this.$.overlay.focus();
      } else {
        this.inputElement.focus();
      }
    },

    _focusAndSelect: function() {
      if (!this._noInput) {
        this._focus();
        this.inputElement.setSelectionRange(0, this._inputValue.length);
      }
    },

    _preventDefault: function(e) {
      e.preventDefault();
    },

    /**
     * Keyboard Navigation
     */
    _eventKey: function(e) {
      var keys = ['down', 'up', 'enter', 'esc', 'tab'];

      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        if (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(e, k)) {
          return k;
        }
      }
    },

    _isValidDate: function(d) {
      return d && !isNaN(d.getTime());
    },

    _onKeydown: function(e) {
      if (this._noInput) {
        // The input element cannot be readonly as it would conflict with
        // the required attribute. Both are not allowed on an input element.
        // Therefore we prevent default on most keydown events.
        var allowedKeys = [
          9 // tab
        ];
        if (allowedKeys.indexOf(e.keyCode) === -1) {
          e.preventDefault();
        }
      }

      switch (this._eventKey(e)) {
        case 'down':
        case 'up':
          // prevent scrolling the page with arrows
          e.preventDefault();

          if (this.opened) {
            this.$.overlay.focus();
            this.$.overlay._onKeydown(e);
          } else {
            this._focusOverlayOnOpen = true;
            this.open();
          }

          break;
        case 'enter':
          if (this.$.overlay.focusedDate) {
            this._selectedDate = this.$.overlay.focusedDate;
          }
          this.close();
          break;
        case 'esc':
          this._focusedDate = this._selectedDate;
          this._close();
          break;
        case 'tab':
          if (this.opened) {
            e.preventDefault();
            // Clear the selection range (remains visible on IE)
            this.inputElement.setSelectionRange(0, 0);
            if (e.shiftKey) {
              this.$.overlay.focusCancel();
            } else {
              this.$.overlay.focus();
              this.$.overlay.revealDate(this._focusedDate);
            }

          }
          break;
      }

    },

    _validateInput: function(date, min, max) {
      if (date && (min || max)) {
        this.invalid = !vaadin.elements.datepicker.DatePickerHelper._dateAllowed(date, min, max);
      }
    },

    _userInputValueChanged: function() {
      var parsedDate = this.i18n.parseDate && this.i18n.parseDate(this._inputValue);
      if (this._isValidDate(parsedDate)) {
        this._ignoreFocusedDateChange = true;
        this._focusedDate = parsedDate;
        this._ignoreFocusedDateChange = false;
      }

      if (!this.opened) {
        this.open();
        // iOS needs a refit after input blur animation has finished
        this.$.dropdown.async(this.$.dropdown.refit, 500);
      }
    },

    _announceFocusedDate: function(_focusedDate, opened, _ignoreAnnounce) {
      if (opened && !_ignoreAnnounce) {
        this.$.overlay.announceFocusedDate();
      }
    }
  };

  /** @polymerBehavior vaadin.elements.datepicker.DatePickerBehavior */
  vaadin.elements.datepicker.DatePickerBehavior = [
    Polymer.IronFormElementBehavior,
    Polymer.IronValidatableBehavior,
    Polymer.IronA11yKeysBehavior,
    vaadin.elements.datepicker.DatePickerBehaviorImpl
  ];

  /**
   * Fired when the value changes.
   *
   * @event value-changed
   * @param {Object} detail
   *  @param {String} detail.value the date value or an empty `String`.
   */
</script><dom-module id="vaadin-date-picker" assetpath="../../../bower_components/vaadin-date-picker/">
  <template>
    <style>
      :host {
        display: block;
      }

      :host([opened]) {
        pointer-events: auto;
      }

      #overlay {
        height: 100vh;
        width: 420px;
      }

      #inputcontainer {
        padding-bottom: 0;
      }

      #inputcontainer,
      #inputcontainer input {
        cursor: pointer;
      }

      #inputcontainer:focus {
        outline: none;
      }

      paper-input-container div[suffix] {
        box-sizing: content-box;
        position: absolute;
        right: -4px;
        bottom: -4px;
        width: 24px;
        height: 24px;
        padding: 4px;
        text-align: center;
      }

      paper-input-container iron-icon {
        fill: rgba(0, 0, 0, .26);
        cursor: pointer;
        --iron-icon-width: 20px;
        --iron-icon-height: 20px;
        margin-top: -1px;
        transition: fill 0.2s;
      }

      paper-input-container paper-ripple {
        color: rgba(0, 0, 0, .54);
      }

      :host([opened]) paper-input-container {
        --paper-input-container-underline-focus: {
          -webkit-transform: none;
          transform: none;
        }
      }

      paper-input-container iron-icon:hover,
      :host([opened]) paper-input-container iron-icon {
        fill: rgba(0, 0, 0, .54);
      }

      :host([opened]) paper-input-container iron-icon:hover {
        fill: rgba(0, 0, 0, .86);
      }

      #input[no-input] {
        pointer-events: none;
      }

      #clear {
        right: 28px;
      }

      #clear iron-icon {
        @apply(--vaadin-date-picker-clear-icon);
      }

      #calendar iron-icon {
        @apply(--vaadin-date-picker-calendar-icon);
      }

      :host([disabled]) #calendar,
      :host([readonly]) #calendar,
      :host(:not([opened])) #clear,
      :host(:not([has-value])) #clear,
      :host([readonly]) #clear,
      :host([disabled]) #clear {
        display: none;
      }

      #input {
        box-sizing: border-box;
        padding-right: 28px;
      }

      #input::-ms-clear {
        display: none;
      }

      :host([opened][has-value]) #input {
        padding-right: 60px;
        margin-right: -32px;
      }
    </style>

    <paper-input-container id="inputcontainer" auto-validate$="[[autoValidate]]" invalid$="[[invalid]]" disabled$="[[disabled]]" role="application" always-float-label="[[_computeAlwaysFloatLabel(placeholder)]]">
      <label id="label" aria-hidden="true">[[label]]</label>
      <input id="input" is="iron-input" autocomplete="off" type="text" on-focus="_focus" value="{{_userInputValue::input}}" name$="[[name]]" placeholder$="[[placeholder]]" aria-label$="[[label]]" invalid="{{invalid}}" required$="[[required]]" validator="[[validator]]" disabled$="[[disabled]]" readonly$="[[readonly]]" no-input$="[[_noInput]]">
      <div suffix="" id="clear" on-tap="_clear" role="button" aria-label$="[[i18n.clear]]">
        <iron-icon icon="vaadin-date-picker:clear"></iron-icon>
        <paper-ripple class="circle" center=""></paper-ripple>
      </div>
      <div suffix="" id="calendar" on-tap="_toggle" role="button" aria-label$="[[i18n.calendar]]" aria-expanded$="[[_getAriaExpanded(opened)]]">
        <iron-icon icon="vaadin-date-picker:event"></iron-icon>
        <paper-ripple class="circle" center=""></paper-ripple>
      </div>
      <template is="dom-if" if="[[errorMessage]]">
        <paper-input-error aria-live="assertive">[[errorMessage]]</paper-input-error>
      </template>
    </paper-input-container>

    <iron-dropdown id="dropdown" fullscreen$="[[_fullscreen]]" allow-outside-scroll="" on-iron-overlay-opened="_onOverlayOpened" on-iron-overlay-closed="_onOverlayClosed" on-iron-overlay-canceled="_preventCancelOnComponentAccess" opened="{{opened}}" no-auto-focus="">
      <vaadin-date-picker-overlay id="overlay" i18n="[[i18n]]" fullscreen$="[[_fullscreen]]" label="[[label]]" selected-date="{{_selectedDate}}" class="dropdown-content" focused-date="{{_focusedDate}}" show-week-numbers="[[showWeekNumbers]]" min-date="[[_minDate]]" max-date="[[_maxDate]]" role="dialog">
      </vaadin-date-picker-overlay>
    </iron-dropdown>

    <iron-media-query query="[[_fullscreenMediaQuery]]" query-matches="{{_fullscreen}}">
    </iron-media-query>
  </template>

  <script>
    Polymer({
      is: 'vaadin-date-picker',

      behaviors: [
        vaadin.elements.datepicker.DatePickerBehavior
      ],

      properties: {
        /**
         * Set to true to auto-validate the input value.
         */
        autoValidate: {
          type: Boolean,
          value: false
        },

        /**
         * Set to true to disable this element.
         */
        disabled: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },

        /**
         * Set to true to make this element read-only.
         */
        readonly: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },

        /**
         * A placeholder string in addition to the label. If this is set, the label will always float.
         */
        placeholder: String,

        /**
         * The error message to display when the input is invalid.
         */
        errorMessage: String,

        _userInputValue: String
      },

      observers: [
        '_userInputValueChanged(_userInputValue)'
      ],

      // TODO: revisit this in order to use validatable-behavior for both the full and
      // the light component. Consider auto-validate, and validate(value) signature.
      /**
       * Override the IronValidatableBehavior._getValidity implementation, replacing
       * it with the iron-input validation.
       */
      _getValidity: function() {
        var inputValid = !this._inputValue || (this._selectedDate && this._inputValue === this.i18n.formatDate(this._selectedDate));
        var minMaxValid = !this._selectedDate ||
            vaadin.elements.datepicker.DatePickerHelper._dateAllowed(this._selectedDate, this._minDate, this._maxDate);
        return this.inputElement.validate() && inputValid && minMaxValid;
      },

      _clear: function(e) {
        e.stopPropagation();
        this.value = '';
        this.close();
      },

      _toggle: function(e) {
        e.stopPropagation();
        this[this.$.dropdown.opened ? 'close' : 'open']();
      },

      _input: function() {
        return this.$.input;
      },

      /**
       * label and placeholder will go on top of each other if always-float-label isn't set
       * This is the similar behavior as paper-input has:
       * PolymerElements/paper-input/blob/d248dad17af3ee46a0701a664e0f304c1619770d/paper-input-behavior.html#L502
       */
      _computeAlwaysFloatLabel: function(placeholder) {
        return Boolean(placeholder);
      },

      set _inputValue(value) {
        this.inputElement.bindValue = value;
      },

      get _inputValue() {
        return this.inputElement.bindValue;
      },

      _getAriaExpanded: function(opened) {
        return Boolean(opened).toString();
      }
    });
  </script>
</dom-module>
<dom-module id="patient-editor" assetpath="/">
  <template>
    <style include="shared-styles">
      :host {
        display: flex;
        flex-direction: column;
        flex: 1;
      }

      header {
        width: 100%;
        display: flex;
        align-items: center;
      }

      header h1 {
        color: #9DD22D;
        text-transform: uppercase;
        display: inline-block;
        margin: 1rem auto;
        border-bottom: 2px solid #9DD22D;
        padding-bottom: 0.25rem;
        font-size: 1.2rem;
      }

      .form-wrapper {
        width: 80%;
        margin: 0 auto;
      }

      footer {
        margin: 3rem auto;
      }

      footer button {
        margin-right: 0.5rem;
      }

      footer button:last-child {
        margin-right: 0;
      }

      @media (max-width: 700px) {
        .form-wrapper {
          width: 90%
        }

        .field label {
          width: 100%;
        }
      }
    </style>
    <header>
      <h1>Editing profile</h1>
      <paper-icon-button icon="close" on-tap="close" class="close-button"></paper-icon-button>
    </header>
    <div class="form-wrapper">

      <template is="dom-if" if="[[patient.id]]">
        <div class="field">
          <label>Patient Id</label>
          <span>{{patient.id}}</span>
        </div>
      </template>

      <div class="spacer"></div>

      <div class="field">
        <label for="title">Title</label>
        <vaadin-combo-box id="title" items="[[titles]]" value="{{model.title}}" required="" class="input"></vaadin-combo-box>
      </div>

      <div class="field">
        <label for="firstName">First name</label>
        <paper-input id="firstName" value="{{model.firstName}}" required="" class="input"></paper-input>
      </div>

      <div class="field">
        <label for="middleName">Middle name</label>
        <paper-input id="middleName" value="{{model.middleName}}" required="" class="input"></paper-input>
      </div>

      <div class="field">
        <label for="lastName">Middle name</label>
        <paper-input id="lastName" value="{{model.lastName}}" required="" class="input"></paper-input>
      </div>

      <div class="spacer"></div>

      <div class="field">
        <label for="gender">Gender</label>
        <vaadin-combo-box id="gender" items="[[genders]]" required="" value="{{model.gender}}" class="input"></vaadin-combo-box>
      </div>

      <div class="field">
        <label for="birthDate">Date of birth</label>
        <vaadin-date-picker id="birthDate" value="{{model.birthDate}}" class="input" required=""></vaadin-date-picker>
      </div>

      <div class="field">
        <label for="ssn">SSN</label>
        <paper-input id="ssn" pattern="\d{3}-\d{2}-\d{4}" value="{{model.ssn}}" class="input" required=""></paper-input>
      </div>

      <div class="spacer"></div>

      <div class="field">
        <label for="doctor">Doctor</label>
        <vaadin-combo-box id="doctor" items="[[doctors]]" item-label-path="fullName" item-value-path="id" selected-item="{{model.doctor}}" class="input" required=""></vaadin-combo-box>
      </div>

      <footer>
        <button class="primary" disabled="[[!valid]]" on-tap="save">Save</button>
        <a class="button" on-tap="close">Cancel</a>
        <button type="button" hidden="[[!patient.id]]" class="danger" on-tap="_deletePatient">Delete</button>
      </footer>
    </div>
  </template>
  <script>
    Polymer({
      is: 'patient-editor',
      behaviors: [PatientPortal.NavHelpers],
      properties: {
        route: Object,
        patient: {
          type: Object,
          notify: true,
          observer: '_patientChanged'
        },
        model: Object,
        titles: {
          type: Array,
          value: function () {
            return ['Miss', 'Ms', 'Mrs', 'Mr'];
          }
        },
        genders: {
          type: Array,
          value: function () {
            return [{
              label: 'Male',
              value: 'MALE'
            }, {
              label: 'Female',
              value: 'FEMALE'
            }, {
              label: 'Other',
              value: 'OTHER'
            }]
          }
        },
        doctors: Array,
        valid: Boolean
      },

      observers: [
        '_checkFormValidity(model.*)'
      ],

      ready: function () {
        this._getDoctors();
        Polymer.dom(this.root).querySelectorAll('.input').forEach(field => field.autoValidate = true);
      },

      _getDoctors: function () {
        PatientPortal.http.get('/doctors')
        // add fullName property for combobox
          .then(doctors => {
            this.doctors = doctors.map(this._addFullNameToDoctor);
            this.setDoctor();
          });
      },

      _patientChanged: function () {
        if (this.patient) {
          this.model = Object.assign({}, this.patient);
          this.set('model.birthDate', moment(this.patient.birthDate).format('YYYY-MM-DD'));
          this.setDoctor();
        }
      },

      setDoctor: function () {
        if (this.patient) {
          this.set('model.doctor', this._addFullNameToDoctor(this.patient.doctor));
        }
      },

      _addFullNameToDoctor: function (doc) {
        doc.fullName = `${doc.lastName}, ${doc.firstName}`;
        return doc;
      },


      _checkFormValidity: function () {
        this.valid = !Polymer.dom(this.root).querySelectorAll('.input').find(input => input.invalid);
      },

      save: function () {
        if (this.model.id) {
          PatientPortal.http.post('/patients/' + this.model.id, this.model)
            .then(() => {
              this.fire('patients-updated');
              this.close();
            })
            .catch(err => console.log(err));
        } else {
          PatientPortal.http.put('/patients', this.model)
            .then(() => {
              this.fire('patients-updated');
              this.close();
            })
            .catch(err => console.log(err));
        }
      },

      close: function () {
        this.set('route.path', '/profile');
      }
    });
  </script>
</dom-module><dom-module id="patient-journal" assetpath="/">
  <template>
    <style include="shared-styles">
      :host {
        display: flex;
        flex-direction: column;
      }
      
      vaadin-grid {
        flex: 1;
      }
      
      .top {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .details {
        padding: 0 25px 25px 25px;
      }
      
      .details h3 {
        text-transform: uppercase;
        font-size: 0.8rem;
      }
      
      .details article {
        white-space: normal;
      }
      
      .cell-wrapper {
        display: flex;
        flex-wrap: wrap;
      }
      
      .cell-wrapper div {
        width: 50%;
      }
      
      .cell-wrapper .date {
        font-weight: bold;
      }
      
      .cell-wrapper .appointment,
      .cell-wrapper .doctor {
        text-align: right;
      }
      
      .cell-wrapper .doctor-label {
        text-transform: uppercase;
        font-size: 0.8rem;
        font-weight: bold;
      }
    </style>

    <iron-media-query query="(max-width: 600px)" query-matches="{{narrow}}"></iron-media-query>

    <div class="top">
      <h2>[[patient.firstName]] [[patient.lastName]]</h2>
      <a class="button primary" href="[[route.prefix]]/new-entry">
        <iron-icon icon="plus"></iron-icon> New entry</a>
    </div>


    <vaadin-grid id="grid" items="[[entries]]">
      <vaadin-grid-column width="50px" flex="0">
        <template class="header"></template>
        <template>
          <paper-icon-button icon="[[_expandIcon(expanded)]]" on-tap="_toggleExpand"></paper-icon-button>
        </template>
      </vaadin-grid-column>

      <vaadin-grid-column hidden="[[!narrow]]">
        <template class="header">Journal Entries</template>
        <template>
          <div class="cell-wrapper">
            <div class="date">{{formatDate(item.date)}}</div>
            <div class="appointment">{{capitalize(item.appointmentType)}}</div>
            <div class="doctor-label">Doctor</div>
            <div class="doctor">{{item.doctor.lastName}}, {{item.doctor.firstName}}</div>
          </div>
        </template>
      </vaadin-grid-column>

      <vaadin-grid-column hidden="[[narrow]]">
        <template class="header">
          <vaadin-grid-sorter path="date">
            Date
          </vaadin-grid-sorter>
        </template>
        <template>[[formatDate(item.date)]]</template>
      </vaadin-grid-column>
      <vaadin-grid-column hidden="[[narrow]]">
        <template class="header">
          <vaadin-grid-sorter path="appointmentType">
            Appointment
          </vaadin-grid-sorter>
        </template>
        <template>[[capitalize(item.appointmentType)]]</template>
      </vaadin-grid-column>
      <vaadin-grid-column hidden="[[narrow]]">
        <template class="header">
          <vaadin-grid-sorter path="doctor.lastName">
            Doctor
          </vaadin-grid-sorter>
        </template>
        <template>[[item.doctor.lastName]], [[item.doctor.firstName]]</template>
      </vaadin-grid-column>
      <vaadin-grid-column hidden="[[narrow]]">
        <template class="header">
          <vaadin-grid-sorter path="entry">
            Notes
          </vaadin-grid-sorter>
        </template>
        <template>[[item.entry]]</template>
      </vaadin-grid-column>

      <template class="row-details">
        <section class="details">
          <h3>Notes</h3>
          <article>[[item.entry]]</article>
        </section>
      </template>
    </vaadin-grid>
  </template>
  <script>
    Polymer({
      is: 'patient-journal',
      behaviors: [PatientPortal.Formatters],
      properties: {
        route: Object,
        patient: {
          type: Object,
          notify: true
        },
        entries: Array
      },

      _expandIcon: function(expanded){
        return expanded ? 'chevron-down' : 'chevron-right';
      },

      _toggleExpand: function(evt) {
        const item = evt.model.item;
        if(this.$.grid.expandedItems && this.$.grid.expandedItems.includes(item)){
          this.$.grid.expandedItems = [];
        } else {
          this.$.grid.expandedItems = [item];
        }
      }
    });
  </script>
</dom-module><dom-module id="journal-editor" assetpath="/">
  <template>
    <style include="shared-styles">
      :host {
        display: block;
      }

      header {
        width: 100%;
        display: flex;
        align-items: center;
      }

      header h1 {
        color: #9DD22D;
        text-transform: uppercase;
        display: inline-block;
        margin: 1rem auto;
        border-bottom: 2px solid #9DD22D;
        padding-bottom: 0.25rem;
        font-size: 1.2rem;
      }

      .edit-form {
        width: 90%;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
      }

      .edit-form .details {
        width: 80%;
        margin: 0 auto;
      }

      .field.notes {
        width: 100%;
      }

      .buttons {
        margin: 3rem auto;
      }

      .buttons button {
        margin-right: 1rem;
      }

      .buttons button:last-child {
        margin-right: 0;
      }

      @media (max-width: 600px) {
        .edit-form {
          width: 90%;
        }

        .edit-form .details {
          width: 100%;
        }
      }

    </style>
    <header>
      <h1>New Journal Entry</h1>
      <paper-icon-button icon="close" on-tap="close" class="close-button"></paper-icon-button>
    </header>

    <div class="edit-form">

      <div class="details">
        <div class="field">
          <label>Patient</label>
          <span>[[patient.lastName]], [[patient.firstName]]</span>
        </div>

        <div class="field">
          <label for="date">Date</label>
          <vaadin-date-picker id="date" required="" value="{{model.date}}"></vaadin-date-picker>
        </div>

        <div class="field">
          <label for="appointment">Appointment</label>
          <vaadin-combo-box id="appointment" required="" value="{{model.appointmentType}}" items="[[appointmentTypes]]">
          </vaadin-combo-box>
        </div>

        <div class="field">
          <label for="doctor">Doctor</label>
          <vaadin-combo-box id="doctor" items="[[doctors]]" item-label-path="fullName" item-value-path="id" selected-item="{{model.doctor}}" class="input" required=""></vaadin-combo-box>
        </div>
      </div>

      <div class="spacer"></div>

      <div class="field stacked centered notes">
        <label for="entry">Notes</label>
        <textarea id="entry" rows="15" name="entry" value="{{model.entry::input}}">    </textarea>
      </div>

      <div class="buttons">
        <button class="primary" disabled="[[!valid]]" on-tap="save">Save</button>
        <a class="button" on-tap="close">Cancel</a>
      </div>

    </div>
  </template>
  <script>
    Polymer({
      is: 'journal-editor',
      properties: {
        patient: {
          type: Object,
          notify: true,
          observer: '_resetModel'
        },
        model: {
          type: Object
        },
        route: Object,
        doctors: Array,
        appointmentTypes: {
          type: Array,
          value: function () {
            return [
              {
                label: 'New patient',
                value: 'NEW_PATIENT'
              }, {
                label: 'X-ray',
                value: 'X_RAY'
              }, {
                label: 'Surgery',
                value: 'SURGERY'
              }, {
                label: 'Follow up',
                value: 'FOLLOW_UP'
              }
            ]
          }
        }
      },

      ready: function () {
        this._getDoctors();
      },

      _resetModel: function () {
        this.model = {
          date: moment().format('YYYY-MM-DD'),
          entry: ''
        };
      },

      _getDoctors: function () {
        PatientPortal.http.get('/doctors')
        // add fullName property for combobox
          .then(doctors => {
            this.doctors = doctors.map(doc => {
              doc.fullName = `${doc.lastName}, ${doc.firstName}`;
              return doc;
            });
          });
      },

      save: function () {
        PatientPortal.http.put(`${this.route.prefix}/journalentries`, this.model)
          .then(() => {
            this.fire('new-entry');
            this.set('route.path', '/journal');
            this._resetModel();
          })
          .catch(err => console.log(err));
      },

      close: function () {
        this.set('route.path', '/journal');
      }
    });
  </script>
</dom-module>
<dom-module id="patient-details" assetpath="./">
  <template>
    <style include="shared-styles">
      :host {
        display: flex;
        flex-direction: column;
        height: 100vh;
        position: relative;
      }

      nav[hidden].details-nav {
        display: none;
      }

      nav.details-nav {
        display: flex;
        width: 100%;
        justify-content: space-between;
        text-transform: uppercase;
        margin-bottom: 50px;
      }

      nav.details-nav a {
        padding-bottom: 4px;
      }

      nav.details-nav .sub-pages a {
        color: #B5B9BC;
        margin-right: 16px;
      }

      nav.details-nav .sub-pages a.active {
        color: #9DD22D;
        border-bottom: 2px solid #9DD22D;
      }

      nav.details-nav .sub-pages a:last-child {
        margin-right: 0;
      }

      .content {
        flex: 1;
        flex-direction: column;
        display: flex;
        overflow-y: scroll;
      }

      .content > * {
        flex: 1;
      }

      @media (max-width: 600px) {
        nav.details-nav .linktext {
          display: none;
        }
      }
    </style>
    <app-route route="{{route}}" active="{{active}}" pattern="/:page" data="{{routeData}}" tail="{{subroute}}"></app-route>

    <nav class="details-nav" hidden="[[pageActive(page, 'edit', 'new-entry')]]">
      <a on-tap="goBack">
        <iron-icon icon="arrow-long-left"></iron-icon>
        <span class="linktext">All patients</span></a>
      <div class="sub-pages">
        <a href$="[[route.prefix]]/profile" class$="[[_getItemClasses('profile', page)]]">Profile</a>
        <a href$="[[route.prefix]]/journal" class$="[[_getItemClasses('journal', page)]]">Journal</a>
      </div>
      <a href$="[[route.prefix]]/edit">Edit patient</a>
    </nav>
    <iron-pages class="content" selected="[[page]]" fallback-selection="profile" attr-for-selected="name" role="main">
      <patient-profile name="profile" patient="[[patient]]" route="{{route}}"></patient-profile>
      <patient-journal name="journal" patient="[[patient]]" route="{{route}}" entries="[[journalEntries]]"></patient-journal>
      <patient-editor name="edit" patient="[[patient]]" route="{{route}}"></patient-editor>
      <journal-editor name="new-entry" patient="[[patient]]" route="{{route}}"></journal-editor>
    </iron-pages>

  </template>
  <script>
    Polymer({
      is: 'patient-details',
      behaviors: [PatientPortal.NavHelpers],
      properties: {
        patient: {
          type: Object,
          notify: true,
          observer: '_updateJournalEntries'
        },
        journalEntries: Array,
        route: {
          type: Object,
          notify: true,
          observer: 'routeChanged',
          value: function () {
            return {}
          }
        },
        page: {
          type: String
        }
      },

      created: function () {
        this.routing = new Map([
          ['profile', 'patient-profile.html'],
          ['journal', 'patient-journal.html'],
          ['new', 'patient-editor.html'],
          ['edit', 'patient-editor.html'],
          ['new-entry', 'journal-editor.html'],
        ]);
      },

      observers: [
        '_routePageChanged(routeData.page)'
      ],

      listeners: {
        'new-entry': '_updateJournalEntries'
      },

      routeChanged: function () {
        if (this.route.path === '' && !this.page) {
          this.set('route.path', '/profile');
        }
      },

      goBack: function () {
        this.patient = null;
      },

      _updateEntries: function () {
        if(this.patient){
          PatientPortal.http.get(`/patients/${this.patient.id}/journalentries`)
            .then(entries => this.entries = entries);
        }
      },

      _routePageChanged: function (page) {
        if (page) {
          this.page = page;
        }
      },

      _updateJournalEntries: function () {
        if(this.patient){
          PatientPortal.http.get(`/patients/${this.patient.id}/journalentries`)
            .then(entries => this.journalEntries = entries);
        }
      },

      _getItemClasses: function (link, page) {
        return 'item ' + (link === page ? 'active' : '');
      },

      _editing: function () {
        return this.page.indexOf('edit') >= 0 || this.page.indexOf('new') >= 0;
      }
    });
  </script>
</dom-module></div><dom-module id="patients-view">
  <template>
    <style include="shared-styles">
      :host {
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      
      vaadin-grid {
        flex: 1;
        height: 100%;
      }
      
      patient-details {
        position: absolute;
        box-sizing: border-box;
        padding: 16px;
        height: 100vh;
        top: 0;
        background: #fff;
        border-left: 5px solid #434D54;
        display: none;
      }
      
      patient-details.open {
        display: inherit;
        left: 25%;
        right: 0;
        box-shadow: 2px 2px 10px 8px rgba(0, 0, 0, 0.2);
      }
      
      .details-row label {
        width: 50%;
        text-align: right;
        padding-right: 0.5rem;
        margin-bottom: 0;
      }
      
      @media (max-width: 600px) {
        patient-details.open {
          left: 0;
          box-shadow: none;
          border: none;
        }
      }
    </style>
    <app-route route="{{route}}" pattern="/:id" data="{{routeData}}" tail="{{subroute}}" active="{{routeActive}}"></app-route>

    <iron-media-query query="(max-width: 600px)" query-matches="{{narrow}}"></iron-media-query>
    <vaadin-grid id="grid" data-source="[[_fetchPatients]]" active-item="{{currentPatient}}" size="100" page-size="20">
      <template class="row-details">
        <div class="details-row">
          <div class="field">
            <label>Id</label>
            <span>{{item.id}}</span>
          </div>
          <div class="field">
            <label>Medical record</label>
            <span>{{item.medicalRecord}}</span>
          </div>
          <div class="field">
            <label>Doctor</label>
            <span>{{item.doctor.lastName}}, {{item.doctor.firstName}}</span>
          </div>
          <div class="field">
            <label>Last entry</label>
            <span>[[formatDate(item.lastEntry)]]</span>
          </div>
        </div>
      </template>

      <vaadin-grid-column width="50px" flex="0" hidden="[[!narrow]]">
        <template class="header"></template>
        <template>
          <paper-icon-button icon="[[_expandIcon(expanded)]]" on-tap="_toggleExpand"></paper-icon-button>
        </template>
      </vaadin-grid-column>

      <vaadin-grid-column>
        <template class="header">
          <vaadin-grid-sorter path="lastName">
            Name
          </vaadin-grid-sorter>
        </template>
        <template>
          <b>[[item.lastName]], [[item.firstName]]</b>
        </template>
      </vaadin-grid-column>

      <vaadin-grid-column width="40px" hidden="[[narrow]]">
        <template class="header">
          <vaadin-grid-sorter path="id">
            Id
          </vaadin-grid-sorter>
        </template>
        <template>[[item.id]]</template>
      </vaadin-grid-column>
      <vaadin-grid-column hidden="[[narrow]]">
        <template class="header">
          <vaadin-grid-sorter path="medicalRecord">
            Medical Record
          </vaadin-grid-sorter>
        </template>
        <template>[[item.medicalRecord]]</template>
      </vaadin-grid-column>
      <vaadin-grid-column hidden="[[narrow]]">
        <template class="header">
          <vaadin-grid-sorter path="doctor.lastName">
            Doctor
          </vaadin-grid-sorter>
        </template>
        <template>[[item.doctor.lastName]], [[item.doctor.firstName]]</template>
      </vaadin-grid-column>
      <vaadin-grid-column hidden="[[narrow]]">
        <template class="header">
          <vaadin-grid-sorter path="lastEntry">
            Last Entry
          </vaadin-grid-sorter>
        </template>
        <template>[[formatDate(item.lastEntry)]]</template>
      </vaadin-grid-column>
    </vaadin-grid>

    <patient-details class$="[[_detailsOpen(currentPatient)]]" patient="{{currentPatient}}" route="{{subroute}}"></patient-details>
  </template>
  <script>
    Polymer({
      is: 'patients-view',
      behaviors: [PatientPortal.Formatters],
      properties: {
        patients: {
          type: Array,
          notify: true
        },
        currentPatient: {
          type: Object,
          notify: true,
          observer: '_patientChanged'
        },
        route: {
          type: Object,
          notify: true
        },
        active: Boolean,
        narrow: Boolean,
        _fetchPatients: {
          notify: true,
          value: function () {
            return function (params, callback) {
              function getSortParams() {
                return params.sortOrder.map(sortOrder => `sort=${sortOrder.path},${sortOrder.direction}`).join('&');
              }

              if (callback) PatientPortal.http.get(`/patients?page=${params.page}&limit=${params.pageSize}&${getSortParams()}`)
                .then(res => {
                  this.$.grid.size = res.totalElements;
                  callback(res.content);
                });
            }.bind(this);
          }
        }
      },

      ready: function () {
        this._updatePatients();
      },

      observers: [
        '_setPatientFromURL(routeData.id)'
      ],

      listeners: {
        'patients-updated': '_updatePatients'
      },

      _setPatientFromURL: function () {
        if (!this.active) return;
        const id = +this.routeData.id;
        if (id && this.patients && this.patients.length > 0 &&
          (!this.currentPatient || this.currentPatient && this.currentPatient.id !== id)) {
          this.currentPatient = this.patients.find(p => p.id === id);
          this._selectPatient(this.currentPatient);
        }
      },

      _patientChanged: function (patient) {
        // Grid fires an initial null selection when initialized which messes up everything
        if (!this.gridInited) {
          this.gridInited = true;
          return;
        }

        if (this.currentPatient && this.currentPatient.id === this.routeData.id) {
          return;
        }

        this._selectPatient(patient);

        if (this.routeActive) {
          this.set('routeData.id', (patient ? patient.id : ''));
        } else {
          this.set('route.path', '/' + (patient ? patient.id : ''));
        }
      },

      _updatePatients: function () {
        this.$.grid.clearCache();
        // TODO: re-select selected item
      },

      _selectPatient: function (patient) {
        this.$.grid.selectedItems = patient ? [patient] : [];
      },

      _detailsOpen: function (currentPatient) {
        return currentPatient ? 'open' : '';
      },

      _expandIcon: function (expanded) {
        return expanded ? 'chevron-down' : 'chevron-right'
      },

      _toggleExpand: function (evt) {
        const item = evt.model.item;
        if (this.$.grid.expandedItems && this.$.grid.expandedItems.includes(item)) {
          this.$.grid.expandedItems = [];
        } else {
          this.$.grid.expandedItems = [item];
        }
      }
    });
  </script>
</dom-module></body></html>